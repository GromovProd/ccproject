
ccRx.elf:     file format elf32-littlearm
ccRx.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000841

Program Header:
    LOAD off    0x00008000 vaddr 0x08000000 paddr 0x08000000 align 2**15
         filesz 0x00001940 memsz 0x00001940 flags rwx
    LOAD off    0x00010800 vaddr 0x20000800 paddr 0x08001940 align 2**15
         filesz 0x00000000 memsz 0x00000840 flags rw-
    LOAD off    0x00010000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000800 flags rw-
private flags = 5000002: [Version5 EABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 startup       000000f4  08000000  08000000  00008000  2**4  CONTENTS, ALLOC, LOAD, DATA
  1 constructors  00000004  080000f4  080000f4  000080f4  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .text         00001840  08000100  08000100  00008100  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .stacks       00000800  20000000  20000000  00010000  2**0  ALLOC
  4 .bss          00000840  20000800  08001940  00010800  2**3  ALLOC
  5 .debug_info   0000e1bd  00000000  00000000  00009940  2**0  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002c8a  00000000  00000000  00017afd  2**0  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000359e  00000000  00000000  0001a787  2**0  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000005d0  00000000  00000000  0001dd25  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000b50  00000000  00000000  0001e2f5  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00002846  00000000  00000000  0001ee45  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003221  00000000  00000000  0002168b  2**0  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000070  00000000  00000000  000248ac  2**0  CONTENTS, READONLY
 13 .ARM.attributes 00000033  00000000  00000000  0002491c  2**0  CONTENTS, READONLY
 14 .debug_frame  00000d38  00000000  00000000  00024950  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  startup	00000000 startup
080000f4 l    d  constructors	00000000 constructors
08000100 l    d  .text	00000000 .text
20000000 l    d  .stacks	00000000 .stacks
20000800 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00000000 l    df *ABS*	00000000 cmd_uart.cpp
08000100 l     F .text	00000024 _GLOBAL__sub_I_Uart
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 chschd.c
080002e0 l     F .text	00000034 wakeup
00000000 l    df *ABS*	00000000 chsys.c
20000800 l     O .bss	00000028 mainthread.4583
00000000 l    df *ABS*	00000000 chthreads.c
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 chcore_v7m.c
080006f4 l       .text	00000000 _port_exit_from_isr
00000000 l    df *ABS*	00000000 crt0.c
00000000 l    df *ABS*	00000000 hal.c
00000000 l    df *ABS*	00000000 hal_lld.cpp
00000000 l    df *ABS*	00000000 nvic.c
00000000 l    df *ABS*	00000000 stm32_dma.c
20000828 l     O .bss	00000038 dma_isr_redir
20000860 l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 clocking_L1xx.cpp
00000000 l    df *ABS*	00000000 kl_lib_L15x.cpp
08001020 l     F .text	0000001c CmdUart_t::PrintNow(char const*) [clone .isra.12]
00000000 l    df *ABS*	00000000 cc1101.cpp
08001070 l     F .text	00000010 cc1101_t::BusyWait() [clone .isra.6]
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 
20001040 l       .bss	00000000 __heap_base__
08001940 l       .text	00000000 _etext
20004000 l       *ABS*	00000000 __heap_end__
00004000 l       *ABS*	00000000 __ram_size__
00000000 l       startup	00000000 _text
20000000 l       startup	00000000 __ram_start__
20004000 l       *ABS*	00000000 __ram_end__
20001040 l       .bss	00000000 _end
00000400 l       *ABS*	00000000 __main_stack_size__
00000400 l       *ABS*	00000000 __process_stack_size__
08000c20  w    F .text	00000002 Vector58
08000c20  w    F .text	00000002 VectorE8
08000c20  w    F .text	00000002 Vector9C
08000980 g     F .text	00000046 nvicEnableVector
08000db0 g     F .text	00000034 SetupVCore(VCore_t)
08000c20  w    F .text	00000002 VectorAC
08000630 g     F .text	0000000a chThdExit
080004d0 g     F .text	00000050 chSysTimerHandlerI
08000340 g     F .text	0000003c chSchGoSleepTimeoutS
08000c20  w    F .text	00000002 Vector5C
08000c20  w    F .text	00000002 NMIVector
08000b50 g     F .text	00000038 dmaInit
08000c20  w    F .text	00000002 Vector8C
08000c20  w    F .text	00000002 VectorDC
08000000 g     O startup	000000f4 _vectors
080010e0 g     F .text	00000068 cc1101_t::ReadFIFO(rPkt_t*)
20000f6d g     O .bss	00000002 PktRx
08000320 g     F .text	00000020 chSchGoSleepS
08000df0 g     F .text	0000003c CmdUart_t::ISendViaDMA()
08000550 g     F .text	00000048 chThdCreateI
08000c20  w    F .text	00000002 VectorC8
08000380 g     F .text	00000038 chSchWakeupS
08000280 g     F .text	00000014 _scheduler_init
080005a0 g     F .text	00000028 chThdCreateStatic
08000c20  w    F .text	00000002 Vector94
08000c20  w    F .text	00000002 VectorA8
08000c20  w    F .text	00000002 VectorB4
080002a0 g     F .text	00000038 chSchReadyI
080000f8 g       constructors	00000000 __fini_array_end
20000800 g       .stacks	00000000 __main_thread_stack_end__
08000640 g     F .text	00000018 _vt_init
08000a60 g     F .text	0000002c Vector74
08000900 g     F .text	00000004 halInit
08000c20  w    F .text	00000002 VectorEC
20000800 g       .bss	00000000 _bss_start
080003c0 g     F .text	00000030 chSchDoRescheduleBehind
08000c20  w    F .text	00000002 UsageFaultVector
08000c20  w    F .text	00000002 DebugMonitorVector
08000c20  w    F .text	00000002 Vector40
08000840 g     F .text	000000c0 ResetHandler
08000c20  w    F .text	00000002 VectorBC
08000720 g     F .text	00000034 _port_init
08000910 g     F .text	00000064 hal_lld_init
08000600 g     F .text	00000030 chThdExitS
08001630 g     F .text	00000040 cc1101_t::IGdo0IrqHandler()
08000c20  w    F .text	00000002 PendSVVector
08001250 g     F .text	0000016e cc1101_t::RfConfig()
08000660 g     F .text	0000004c chVTSetI
08001670 g     F .text	00000014 Vector64
20001040 g       .bss	00000000 _bss_end
08000830  w    F .text	00000002 _default_exit
08000fb0 g     F .text	00000054 CmdUart_t::IRQDmaTxHandler()
08000c20  w    F .text	00000002 VectorCC
08000c20  w    F .text	00000002 Vector54
08000c20  w    F .text	00000002 Vector98
08000c20  w    F .text	00000002 VectorD8
08000c20  w    F .text	00000002 Vector24
08001180 g     F .text	0000002c cc1101_t::WriteStrobe(unsigned char)
08000430 g     F .text	00000014 chSchDoReschedule
08000470 g     F .text	00000058 chSysInit
080005d0 g     F .text	00000028 chThdSleep
08001890 g     O .text	00000054 _stm32_dma_streams
08000b20 g     F .text	0000002c Vector84
080007d0 g     F .text	0000001a SysTickVector
20000874 g     O .bss	000006d0 Uart
08000c20  w    F .text	00000002 BusFaultVector
08000d80 g     F .text	0000002c Clk_t::SwitchToHSI()
08000c20  w    F .text	00000002 VectorD0
08000c60 g     F .text	00000114 Clk_t::UpdateFreqValues()
080013c0 g     F .text	0000024c cc1101_t::Init()
08000c20  w    F .text	00000002 VectorE4
08000c20  w    F .text	00000002 VectorC0
20000f6c g     O .bss	00000001 isON
080007f0 g     F .text	00000010 _port_switch
08000700 g     F .text	00000012 SVCallVector
08000820  w    F .text	00000002 __late_init
08001040 g     F .text	0000002c chDbgPanic
20001030 g     O .bss	00000010 vtlist
08001150 g     F .text	00000030 cc1101_t::WriteRegister(unsigned char, unsigned char)
08000c20  w    F .text	00000002 HardFaultVector
08000760 g     F .text	00000068 _port_irq_epilogue
08000e30 g     F .text	00000174 CmdUart_t::Init(unsigned long)
08000c20  w    F .text	00000002 VectorF0
20000868 g     O .bss	0000000c Clk
08001080  w    F .text	00000010 Spi_t::ReadWriteByte(unsigned char)
08001940 g       .text	00000000 _textdata
08000c20  w    F .text	00000002 VectorE0
08000c20  w    F .text	00000002 MemManageVector
080000f8 g       constructors	00000000 __fini_array_start
20000f44 g     O .bss	00000028 CC
08001690 g     F .text	00000094 memset
08000130 g     F .text	00000144 main
08000a00 g     F .text	00000028 Vector6C
20000f70 g     O .bss	0000001c rlist
08000c20  w    F .text	00000002 VectorA0
080011f0 g     F .text	0000005c cc1101_t::ReceiveSync(unsigned long, rPkt_t*)
080000f8 g       constructors	00000000 __init_array_end
08000c20  w    F .text	00000002 VectorC4
08000ac0 g     F .text	0000002c Vector7C
08000450 g     F .text	00000014 _idle_thread
08000c20  w    F .text	00000002 VectorB0
08001760 g     O .text	00000016 ch_debug
080011d0 g     F .text	0000001e cc1101_t::SetChannel(unsigned char)
08000c20  w    F .text	00000002 Vector90
08000800 g     F .text	00000010 _port_thread_start
08000c20  w    F .text	00000002 Vector60
08000c20  w    F .text	00000002 Vector1C
080003f0 g     F .text	00000038 chSchDoRescheduleAhead
08000c20  w    F .text	00000002 Vector48
20000400 g       .stacks	00000000 __process_stack_base__
08001090 g     F .text	00000018 cc1101_t::RSSI_dBm(unsigned char)
20000864 g     O .bss	00000001 VCore
08000a30 g     F .text	00000028 Vector70
08000c20  w    F .text	00000002 VectorD4
080009d0 g     F .text	00000026 nvicSetSystemHandlerPriority
20000f90 g     O .bss	000000a0 _idle_thread_wa
20000800 g       .bss	00000000 _data
08001010 g     F .text	0000000c CmdUartTxIrq
08000c20  w    F .text	00000002 Vector4C
08000af0 g     F .text	0000002c Vector80
080006f0 g     F .text	00000006 _port_switch_from_isr
08000c20  w    F .text	00000002 Vector68
20000400 g       .stacks	00000000 __main_stack_end__
08000a90 g     F .text	0000002c Vector78
20000800 g       .bss	00000000 _edata
08000c30 g     F .text	00000028 Clk_t::EnableHSI()
080006b0 g     F .text	00000040 chVTResetI
08000c20 g     F .text	00000002 _unhandled_exception
08000c20  w    F .text	00000002 Vector88
20000400 g       .stacks	00000000 __main_thread_stack_base__
08001610 g     F .text	00000014 cc1101_t::IHandleAsync()
080000f4 g       constructors	00000000 __init_array_start
08000520 g     F .text	00000024 _thread_init
08000c20  w    F .text	00000002 Vector50
08000b90 g     F .text	00000088 dmaStreamAllocate
080011b0  w    F .text	00000012 cc1101_t::EnterIdle()
20000000 g       .stacks	00000000 __main_stack_base__
08000c20  w    F .text	00000002 Vector44
08000c20  w    F .text	00000002 Vector28
08000c20  w    F .text	00000002 VectorB8
20000800 g       .stacks	00000000 __process_stack_end__
080010b0 g     F .text	0000002c cc1101_t::ReadRegister(unsigned char)
08000c20  w    F .text	00000002 Vector34
08000810  w    F .text	00000002 __early_init
08000c20  w    F .text	00000002 VectorA4
08000c20  w    F .text	00000002 Vector20



Disassembly of section .text:

08000100 <_GLOBAL__sub_I_Uart>:
CmdUart_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.h:81
    uint8_t TryConvertTokenToNumber( int32_t *POutput) { return Convert::TryStrToInt32(Token, POutput); }
    bool NameIs(const char *SCmd) { return (strcasecmp(Name, SCmd) == 0); }
    friend class CmdUart_t;
};

class CmdUart_t {
 8000100:	4b07      	ldr	r3, [pc, #28]	; (8000120 <_GLOBAL__sub_I_Uart+0x20>)
 8000102:	2200      	movs	r2, #0
 8000104:	f8c3 25f0 	str.w	r2, [r3, #1520]	; 0x5f0
 8000108:	f8c3 25f4 	str.w	r2, [r3, #1524]	; 0x5f4
 800010c:	f503 62c8 	add.w	r2, r3, #1600	; 0x640
 8000110:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
 8000114:	f203 6284 	addw	r2, r3, #1668	; 0x684
 8000118:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
 800011c:	4770      	bx	lr
 800011e:	bf00      	nop
 8000120:	20000874 	.word	0x20000874
	...

08000130 <main>:
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:21
#include "Radio/cc1101.h"

rPkt_t PktRx;

bool isON = false;
int main(void) {
 8000130:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:23
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V5);
 8000132:	2002      	movs	r0, #2
 8000134:	f000 fe3c 	bl	8000db0 <SetupVCore(VCore_t)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:24
    Clk.EnableHSI();
 8000138:	4846      	ldr	r0, [pc, #280]	; (8000254 <main+0x124>)
 800013a:	f000 fd79 	bl	8000c30 <Clk_t::EnableHSI()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:25
    Clk.SwitchToHSI();
 800013e:	4845      	ldr	r0, [pc, #276]	; (8000254 <main+0x124>)
 8000140:	f000 fe1e 	bl	8000d80 <Clk_t::SwitchToHSI()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:26
    Clk.UpdateFreqValues();
 8000144:	4843      	ldr	r0, [pc, #268]	; (8000254 <main+0x124>)
 8000146:	f000 fd8b 	bl	8000c60 <Clk_t::UpdateFreqValues()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:29

    // ==== Init OS ====
    halInit();
 800014a:	f000 fbd9 	bl	8000900 <halInit>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:30
    chSysInit();
 800014e:	f000 f98f 	bl	8000470 <chSysInit>
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:183
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8000152:	4a41      	ldr	r2, [pc, #260]	; (8000258 <main+0x128>)
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000154:	4c41      	ldr	r4, [pc, #260]	; (800025c <main+0x12c>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:183
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8000156:	69d3      	ldr	r3, [r2, #28]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:36

    // ==== Init Hard & Soft ====
    PinSetupOut(GPIOB, 1, omPushPull, pudNone);
    PinSetupOut(GPIOB, 0, omPushPull, pudNone);

    Uart.Init(115200);
 8000158:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:183
 800015c:	f043 0302 	orr.w	r3, r3, #2
 8000160:	61d3      	str	r3, [r2, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000162:	6823      	ldr	r3, [r4, #0]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:36
 8000164:	483e      	ldr	r0, [pc, #248]	; (8000260 <main+0x130>)
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
 8000166:	f023 030c 	bic.w	r3, r3, #12
 800016a:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:199
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 800016c:	6823      	ldr	r3, [r4, #0]
 800016e:	f043 0304 	orr.w	r3, r3, #4
 8000172:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:201
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000174:	88a3      	ldrh	r3, [r4, #4]
 8000176:	f023 0302 	bic.w	r3, r3, #2
 800017a:	041b      	lsls	r3, r3, #16
 800017c:	0c1b      	lsrs	r3, r3, #16
 800017e:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:202
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000180:	88a3      	ldrh	r3, [r4, #4]
 8000182:	b29b      	uxth	r3, r3
 8000184:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:204
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000186:	68e3      	ldr	r3, [r4, #12]
 8000188:	f023 030c 	bic.w	r3, r3, #12
 800018c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:205
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800018e:	68e3      	ldr	r3, [r4, #12]
 8000190:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:207
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000192:	68a3      	ldr	r3, [r4, #8]
 8000194:	f023 030c 	bic.w	r3, r3, #12
 8000198:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:208
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800019a:	68a3      	ldr	r3, [r4, #8]
 800019c:	f043 030c 	orr.w	r3, r3, #12
 80001a0:	60a3      	str	r3, [r4, #8]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:183
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 80001a2:	69d3      	ldr	r3, [r2, #28]
 80001a4:	f043 0302 	orr.w	r3, r3, #2
 80001a8:	61d3      	str	r3, [r2, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80001aa:	6823      	ldr	r3, [r4, #0]
 80001ac:	f023 0303 	bic.w	r3, r3, #3
 80001b0:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:199
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 80001b2:	6823      	ldr	r3, [r4, #0]
 80001b4:	f043 0301 	orr.w	r3, r3, #1
 80001b8:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:201
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80001ba:	88a3      	ldrh	r3, [r4, #4]
 80001bc:	f023 0301 	bic.w	r3, r3, #1
 80001c0:	041b      	lsls	r3, r3, #16
 80001c2:	0c1b      	lsrs	r3, r3, #16
 80001c4:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:202
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80001c6:	88a3      	ldrh	r3, [r4, #4]
 80001c8:	b29b      	uxth	r3, r3
 80001ca:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:204
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80001cc:	68e3      	ldr	r3, [r4, #12]
 80001ce:	f023 0303 	bic.w	r3, r3, #3
 80001d2:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:205
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80001d4:	68e3      	ldr	r3, [r4, #12]
 80001d6:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:207
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80001d8:	68a3      	ldr	r3, [r4, #8]
 80001da:	f023 0303 	bic.w	r3, r3, #3
 80001de:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:208
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80001e0:	68a3      	ldr	r3, [r4, #8]
 80001e2:	f043 0303 	orr.w	r3, r3, #3
 80001e6:	60a3      	str	r3, [r4, #8]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:36
 80001e8:	f000 fe22 	bl	8000e30 <CmdUart_t::Init(unsigned long)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:38

    CC.Init();
 80001ec:	481d      	ldr	r0, [pc, #116]	; (8000264 <main+0x134>)
 80001ee:	f001 f8e7 	bl	80013c0 <cc1101_t::Init()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:39
    CC.SetChannel(CHANNEL_ZERO);
 80001f2:	481c      	ldr	r0, [pc, #112]	; (8000264 <main+0x134>)
 80001f4:	2100      	movs	r1, #0
 80001f6:	f000 ffeb 	bl	80011d0 <cc1101_t::SetChannel(unsigned char)>
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:68
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 80001fa:	4d1a      	ldr	r5, [pc, #104]	; (8000264 <main+0x134>)
 80001fc:	782b      	ldrb	r3, [r5, #0]
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:65
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 80001fe:	4628      	mov	r0, r5
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:68
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 8000200:	b133      	cbz	r3, 8000210 <main+0xe0>
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:65
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 8000202:	2136      	movs	r1, #54	; 0x36
 8000204:	f000 ffbc 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
 8000208:	2300      	movs	r3, #0
 800020a:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 800020e:	e7f4      	b.n	80001fa <main+0xca>
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:69
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
        WriteStrobe(CC_SCAL);
 8000210:	2133      	movs	r1, #51	; 0x33
 8000212:	f000 ffb5 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
PinIsSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:179
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 8000216:	4b14      	ldr	r3, [pc, #80]	; (8000268 <main+0x138>)
 8000218:	8a1b      	ldrh	r3, [r3, #16]
_ZN8cc1101_t8BusyWaitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:38
    PinIrq_t IGdo2; //new
    void CsHi() { PinSet(CC_GPIO, CC_CS); }
    void CsLo() { PinClear(CC_GPIO, CC_CS); }
    bool GDO0IsHi() { return PinIsSet(CC_GPIO, CC_GDO0); }
    bool GDO2IsHi() { return PinIsSet(CC_GPIO, CC_GDO2); }
    void BusyWait() { while(PinIsSet(CC_GPIO, CC_MISO)); }
 800021a:	065b      	lsls	r3, r3, #25
 800021c:	d4fb      	bmi.n	8000216 <main+0xe6>
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:45
    // ==== Main cycle ====
    while(true) {

        CC.Recalibrate();

        if(CC.ReceiveSync(30, &PktRx) == OK) {
 800021e:	4811      	ldr	r0, [pc, #68]	; (8000264 <main+0x134>)
 8000220:	211e      	movs	r1, #30
 8000222:	4a12      	ldr	r2, [pc, #72]	; (800026c <main+0x13c>)
 8000224:	f000 ffe4 	bl	80011f0 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)>
 8000228:	b950      	cbnz	r0, 8000240 <main+0x110>
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800022a:	2502      	movs	r5, #2
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:47
            PinSet(GPIOB, 1);
            chThdSleepMilliseconds(2000);
 800022c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
 8000230:	8325      	strh	r5, [r4, #24]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:47
 8000232:	f000 f9cd 	bl	80005d0 <chThdSleep>
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000236:	8365      	strh	r5, [r4, #26]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:49
            PinClear(GPIOB, 1);
            chThdSleepMilliseconds(2000);
 8000238:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800023c:	f000 f9c8 	bl	80005d0 <chThdSleep>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:51
        }
        if(isON) {
 8000240:	4a0b      	ldr	r2, [pc, #44]	; (8000270 <main+0x140>)
 8000242:	2301      	movs	r3, #1
 8000244:	7811      	ldrb	r1, [r2, #0]
 8000246:	b111      	cbz	r1, 800024e <main+0x11e>
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000248:	8323      	strh	r3, [r4, #24]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:57
            PinSet(GPIOB, 0);
        }
        else {
            PinClear(GPIOB, 0);
        }
        isON = isON? false : true;
 800024a:	2300      	movs	r3, #0
 800024c:	e000      	b.n	8000250 <main+0x120>
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 800024e:	8363      	strh	r3, [r4, #26]
main():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:57 (discriminator 3)
 8000250:	7013      	strb	r3, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../main.cpp:21 (discriminator 3)
#include "Radio/cc1101.h"

rPkt_t PktRx;

bool isON = false;
int main(void) {
 8000252:	e7d2      	b.n	80001fa <main+0xca>
 8000254:	20000868 	.word	0x20000868
 8000258:	40023800 	.word	0x40023800
 800025c:	40020400 	.word	0x40020400
 8000260:	20000874 	.word	0x20000874
 8000264:	20000f44 	.word	0x20000f44
 8000268:	40020000 	.word	0x40020000
 800026c:	20000f6d 	.word	0x20000f6d
 8000270:	20000f6c 	.word	0x20000f6c
	...

08000280 <_scheduler_init>:
_scheduler_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000280:	4b03      	ldr	r3, [pc, #12]	; (8000290 <_scheduler_init+0x10>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000282:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000284:	605b      	str	r3, [r3, #4]
 8000286:	601b      	str	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000288:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:60
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 800028a:	615b      	str	r3, [r3, #20]
 800028c:	611b      	str	r3, [r3, #16]
 800028e:	4770      	bx	lr
 8000290:	20000f70 	.word	0x20000f70
	...

080002a0 <chSchReadyI>:
chSchReadyI():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 80002a0:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:87
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 80002a2:	7f03      	ldrb	r3, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 80002a4:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:87
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 80002a6:	b10b      	cbz	r3, 80002ac <chSchReadyI+0xc>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:87 (discriminator 2)
 80002a8:	2b0e      	cmp	r3, #14
 80002aa:	d102      	bne.n	80002b2 <chSchReadyI+0x12>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:87 (discriminator 1)
 80002ac:	4808      	ldr	r0, [pc, #32]	; (80002d0 <chSchReadyI+0x30>)
 80002ae:	f000 fec7 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:92
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 80002b2:	2300      	movs	r3, #0
 80002b4:	7723      	strb	r3, [r4, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:96
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 80002b6:	68a1      	ldr	r1, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:93
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 80002b8:	4b06      	ldr	r3, [pc, #24]	; (80002d4 <chSchReadyI+0x34>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:95 (discriminator 1)
  do {
    cp = cp->p_next;
 80002ba:	681b      	ldr	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:96 (discriminator 1)
  } while (cp->p_prio >= tp->p_prio);
 80002bc:	689a      	ldr	r2, [r3, #8]
 80002be:	428a      	cmp	r2, r1
 80002c0:	d2fb      	bcs.n	80002ba <chSchReadyI+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:99
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80002c2:	685a      	ldr	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:98
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80002c4:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:99
  tp->p_prev = cp->p_prev;
 80002c6:	6062      	str	r2, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:102
  tp->p_prev->p_next = cp->p_prev = tp;
  return tp;
}
 80002c8:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:100
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80002ca:	605c      	str	r4, [r3, #4]
 80002cc:	6014      	str	r4, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:102
  return tp;
}
 80002ce:	bd10      	pop	{r4, pc}
 80002d0:	08001780 	.word	0x08001780
 80002d4:	20000f70 	.word	0x20000f70
	...

080002e0 <wakeup>:
wakeup():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:136

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80002e0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:139
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
 80002e2:	2320      	movs	r3, #32
 80002e4:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:140
  switch (tp->p_state) {
 80002e8:	7f03      	ldrb	r3, [r0, #28]
 80002ea:	b183      	cbz	r3, 800030e <wakeup+0x2e>
 80002ec:	2b03      	cmp	r3, #3
 80002ee:	d108      	bne.n	8000302 <wakeup+0x22>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:150
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 80002f0:	6a03      	ldr	r3, [r0, #32]
 80002f2:	689a      	ldr	r2, [r3, #8]
 80002f4:	3201      	adds	r2, #1
 80002f6:	609a      	str	r2, [r3, #8]
dequeue():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:75
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
 80002f8:	e890 000c 	ldmia.w	r0, {r2, r3}
 80002fc:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:76
  tp->p_next->p_prev = tp->p_prev;
 80002fe:	6802      	ldr	r2, [r0, #0]
 8000300:	6053      	str	r3, [r2, #4]
wakeup():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:163
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 8000302:	f04f 33ff 	mov.w	r3, #4294967295
 8000306:	6203      	str	r3, [r0, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:164
  chSchReadyI(tp);
 8000308:	f7ff ffca 	bl	80002a0 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:165
  chSysUnlockFromIsr();
 800030c:	2300      	movs	r3, #0
 800030e:	f383 8811 	msr	BASEPRI, r3
 8000312:	bd08      	pop	{r3, pc}
	...

08000320 <chSchGoSleepS>:
chSchGoSleepS():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000320:	4b06      	ldr	r3, [pc, #24]	; (800033c <chSchGoSleepS+0x1c>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 8000322:	2214      	movs	r2, #20
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000324:	6999      	ldr	r1, [r3, #24]
 8000326:	7708      	strb	r0, [r1, #28]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8000328:	6818      	ldr	r0, [r3, #0]
chSchGoSleepS():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 800032a:	778a      	strb	r2, [r1, #30]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 800032c:	6802      	ldr	r2, [r0, #0]
 800032e:	6053      	str	r3, [r2, #4]
 8000330:	601a      	str	r2, [r3, #0]
chSchGoSleepS():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:126
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 8000332:	6198      	str	r0, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:127
  currp->p_state = THD_STATE_CURRENT;
 8000334:	2301      	movs	r3, #1
 8000336:	7703      	strb	r3, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:128
  chSysSwitch(currp, otp);
 8000338:	f000 ba5a 	b.w	80007f0 <_port_switch>
 800033c:	20000f70 	.word	0x20000f70

08000340 <chSchGoSleepTimeoutS>:
chSchGoSleepTimeoutS():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000340:	b530      	push	{r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:193

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000342:	1c4b      	adds	r3, r1, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000344:	b087      	sub	sp, #28
 8000346:	4605      	mov	r5, r0
 8000348:	4c0a      	ldr	r4, [pc, #40]	; (8000374 <chSchGoSleepTimeoutS+0x34>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:193

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800034a:	d00d      	beq.n	8000368 <chSchGoSleepTimeoutS+0x28>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:196
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 800034c:	69a3      	ldr	r3, [r4, #24]
 800034e:	a801      	add	r0, sp, #4
 8000350:	4a09      	ldr	r2, [pc, #36]	; (8000378 <chSchGoSleepTimeoutS+0x38>)
 8000352:	f000 f985 	bl	8000660 <chVTSetI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:197
    chSchGoSleepS(newstate);
 8000356:	4628      	mov	r0, r5
 8000358:	f7ff ffe2 	bl	8000320 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:198
    if (chVTIsArmedI(&vt))
 800035c:	9b04      	ldr	r3, [sp, #16]
 800035e:	b12b      	cbz	r3, 800036c <chSchGoSleepTimeoutS+0x2c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:199
      chVTResetI(&vt);
 8000360:	a801      	add	r0, sp, #4
 8000362:	f000 f9a5 	bl	80006b0 <chVTResetI>
 8000366:	e001      	b.n	800036c <chSchGoSleepTimeoutS+0x2c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:202
  }
  else
    chSchGoSleepS(newstate);
 8000368:	f7ff ffda 	bl	8000320 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:203
  return currp->p_u.rdymsg;
 800036c:	69a3      	ldr	r3, [r4, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:204
}
 800036e:	6a18      	ldr	r0, [r3, #32]
 8000370:	b007      	add	sp, #28
 8000372:	bd30      	pop	{r4, r5, pc}
 8000374:	20000f70 	.word	0x20000f70
 8000378:	080002e1 	.word	0x080002e1
$d():
 800037c:	00000000 	.word	0x00000000

08000380 <chSchWakeupS>:
chSchWakeupS():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 8000380:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8000382:	4d0c      	ldr	r5, [pc, #48]	; (80003b4 <chSchWakeupS+0x34>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:229
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 8000384:	6201      	str	r1, [r0, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:234
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8000386:	69ab      	ldr	r3, [r5, #24]
 8000388:	6881      	ldr	r1, [r0, #8]
 800038a:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 800038c:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 800038e:	4291      	cmp	r1, r2
 8000390:	d803      	bhi.n	800039a <chSchWakeupS+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:242
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000392:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:235
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
 8000396:	f7ff bf83 	b.w	80002a0 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:237
  else {
    Thread *otp = chSchReadyI(currp);
 800039a:	4618      	mov	r0, r3
 800039c:	f7ff ff80 	bl	80002a0 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80003a0:	2301      	movs	r3, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:237
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
 80003a2:	4601      	mov	r1, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:238
    setcurrp(ntp);
 80003a4:	61ac      	str	r4, [r5, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:239
    ntp->p_state = THD_STATE_CURRENT;
 80003a6:	7723      	strb	r3, [r4, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:240
    chSysSwitch(ntp, otp);
 80003a8:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:242
  }
}
 80003aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:240
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80003ae:	f000 ba1f 	b.w	80007f0 <_port_switch>
 80003b2:	bf00      	nop
 80003b4:	20000f70 	.word	0x20000f70
	...

080003c0 <chSchDoRescheduleBehind>:
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:304
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
 80003c0:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:307
  Thread *otp;

  otp = currp;
 80003c2:	4c0a      	ldr	r4, [pc, #40]	; (80003ec <chSchDoRescheduleBehind+0x2c>)
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 80003c4:	6823      	ldr	r3, [r4, #0]
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:307
 80003c6:	69a5      	ldr	r5, [r4, #24]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80003c8:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:314
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
 80003ca:	4628      	mov	r0, r5
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:62
 80003cc:	6054      	str	r4, [r2, #4]
 80003ce:	6022      	str	r2, [r4, #0]
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:310
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 80003d0:	2201      	movs	r2, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:309
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 80003d2:	61a3      	str	r3, [r4, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:310
  currp->p_state = THD_STATE_CURRENT;
 80003d4:	771a      	strb	r2, [r3, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:312
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
 80003d6:	2314      	movs	r3, #20
 80003d8:	77ab      	strb	r3, [r5, #30]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:314
#endif
  chSchReadyI(otp);
 80003da:	f7ff ff61 	bl	80002a0 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:315
  chSysSwitch(currp, otp);
 80003de:	69a0      	ldr	r0, [r4, #24]
 80003e0:	4629      	mov	r1, r5
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:316
}
 80003e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:315
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80003e6:	f000 ba03 	b.w	80007f0 <_port_switch>
 80003ea:	bf00      	nop
 80003ec:	20000f70 	.word	0x20000f70

080003f0 <chSchDoRescheduleAhead>:
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:332
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
 80003f0:	4b0c      	ldr	r3, [pc, #48]	; (8000424 <chSchDoRescheduleAhead+0x34>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:329
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
 80003f2:	b510      	push	{r4, lr}
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 80003f4:	6818      	ldr	r0, [r3, #0]
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:332
  Thread *otp, *cp;

  otp = currp;
 80003f6:	6999      	ldr	r1, [r3, #24]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80003f8:	6802      	ldr	r2, [r0, #0]
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:341

  otp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 80003fa:	688c      	ldr	r4, [r1, #8]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/include/chinline.h:62
 80003fc:	6053      	str	r3, [r2, #4]
 80003fe:	601a      	str	r2, [r3, #0]
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:335
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8000400:	2201      	movs	r2, #1
 8000402:	7702      	strb	r2, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:337

  otp->p_state = THD_STATE_READY;
 8000404:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:334
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000406:	6198      	str	r0, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:337
  currp->p_state = THD_STATE_CURRENT;

  otp->p_state = THD_STATE_READY;
 8000408:	770a      	strb	r2, [r1, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:340 (discriminator 1)
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
 800040a:	681b      	ldr	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:341 (discriminator 1)
  } while (cp->p_prio > otp->p_prio);
 800040c:	689a      	ldr	r2, [r3, #8]
 800040e:	42a2      	cmp	r2, r4
 8000410:	d8fb      	bhi.n	800040a <chSchDoRescheduleAhead+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:344
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000412:	685a      	ldr	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:343
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000414:	600b      	str	r3, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:344
  otp->p_prev = cp->p_prev;
 8000416:	604a      	str	r2, [r1, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:348
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
}
 8000418:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:345
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 800041c:	6059      	str	r1, [r3, #4]
 800041e:	6011      	str	r1, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:347

  chSysSwitch(currp, otp);
 8000420:	f000 b9e6 	b.w	80007f0 <_port_switch>
 8000424:	20000f70 	.word	0x20000f70
	...

08000430 <chSchDoReschedule>:
chSchDoReschedule():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:367
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
 8000430:	4b03      	ldr	r3, [pc, #12]	; (8000440 <chSchDoReschedule+0x10>)
 8000432:	699b      	ldr	r3, [r3, #24]
 8000434:	7f9b      	ldrb	r3, [r3, #30]
 8000436:	b90b      	cbnz	r3, 800043c <chSchDoReschedule+0xc>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:370
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 8000438:	f7ff bfc2 	b.w	80003c0 <chSchDoRescheduleBehind>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chschd.c:375
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 800043c:	f7ff bfd8 	b.w	80003f0 <chSchDoRescheduleAhead>
 8000440:	20000f70 	.word	0x20000f70
	...

08000450 <_idle_thread>:
_idle_thread():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:64
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8000450:	4b02      	ldr	r3, [pc, #8]	; (800045c <_idle_thread+0xc>)
 8000452:	4a03      	ldr	r2, [pc, #12]	; (8000460 <_idle_thread+0x10>)
 8000454:	699b      	ldr	r3, [r3, #24]
 8000456:	619a      	str	r2, [r3, #24]
 8000458:	e7fe      	b.n	8000458 <_idle_thread+0x8>
 800045a:	bf00      	nop
 800045c:	20000f70 	.word	0x20000f70
 8000460:	080017a0 	.word	0x080017a0
	...

08000470 <chSysInit>:
chSysInit():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:84
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 8000470:	b507      	push	{r0, r1, r2, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:90
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8000472:	f000 f955 	bl	8000720 <_port_init>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:91
  _scheduler_init();
 8000476:	f7ff ff03 	bl	8000280 <_scheduler_init>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:92
  _vt_init();
 800047a:	f000 f8e1 	bl	8000640 <_vt_init>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:104
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 800047e:	2140      	movs	r1, #64	; 0x40
 8000480:	480c      	ldr	r0, [pc, #48]	; (80004b4 <chSysInit+0x44>)
 8000482:	f000 f84d 	bl	8000520 <_thread_init>
 8000486:	4b0c      	ldr	r3, [pc, #48]	; (80004b8 <chSysInit+0x48>)
 8000488:	6198      	str	r0, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:105
  currp->p_state = THD_STATE_CURRENT;
 800048a:	2301      	movs	r3, #1
 800048c:	7703      	strb	r3, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:111
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 800048e:	2300      	movs	r3, #0
 8000490:	f383 8811 	msr	BASEPRI, r3
 8000494:	b662      	cpsie	i
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:115

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000496:	4b08      	ldr	r3, [pc, #32]	; (80004b8 <chSysInit+0x48>)
 8000498:	4a08      	ldr	r2, [pc, #32]	; (80004bc <chSysInit+0x4c>)
 800049a:	699b      	ldr	r3, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800049c:	21a0      	movs	r1, #160	; 0xa0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:115
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 800049e:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 80004a0:	2300      	movs	r3, #0
 80004a2:	9300      	str	r3, [sp, #0]
 80004a4:	2201      	movs	r2, #1
 80004a6:	4b06      	ldr	r3, [pc, #24]	; (80004c0 <chSysInit+0x50>)
 80004a8:	4806      	ldr	r0, [pc, #24]	; (80004c4 <chSysInit+0x54>)
 80004aa:	f000 f879 	bl	80005a0 <chThdCreateStatic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:124
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 80004ae:	b003      	add	sp, #12
 80004b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80004b4:	20000800 	.word	0x20000800
 80004b8:	20000f70 	.word	0x20000f70
 80004bc:	08001760 	.word	0x08001760
 80004c0:	08000451 	.word	0x08000451
 80004c4:	20000f90 	.word	0x20000f90
	...

080004d0 <chSysTimerHandlerI>:
chSysTimerHandlerI():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:137
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80004d0:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:143

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
 80004d2:	4b11      	ldr	r3, [pc, #68]	; (8000518 <chSysTimerHandlerI+0x48>)
 80004d4:	699b      	ldr	r3, [r3, #24]
 80004d6:	7f9a      	ldrb	r2, [r3, #30]
 80004d8:	b10a      	cbz	r2, 80004de <chSysTimerHandlerI+0xe>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:145
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 80004da:	3a01      	subs	r2, #1
 80004dc:	779a      	strb	r2, [r3, #30]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:150
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
#endif
  chVTDoTickI();
 80004de:	4b0f      	ldr	r3, [pc, #60]	; (800051c <chSysTimerHandlerI+0x4c>)
 80004e0:	68da      	ldr	r2, [r3, #12]
 80004e2:	461c      	mov	r4, r3
 80004e4:	3201      	adds	r2, #1
 80004e6:	60da      	str	r2, [r3, #12]
 80004e8:	681a      	ldr	r2, [r3, #0]
 80004ea:	429a      	cmp	r2, r3
 80004ec:	d013      	beq.n	8000516 <chSysTimerHandlerI+0x46>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:150 (discriminator 1)
 80004ee:	6891      	ldr	r1, [r2, #8]
 80004f0:	3901      	subs	r1, #1
 80004f2:	6091      	str	r1, [r2, #8]
 80004f4:	6822      	ldr	r2, [r4, #0]
 80004f6:	4909      	ldr	r1, [pc, #36]	; (800051c <chSysTimerHandlerI+0x4c>)
 80004f8:	6893      	ldr	r3, [r2, #8]
 80004fa:	b963      	cbnz	r3, 8000516 <chSysTimerHandlerI+0x46>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chsys.c:150 (discriminator 2)
 80004fc:	6810      	ldr	r0, [r2, #0]
 80004fe:	68d5      	ldr	r5, [r2, #12]
 8000500:	6008      	str	r0, [r1, #0]
 8000502:	60d3      	str	r3, [r2, #12]
 8000504:	6041      	str	r1, [r0, #4]
 8000506:	f383 8811 	msr	BASEPRI, r3
 800050a:	6910      	ldr	r0, [r2, #16]
 800050c:	47a8      	blx	r5
 800050e:	2320      	movs	r3, #32
 8000510:	f383 8811 	msr	BASEPRI, r3
 8000514:	e7ee      	b.n	80004f4 <chSysTimerHandlerI+0x24>
 8000516:	bd38      	pop	{r3, r4, r5, pc}
 8000518:	20000f70 	.word	0x20000f70
 800051c:	20001030 	.word	0x20001030

08000520 <_thread_init>:
_thread_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:79
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 8000520:	2202      	movs	r2, #2
 8000522:	7702      	strb	r2, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:80
  tp->p_flags = THD_MEM_MODE_STATIC;
 8000524:	2200      	movs	r2, #0
 8000526:	7742      	strb	r2, [r0, #29]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:89
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 8000528:	6242      	str	r2, [r0, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:98
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 800052a:	6182      	str	r2, [r0, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:99
  REG_INSERT(tp);
 800052c:	4a04      	ldr	r2, [pc, #16]	; (8000540 <_thread_init+0x20>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:78
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 800052e:	6081      	str	r1, [r0, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:82
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 8000530:	2114      	movs	r1, #20
 8000532:	7781      	strb	r1, [r0, #30]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000534:	6951      	ldr	r1, [r2, #20]
 8000536:	6102      	str	r2, [r0, #16]
 8000538:	6141      	str	r1, [r0, #20]
 800053a:	6150      	str	r0, [r2, #20]
 800053c:	6108      	str	r0, [r1, #16]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:114
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
 800053e:	4770      	bx	lr
 8000540:	20000f70 	.word	0x20000f70
	...

08000550 <chThdCreateI>:
chThdCreateI():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:158
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
 8000550:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000554:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8000558:	460d      	mov	r5, r1
 800055a:	4616      	mov	r6, r2
 800055c:	461f      	mov	r7, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:164
  /* Thread structure is laid out in the lower part of the thread workspace.*/
  Thread *tp = wsp;

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
 800055e:	4604      	mov	r4, r0
 8000560:	b120      	cbz	r0, 800056c <chThdCreateI+0x1c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:164 (discriminator 2)
 8000562:	298f      	cmp	r1, #143	; 0x8f
 8000564:	d902      	bls.n	800056c <chThdCreateI+0x1c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:164 (discriminator 1)
 8000566:	2a7f      	cmp	r2, #127	; 0x7f
 8000568:	d800      	bhi.n	800056c <chThdCreateI+0x1c>
 800056a:	b913      	cbnz	r3, 8000572 <chThdCreateI+0x22>
 800056c:	4808      	ldr	r0, [pc, #32]	; (8000590 <chThdCreateI+0x40>)
 800056e:	f000 fd67 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:167
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8000572:	3d24      	subs	r5, #36	; 0x24
 8000574:	4b07      	ldr	r3, [pc, #28]	; (8000594 <chThdCreateI+0x44>)
 8000576:	1960      	adds	r0, r4, r5
 8000578:	60e0      	str	r0, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 800057a:	4631      	mov	r1, r6
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:167
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 800057c:	5167      	str	r7, [r4, r5]
 800057e:	f8c0 8004 	str.w	r8, [r0, #4]
 8000582:	6203      	str	r3, [r0, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 8000584:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:169
}
 8000586:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:168

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
 800058a:	f7ff bfc9 	b.w	8000520 <_thread_init>
 800058e:	bf00      	nop
 8000590:	080017b0 	.word	0x080017b0
 8000594:	08000801 	.word	0x08000801
	...

080005a0 <chThdCreateStatic>:
chThdCreateStatic():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 80005a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80005a2:	461d      	mov	r5, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:199
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
 80005a4:	2320      	movs	r3, #32
 80005a6:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:200
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 80005aa:	9c06      	ldr	r4, [sp, #24]
 80005ac:	462b      	mov	r3, r5
 80005ae:	9400      	str	r4, [sp, #0]
 80005b0:	f7ff ffce 	bl	8000550 <chThdCreateI>
 80005b4:	2100      	movs	r1, #0
 80005b6:	4604      	mov	r4, r0
 80005b8:	f7ff fee2 	bl	8000380 <chSchWakeupS>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:201
  chSysUnlock();
 80005bc:	2300      	movs	r3, #0
 80005be:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:203
  return tp;
}
 80005c2:	4620      	mov	r0, r4
 80005c4:	b003      	add	sp, #12
 80005c6:	bd30      	pop	{r4, r5, pc}
	...

080005d0 <chThdSleep>:
chThdSleep():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:292
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80005d0:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:294

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");
 80005d2:	4604      	mov	r4, r0
 80005d4:	b910      	cbnz	r0, 80005dc <chThdSleep+0xc>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:294 (discriminator 1)
 80005d6:	4807      	ldr	r0, [pc, #28]	; (80005f4 <chThdSleep+0x24>)
 80005d8:	f000 fd32 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:296

  chSysLock();
 80005dc:	2320      	movs	r3, #32
 80005de:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:297
  chThdSleepS(time);
 80005e2:	2006      	movs	r0, #6
 80005e4:	4621      	mov	r1, r4
 80005e6:	f7ff feab 	bl	8000340 <chSchGoSleepTimeoutS>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:298
  chSysUnlock();
 80005ea:	2300      	movs	r3, #0
 80005ec:	f383 8811 	msr	BASEPRI, r3
 80005f0:	bd10      	pop	{r4, pc}
 80005f2:	bf00      	nop
 80005f4:	080017e8 	.word	0x080017e8
	...

08000600 <chThdExitS>:
chThdExitS():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:366
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000600:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:367
  Thread *tp = currp;
 8000602:	4b09      	ldr	r3, [pc, #36]	; (8000628 <chThdExitS+0x28>)
 8000604:	699b      	ldr	r3, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:380
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 8000606:	7f5a      	ldrb	r2, [r3, #29]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:369
 * @sclass
 */
void chThdExitS(msg_t msg) {
  Thread *tp = currp;

  tp->p_u.exitcode = msg;
 8000608:	6218      	str	r0, [r3, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:380
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 800060a:	0792      	lsls	r2, r2, #30
 800060c:	d104      	bne.n	8000618 <chThdExitS+0x18>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:381
    REG_REMOVE(tp);
 800060e:	695a      	ldr	r2, [r3, #20]
 8000610:	6919      	ldr	r1, [r3, #16]
 8000612:	6111      	str	r1, [r2, #16]
 8000614:	691b      	ldr	r3, [r3, #16]
 8000616:	615a      	str	r2, [r3, #20]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:383
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 8000618:	200e      	movs	r0, #14
 800061a:	f7ff fe81 	bl	8000320 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:386
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 800061e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:385
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
 8000622:	4802      	ldr	r0, [pc, #8]	; (800062c <chThdExitS+0x2c>)
 8000624:	f000 bd0c 	b.w	8001040 <chDbgPanic>
 8000628:	20000f70 	.word	0x20000f70
 800062c:	080017f7 	.word	0x080017f7

08000630 <chThdExit>:
chThdExit():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:347
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
 8000630:	2320      	movs	r3, #32
 8000632:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chthreads.c:348
  chThdExitS(msg);
 8000636:	f7ff bfe3 	b.w	8000600 <chThdExitS>
 800063a:	0000      	movs	r0, r0
 800063c:	0000      	movs	r0, r0
	...

08000640 <_vt_init>:
_vt_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 8000640:	4b04      	ldr	r3, [pc, #16]	; (8000654 <_vt_init+0x14>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:53
  vtlist.vt_time = (systime_t)-1;
 8000642:	f04f 32ff 	mov.w	r2, #4294967295
 8000646:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:54
  vtlist.vt_systime = 0;
 8000648:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 800064a:	605b      	str	r3, [r3, #4]
 800064c:	601b      	str	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:54
  vtlist.vt_time = (systime_t)-1;
  vtlist.vt_systime = 0;
 800064e:	60da      	str	r2, [r3, #12]
 8000650:	4770      	bx	lr
 8000652:	bf00      	nop
 8000654:	20001030 	.word	0x20001030
	...

08000660 <chVTSetI>:
chVTSetI():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:76
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 8000660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000662:	460d      	mov	r5, r1
 8000664:	4616      	mov	r6, r2
 8000666:	461f      	mov	r7, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:80
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
 8000668:	4604      	mov	r4, r0
 800066a:	b108      	cbz	r0, 8000670 <chVTSetI+0x10>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:80 (discriminator 2)
 800066c:	b102      	cbz	r2, 8000670 <chVTSetI+0x10>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:80 (discriminator 1)
 800066e:	b911      	cbnz	r1, 8000676 <chVTSetI+0x16>
 8000670:	480c      	ldr	r0, [pc, #48]	; (80006a4 <chVTSetI+0x44>)
 8000672:	f000 fce5 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:85
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 8000676:	4a0c      	ldr	r2, [pc, #48]	; (80006a8 <chVTSetI+0x48>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:83

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
 8000678:	6127      	str	r7, [r4, #16]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:85
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 800067a:	6813      	ldr	r3, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:84
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800067c:	60e6      	str	r6, [r4, #12]
 800067e:	4611      	mov	r1, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:86 (discriminator 1)
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 8000680:	689a      	ldr	r2, [r3, #8]
 8000682:	42aa      	cmp	r2, r5
 8000684:	d202      	bcs.n	800068c <chVTSetI+0x2c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:87
    time -= p->vt_time;
 8000686:	1aad      	subs	r5, r5, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:88
    p = p->vt_next;
 8000688:	681b      	ldr	r3, [r3, #0]
 800068a:	e7f9      	b.n	8000680 <chVTSetI+0x20>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:91
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 800068c:	685a      	ldr	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:94
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_time = time;
  if (p != (void *)&vtlist)
 800068e:	428b      	cmp	r3, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:91
  while (p->vt_time < time) {
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8000690:	6023      	str	r3, [r4, #0]
 8000692:	6062      	str	r2, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:92
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8000694:	605c      	str	r4, [r3, #4]
 8000696:	6014      	str	r4, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:93
  vtp->vt_time = time;
 8000698:	60a5      	str	r5, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:94
  if (p != (void *)&vtlist)
 800069a:	d002      	beq.n	80006a2 <chVTSetI+0x42>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:95
    p->vt_time -= time;
 800069c:	689a      	ldr	r2, [r3, #8]
 800069e:	1b55      	subs	r5, r2, r5
 80006a0:	609d      	str	r5, [r3, #8]
 80006a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80006a4:	08001810 	.word	0x08001810
 80006a8:	20001030 	.word	0x20001030
$d():
 80006ac:	00000000 	.word	0x00000000

080006b0 <chVTResetI>:
chVTResetI():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:106
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 80006b0:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:109

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL, "chVTResetI");
 80006b2:	4604      	mov	r4, r0
 80006b4:	b910      	cbnz	r0, 80006bc <chVTResetI+0xc>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:109 (discriminator 1)
 80006b6:	480b      	ldr	r0, [pc, #44]	; (80006e4 <chVTResetI+0x34>)
 80006b8:	f000 fcc2 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:110
  chDbgAssert(vtp->vt_func != NULL,
 80006bc:	68e3      	ldr	r3, [r4, #12]
 80006be:	b913      	cbnz	r3, 80006c6 <chVTResetI+0x16>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:110 (discriminator 1)
 80006c0:	4809      	ldr	r0, [pc, #36]	; (80006e8 <chVTResetI+0x38>)
 80006c2:	f000 fcbd 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:114
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 80006c6:	6823      	ldr	r3, [r4, #0]
 80006c8:	4a08      	ldr	r2, [pc, #32]	; (80006ec <chVTResetI+0x3c>)
 80006ca:	4293      	cmp	r3, r2
 80006cc:	d003      	beq.n	80006d6 <chVTResetI+0x26>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:115
    vtp->vt_next->vt_time += vtp->vt_time;
 80006ce:	6899      	ldr	r1, [r3, #8]
 80006d0:	68a2      	ldr	r2, [r4, #8]
 80006d2:	440a      	add	r2, r1
 80006d4:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:116
  vtp->vt_prev->vt_next = vtp->vt_next;
 80006d6:	6862      	ldr	r2, [r4, #4]
 80006d8:	6013      	str	r3, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:117
  vtp->vt_next->vt_prev = vtp->vt_prev;
 80006da:	6823      	ldr	r3, [r4, #0]
 80006dc:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/kernel/src/chvt.c:118
  vtp->vt_func = (vtfunc_t)NULL;
 80006de:	2300      	movs	r3, #0
 80006e0:	60e3      	str	r3, [r4, #12]
 80006e2:	bd10      	pop	{r4, pc}
 80006e4:	0800181d 	.word	0x0800181d
 80006e8:	0800182c 	.word	0x0800182c
 80006ec:	20001030 	.word	0x20001030

080006f0 <_port_switch_from_isr>:
_port_switch_from_isr():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:210
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
  chSchDoReschedule();
 80006f0:	f7ff fe9e 	bl	8000430 <chSchDoReschedule>

080006f4 <_port_exit_from_isr>:
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:214
  dbg_check_unlock();
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
 80006f4:	df00      	svc	0
	...

08000700 <SVCallVector>:
SVCallVector():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:69
 */
void SVCallVector(void) {
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000700:	f3ef 8309 	mrs	r3, PSP
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:73

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000704:	3320      	adds	r3, #32
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:80
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000706:	f383 8809 	msr	PSP, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:81
  port_unlock_from_isr();
 800070a:	2300      	movs	r3, #0
 800070c:	f383 8811 	msr	BASEPRI, r3
 8000710:	4770      	bx	lr
	...

08000720 <_port_init>:
_port_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:118
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
 8000720:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:121

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
 8000722:	4b0a      	ldr	r3, [pc, #40]	; (800074c <_port_init+0x2c>)
 8000724:	2200      	movs	r2, #0
 8000726:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:122
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 8000728:	4a09      	ldr	r2, [pc, #36]	; (8000750 <_port_init+0x30>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 800072a:	2007      	movs	r0, #7
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:122
 */
void _port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 800072c:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 800072e:	2110      	movs	r1, #16
 8000730:	f000 f94e 	bl	80009d0 <nvicSetSystemHandlerPriority>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:127
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
 8000734:	200a      	movs	r0, #10
 8000736:	f44f 7100 	mov.w	r1, #512	; 0x200
 800073a:	f000 f949 	bl	80009d0 <nvicSetSystemHandlerPriority>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:131
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
}
 800073e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:129
  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
 8000742:	200b      	movs	r0, #11
 8000744:	2180      	movs	r1, #128	; 0x80
 8000746:	f000 b943 	b.w	80009d0 <nvicSetSystemHandlerPriority>
 800074a:	bf00      	nop
 800074c:	e000ed00 	.word	0xe000ed00
 8000750:	05fa0300 	.word	0x05fa0300
	...

08000760 <_port_irq_epilogue>:
_port_irq_epilogue():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:150
/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
 8000760:	2320      	movs	r3, #32
 8000762:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:151
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
 8000766:	4b14      	ldr	r3, [pc, #80]	; (80007b8 <_port_irq_epilogue+0x58>)
 8000768:	685b      	ldr	r3, [r3, #4]
 800076a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800076e:	d020      	beq.n	80007b2 <_port_irq_epilogue+0x52>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:155
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000770:	f3ef 8309 	mrs	r3, PSP
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:159

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000774:	f1a3 0220 	sub.w	r2, r3, #32
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:160
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000778:	f382 8809 	msr	PSP, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:161
    ctxp->xpsr = (regarm_t)0x01000000;
 800077c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000780:	f843 2c04 	str.w	r2, [r3, #-4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000784:	4a0d      	ldr	r2, [pc, #52]	; (80007bc <_port_irq_epilogue+0x5c>)
 8000786:	6991      	ldr	r1, [r2, #24]
 8000788:	6812      	ldr	r2, [r2, #0]
 800078a:	7f88      	ldrb	r0, [r1, #30]
 800078c:	6892      	ldr	r2, [r2, #8]
 800078e:	6889      	ldr	r1, [r1, #8]
 8000790:	b120      	cbz	r0, 800079c <_port_irq_epilogue+0x3c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165 (discriminator 1)
 8000792:	428a      	cmp	r2, r1
 8000794:	bf94      	ite	ls
 8000796:	2200      	movls	r2, #0
 8000798:	2201      	movhi	r2, #1
 800079a:	e003      	b.n	80007a4 <_port_irq_epilogue+0x44>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165 (discriminator 2)
 800079c:	428a      	cmp	r2, r1
 800079e:	bf34      	ite	cc
 80007a0:	2200      	movcc	r2, #0
 80007a2:	2201      	movcs	r2, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165 (discriminator 3)
 80007a4:	b10a      	cbz	r2, 80007aa <_port_irq_epilogue+0x4a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:167
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
 80007a6:	4a06      	ldr	r2, [pc, #24]	; (80007c0 <_port_irq_epilogue+0x60>)
 80007a8:	e000      	b.n	80007ac <_port_irq_epilogue+0x4c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:176
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
 80007aa:	4a06      	ldr	r2, [pc, #24]	; (80007c4 <_port_irq_epilogue+0x64>)
 80007ac:	f843 2c08 	str.w	r2, [r3, #-8]
 80007b0:	4770      	bx	lr
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:197

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 80007b2:	f383 8811 	msr	BASEPRI, r3
 80007b6:	4770      	bx	lr
 80007b8:	e000ed00 	.word	0xe000ed00
 80007bc:	20000f70 	.word	0x20000f70
 80007c0:	080006f1 	.word	0x080006f1
 80007c4:	080006f4 	.word	0x080006f4
	...

080007d0 <SysTickVector>:
SysTickVector():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:47
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
 80007d0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:51

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
 80007d2:	2320      	movs	r3, #32
 80007d4:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:52
  chSysTimerHandlerI();
 80007d8:	f7ff fe7a 	bl	80004d0 <chSysTimerHandlerI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:53
  chSysUnlockFromIsr();
 80007dc:	2300      	movs	r3, #0
 80007de:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:56

  CH_IRQ_EPILOGUE();
}
 80007e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:55

  chSysLockFromIsr();
  chSysTimerHandlerI();
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
 80007e6:	f7ff bfbb 	b.w	8000760 <_port_irq_epilogue>
 80007ea:	0000      	movs	r0, r0
 80007ec:	0000      	movs	r0, r0
	...

080007f0 <_port_switch>:
_port_switch():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:238
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
 80007f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:244
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
 80007f4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80007f8:	f8d0 d00c 	ldr.w	sp, [r0, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:250
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
 80007fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000800 <_port_thread_start>:
_port_thread_start():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:261
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
 8000800:	2300      	movs	r3, #0
 8000802:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/chcore_v7m.c:262
  asm volatile ("mov     r0, r5                                 \n\t"
 8000806:	4628      	mov	r0, r5
 8000808:	47a0      	blx	r4
 800080a:	f7ff ff11 	bl	8000630 <chThdExit>
 800080e:	4770      	bx	lr

08000810 <__early_init>:
__early_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:234
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __early_init(void) {}
 8000810:	4770      	bx	lr
	...

08000820 <__late_init>:
__late_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:246
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 8000820:	4770      	bx	lr
	...

08000830 <_default_exit>:
_default_exit():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:257
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak, naked))
#endif
void _default_exit(void) {
 8000830:	e7fe      	b.n	8000830 <_default_exit>
	...

08000840 <ResetHandler>:
ResetHandler():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:274
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000840:	b672      	cpsid	i
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:276
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000842:	4b22      	ldr	r3, [pc, #136]	; (80008cc <ResetHandler+0x8c>)
 8000844:	f383 8809 	msr	PSP, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:296
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000848:	2302      	movs	r3, #2
 800084a:	f383 8814 	msr	CONTROL, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:297
  asm volatile ("isb");
 800084e:	f3bf 8f6f 	isb	sy
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:301

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000852:	4b1f      	ldr	r3, [pc, #124]	; (80008d0 <ResetHandler+0x90>)
 8000854:	4a1d      	ldr	r2, [pc, #116]	; (80008cc <ResetHandler+0x8c>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:301 (discriminator 1)
 8000856:	491f      	ldr	r1, [pc, #124]	; (80008d4 <ResetHandler+0x94>)
 8000858:	428b      	cmp	r3, r1
 800085a:	d204      	bcs.n	8000866 <ResetHandler+0x26>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:301 (discriminator 2)
 800085c:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000860:	f843 1b04 	str.w	r1, [r3], #4
 8000864:	e7f7      	b.n	8000856 <ResetHandler+0x16>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:301
 8000866:	4b1c      	ldr	r3, [pc, #112]	; (80008d8 <ResetHandler+0x98>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:304 (discriminator 1)
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000868:	4293      	cmp	r3, r2
 800086a:	d204      	bcs.n	8000876 <ResetHandler+0x36>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:304 (discriminator 2)
 800086c:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000870:	f843 1b04 	str.w	r1, [r3], #4
 8000874:	e7f8      	b.n	8000868 <ResetHandler+0x28>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:310
         &__process_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
#endif

  /* Early initialization hook invocation.*/
  __early_init();
 8000876:	f7ff ffcb 	bl	8000810 <__early_init>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 800087a:	2300      	movs	r3, #0
 800087c:	4a17      	ldr	r2, [pc, #92]	; (80008dc <ResetHandler+0x9c>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:319 (discriminator 1)
 800087e:	4918      	ldr	r1, [pc, #96]	; (80008e0 <ResetHandler+0xa0>)
 8000880:	1898      	adds	r0, r3, r2
 8000882:	4288      	cmp	r0, r1
 8000884:	d204      	bcs.n	8000890 <ResetHandler+0x50>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:320
      *dp++ = *tp++;
 8000886:	4917      	ldr	r1, [pc, #92]	; (80008e4 <ResetHandler+0xa4>)
 8000888:	5859      	ldr	r1, [r3, r1]
 800088a:	5099      	str	r1, [r3, r2]
 800088c:	3304      	adds	r3, #4
 800088e:	e7f5      	b.n	800087c <ResetHandler+0x3c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000890:	4b15      	ldr	r3, [pc, #84]	; (80008e8 <ResetHandler+0xa8>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:326 (discriminator 1)
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000892:	4a16      	ldr	r2, [pc, #88]	; (80008ec <ResetHandler+0xac>)
 8000894:	4293      	cmp	r3, r2
 8000896:	d203      	bcs.n	80008a0 <ResetHandler+0x60>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:326 (discriminator 2)
 8000898:	2200      	movs	r2, #0
 800089a:	f843 2b04 	str.w	r2, [r3], #4
 800089e:	e7f8      	b.n	8000892 <ResetHandler+0x52>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:330
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 80008a0:	f7ff ffbe 	bl	8000820 <__late_init>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:335

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
 80008a4:	4c12      	ldr	r4, [pc, #72]	; (80008f0 <ResetHandler+0xb0>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:336 (discriminator 1)
    while (fpp < &__init_array_end) {
 80008a6:	4b13      	ldr	r3, [pc, #76]	; (80008f4 <ResetHandler+0xb4>)
 80008a8:	429c      	cmp	r4, r3
 80008aa:	d203      	bcs.n	80008b4 <ResetHandler+0x74>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:337
      (*fpp)();
 80008ac:	f854 3b04 	ldr.w	r3, [r4], #4
 80008b0:	4798      	blx	r3
 80008b2:	e7f8      	b.n	80008a6 <ResetHandler+0x66>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:344
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 80008b4:	f7ff fc3c 	bl	8000130 <main>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:349

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
 80008b8:	4c0f      	ldr	r4, [pc, #60]	; (80008f8 <ResetHandler+0xb8>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:350 (discriminator 1)
    while (fpp < &__fini_array_end) {
 80008ba:	4b10      	ldr	r3, [pc, #64]	; (80008fc <ResetHandler+0xbc>)
 80008bc:	429c      	cmp	r4, r3
 80008be:	d203      	bcs.n	80008c8 <ResetHandler+0x88>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:351
      (*fpp)();
 80008c0:	f854 3b04 	ldr.w	r3, [r4], #4
 80008c4:	4798      	blx	r3
 80008c6:	e7f8      	b.n	80008ba <ResetHandler+0x7a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/ARMCMx/crt0.c:358
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 80008c8:	f7ff ffb2 	bl	8000830 <_default_exit>
 80008cc:	20000800 	.word	0x20000800
 80008d0:	20000000 	.word	0x20000000
 80008d4:	20000400 	.word	0x20000400
 80008d8:	20000400 	.word	0x20000400
 80008dc:	20000800 	.word	0x20000800
 80008e0:	20000800 	.word	0x20000800
 80008e4:	08001940 	.word	0x08001940
 80008e8:	20000800 	.word	0x20000800
 80008ec:	20001040 	.word	0x20001040
 80008f0:	080000f4 	.word	0x080000f4
 80008f4:	080000f8 	.word	0x080000f8
 80008f8:	080000f8 	.word	0x080000f8
 80008fc:	080000f8 	.word	0x080000f8

08000900 <halInit>:
halInit():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal.c:70
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
 8000900:	f000 b806 	b.w	8000910 <hal_lld_init>
	...

08000910 <hal_lld_init>:
hal_lld_init():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:96
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 8000910:	4b15      	ldr	r3, [pc, #84]	; (8000968 <hal_lld_init+0x58>)
 8000912:	691a      	ldr	r2, [r3, #16]
 8000914:	f462 4200 	orn	r2, r2, #32768	; 0x8000
 8000918:	611a      	str	r2, [r3, #16]
 800091a:	2200      	movs	r2, #0
 800091c:	611a      	str	r2, [r3, #16]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:97
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800091e:	6999      	ldr	r1, [r3, #24]
 8000920:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8000924:	6199      	str	r1, [r3, #24]
 8000926:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:98
  rccResetAPB2(~0);
 8000928:	6959      	ldr	r1, [r3, #20]
 800092a:	f04f 31ff 	mov.w	r1, #4294967295
 800092e:	6159      	str	r1, [r3, #20]
 8000930:	615a      	str	r2, [r3, #20]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:100

  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000932:	6a19      	ldr	r1, [r3, #32]
 8000934:	f041 0101 	orr.w	r1, r1, #1
 8000938:	6219      	str	r1, [r3, #32]
 800093a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800093c:	f041 0101 	orr.w	r1, r1, #1
 8000940:	62d9      	str	r1, [r3, #44]	; 0x2c
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:103

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = Clk.AHBFreqHz / CH_FREQUENCY - 1;
 8000942:	490a      	ldr	r1, [pc, #40]	; (800096c <hal_lld_init+0x5c>)
 8000944:	6808      	ldr	r0, [r1, #0]
 8000946:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800094a:	fbb0 f0f1 	udiv	r0, r0, r1
 800094e:	4908      	ldr	r1, [pc, #32]	; (8000970 <hal_lld_init+0x60>)
 8000950:	3801      	subs	r0, #1
 8000952:	6048      	str	r0, [r1, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:104
  SysTick->VAL = 0;
 8000954:	608a      	str	r2, [r1, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:107
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;
 8000956:	2207      	movs	r2, #7
 8000958:	600a      	str	r2, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:114
  /* DWT cycle counter enable.*/
//  SCS_DEMCR |= SCS_DEMCR_TRCENA;
//  DWT_CTRL  |= DWT_CTRL_CYCCNTENA;

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800095a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800095c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000960:	625a      	str	r2, [r3, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/hal_lld.cpp:120

  /* Initializes the backup domain.*/
//  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000962:	f000 b8f5 	b.w	8000b50 <dmaInit>
 8000966:	bf00      	nop
 8000968:	40023800 	.word	0x40023800
 800096c:	20000868 	.word	0x20000868
 8000970:	e000e010 	.word	0xe000e010
	...

08000980 <nvicEnableVector>:
nvicEnableVector():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:47
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 8000980:	f000 0203 	and.w	r2, r0, #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:46
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000984:	b530      	push	{r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:47
  unsigned sh = (n & 3) << 3;
 8000986:	00d2      	lsls	r2, r2, #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:49

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000988:	24ff      	movs	r4, #255	; 0xff
 800098a:	4094      	lsls	r4, r2
 800098c:	4091      	lsls	r1, r2
 800098e:	f020 0303 	bic.w	r3, r0, #3
 8000992:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8000996:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 800099a:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 800099e:	2201      	movs	r2, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:49
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80009a0:	ea25 0404 	bic.w	r4, r5, r4
 80009a4:	430c      	orrs	r4, r1
 80009a6:	f8c3 4300 	str.w	r4, [r3, #768]	; 0x300
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 80009aa:	f000 031f 	and.w	r3, r0, #31
 80009ae:	fa02 f303 	lsl.w	r3, r2, r3
 80009b2:	0940      	lsrs	r0, r0, #5
 80009b4:	0080      	lsls	r0, r0, #2
 80009b6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80009ba:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80009be:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:51
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
 80009c2:	6003      	str	r3, [r0, #0]
 80009c4:	bd30      	pop	{r4, r5, pc}
	...

080009d0 <nvicSetSystemHandlerPriority>:
nvicSetSystemHandlerPriority():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 80009d0:	f020 0303 	bic.w	r3, r0, #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:75
  unsigned sh = (handler & 3) * 8;
 80009d4:	f000 0003 	and.w	r0, r0, #3
 80009d8:	00c0      	lsls	r0, r0, #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:78

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
                           ~(0xFF << sh)) | (prio << sh);
 80009da:	22ff      	movs	r2, #255	; 0xff
 80009dc:	4082      	lsls	r2, r0
 80009de:	4081      	lsls	r1, r0
 80009e0:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 80009e4:	b510      	push	{r4, lr}
 80009e6:	f503 436d 	add.w	r3, r3, #60672	; 0xed00
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:77
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 80009ea:	699c      	ldr	r4, [r3, #24]
 80009ec:	ea24 0202 	bic.w	r2, r4, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:78
                           ~(0xFF << sh)) | (prio << sh);
 80009f0:	430a      	orrs	r2, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/nvic.c:77
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 80009f2:	619a      	str	r2, [r3, #24]
 80009f4:	bd10      	pop	{r4, pc}
	...

08000a00 <Vector6C>:
Vector6C():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:114
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
 8000a00:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:119
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000a02:	4b07      	ldr	r3, [pc, #28]	; (8000a20 <Vector6C+0x20>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8000a04:	220f      	movs	r2, #15
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000a06:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8000a08:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:121
  if (dma_isr_redir[0].dma_func)
 8000a0a:	4a06      	ldr	r2, [pc, #24]	; (8000a24 <Vector6C+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000a0c:	f001 010f 	and.w	r1, r1, #15
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:121
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
 8000a10:	6813      	ldr	r3, [r2, #0]
 8000a12:	b10b      	cbz	r3, 8000a18 <Vector6C+0x18>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:122
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8000a14:	6850      	ldr	r0, [r2, #4]
 8000a16:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:125

  CH_IRQ_EPILOGUE();
}
 8000a18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:124
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a1c:	f7ff bea0 	b.w	8000760 <_port_irq_epilogue>
 8000a20:	40026000 	.word	0x40026000
 8000a24:	20000828 	.word	0x20000828
	...

08000a30 <Vector70>:
Vector70():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:132
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
 8000a30:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:137
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000a32:	4b07      	ldr	r3, [pc, #28]	; (8000a50 <Vector70+0x20>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 8000a34:	22f0      	movs	r2, #240	; 0xf0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000a36:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 8000a38:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:139
  if (dma_isr_redir[1].dma_func)
 8000a3a:	4a06      	ldr	r2, [pc, #24]	; (8000a54 <Vector70+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000a3c:	f3c1 1103 	ubfx	r1, r1, #4, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:139
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
 8000a40:	6893      	ldr	r3, [r2, #8]
 8000a42:	b10b      	cbz	r3, 8000a48 <Vector70+0x18>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:140
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8000a44:	68d0      	ldr	r0, [r2, #12]
 8000a46:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:143

  CH_IRQ_EPILOGUE();
}
 8000a48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:142
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a4c:	f7ff be88 	b.w	8000760 <_port_irq_epilogue>
 8000a50:	40026000 	.word	0x40026000
 8000a54:	20000828 	.word	0x20000828
	...

08000a60 <Vector74>:
Vector74():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:150
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
 8000a60:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:155
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000a62:	4b08      	ldr	r3, [pc, #32]	; (8000a84 <Vector74+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 8000a64:	f44f 6270 	mov.w	r2, #3840	; 0xf00
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000a68:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 8000a6a:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:157
  if (dma_isr_redir[2].dma_func)
 8000a6c:	4a06      	ldr	r2, [pc, #24]	; (8000a88 <Vector74+0x28>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000a6e:	f3c1 2103 	ubfx	r1, r1, #8, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:157
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
 8000a72:	6913      	ldr	r3, [r2, #16]
 8000a74:	b10b      	cbz	r3, 8000a7a <Vector74+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:158
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8000a76:	6950      	ldr	r0, [r2, #20]
 8000a78:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:161

  CH_IRQ_EPILOGUE();
}
 8000a7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:160
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a7e:	f7ff be6f 	b.w	8000760 <_port_irq_epilogue>
 8000a82:	bf00      	nop
 8000a84:	40026000 	.word	0x40026000
 8000a88:	20000828 	.word	0x20000828
$d():
 8000a8c:	00000000 	.word	0x00000000

08000a90 <Vector78>:
Vector78():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:168
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
 8000a90:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:173
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000a92:	4b08      	ldr	r3, [pc, #32]	; (8000ab4 <Vector78+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8000a94:	f44f 4270 	mov.w	r2, #61440	; 0xf000
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000a98:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8000a9a:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:175
  if (dma_isr_redir[3].dma_func)
 8000a9c:	4a06      	ldr	r2, [pc, #24]	; (8000ab8 <Vector78+0x28>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000a9e:	f3c1 3103 	ubfx	r1, r1, #12, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:175
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
 8000aa2:	6993      	ldr	r3, [r2, #24]
 8000aa4:	b10b      	cbz	r3, 8000aaa <Vector78+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:176
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8000aa6:	69d0      	ldr	r0, [r2, #28]
 8000aa8:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:179

  CH_IRQ_EPILOGUE();
}
 8000aaa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:178
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000aae:	f7ff be57 	b.w	8000760 <_port_irq_epilogue>
 8000ab2:	bf00      	nop
 8000ab4:	40026000 	.word	0x40026000
 8000ab8:	20000828 	.word	0x20000828
$d():
 8000abc:	00000000 	.word	0x00000000

08000ac0 <Vector7C>:
Vector7C():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:186
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
 8000ac0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:191
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000ac2:	4b08      	ldr	r3, [pc, #32]	; (8000ae4 <Vector7C+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8000ac4:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000ac8:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8000aca:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:193
  if (dma_isr_redir[4].dma_func)
 8000acc:	4a06      	ldr	r2, [pc, #24]	; (8000ae8 <Vector7C+0x28>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000ace:	f3c1 4103 	ubfx	r1, r1, #16, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:193
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
 8000ad2:	6a13      	ldr	r3, [r2, #32]
 8000ad4:	b10b      	cbz	r3, 8000ada <Vector7C+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:194
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8000ad6:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8000ad8:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:197

  CH_IRQ_EPILOGUE();
}
 8000ada:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:196
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000ade:	f7ff be3f 	b.w	8000760 <_port_irq_epilogue>
 8000ae2:	bf00      	nop
 8000ae4:	40026000 	.word	0x40026000
 8000ae8:	20000828 	.word	0x20000828
$d():
 8000aec:	00000000 	.word	0x00000000

08000af0 <Vector80>:
Vector80():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:204
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
 8000af0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:209
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000af2:	4b08      	ldr	r3, [pc, #32]	; (8000b14 <Vector80+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 8000af4:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000af8:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 8000afa:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:211
  if (dma_isr_redir[5].dma_func)
 8000afc:	4a06      	ldr	r2, [pc, #24]	; (8000b18 <Vector80+0x28>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000afe:	f3c1 5103 	ubfx	r1, r1, #20, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:211
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
 8000b02:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8000b04:	b10b      	cbz	r3, 8000b0a <Vector80+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:212
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8000b06:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8000b08:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:215

  CH_IRQ_EPILOGUE();
}
 8000b0a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:214
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000b0e:	f7ff be27 	b.w	8000760 <_port_irq_epilogue>
 8000b12:	bf00      	nop
 8000b14:	40026000 	.word	0x40026000
 8000b18:	20000828 	.word	0x20000828
$d():
 8000b1c:	00000000 	.word	0x00000000

08000b20 <Vector84>:
Vector84():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:222
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
 8000b20:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:227
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000b22:	4b08      	ldr	r3, [pc, #32]	; (8000b44 <Vector84+0x24>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8000b24:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000b28:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8000b2a:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:229
  if (dma_isr_redir[6].dma_func)
 8000b2c:	4a06      	ldr	r2, [pc, #24]	; (8000b48 <Vector84+0x28>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000b2e:	f3c1 6103 	ubfx	r1, r1, #24, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:229
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
 8000b32:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000b34:	b10b      	cbz	r3, 8000b3a <Vector84+0x1a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:230
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8000b36:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8000b38:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:233

  CH_IRQ_EPILOGUE();
}
 8000b3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:232
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000b3e:	f7ff be0f 	b.w	8000760 <_port_irq_epilogue>
 8000b42:	bf00      	nop
 8000b44:	40026000 	.word	0x40026000
 8000b48:	20000828 	.word	0x20000828
$d():
 8000b4c:	00000000 	.word	0x00000000

08000b50 <dmaInit>:
dmaInit():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:247
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8000b50:	4a09      	ldr	r2, [pc, #36]	; (8000b78 <dmaInit+0x28>)
 8000b52:	2300      	movs	r3, #0
 8000b54:	6013      	str	r3, [r2, #0]
 8000b56:	210c      	movs	r1, #12
 8000b58:	4359      	muls	r1, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:249 (discriminator 2)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8000b5a:	4a08      	ldr	r2, [pc, #32]	; (8000b7c <dmaInit+0x2c>)
 8000b5c:	5889      	ldr	r1, [r1, r2]
 8000b5e:	2200      	movs	r2, #0
 8000b60:	600a      	str	r2, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:250 (discriminator 2)
    dma_isr_redir[i].dma_func = NULL;
 8000b62:	4907      	ldr	r1, [pc, #28]	; (8000b80 <dmaInit+0x30>)
 8000b64:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:248 (discriminator 2)
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000b68:	3301      	adds	r3, #1
 8000b6a:	2b07      	cmp	r3, #7
 8000b6c:	d1f3      	bne.n	8000b56 <dmaInit+0x6>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:252
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 8000b6e:	4b05      	ldr	r3, [pc, #20]	; (8000b84 <dmaInit+0x34>)
 8000b70:	f04f 32ff 	mov.w	r2, #4294967295
 8000b74:	605a      	str	r2, [r3, #4]
 8000b76:	4770      	bx	lr
 8000b78:	20000860 	.word	0x20000860
 8000b7c:	08001890 	.word	0x08001890
 8000b80:	20000828 	.word	0x20000828
 8000b84:	40026000 	.word	0x40026000
	...

08000b90 <dmaStreamAllocate>:
dmaStreamAllocate():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:282
 * @special
 */
bool_t dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                         uint32_t priority,
                         stm32_dmaisr_t func,
                         void *param) {
 8000b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000b94:	460f      	mov	r7, r1
 8000b96:	4615      	mov	r5, r2
 8000b98:	4698      	mov	r8, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:284

  chDbgCheck(dmastp != NULL, "dmaStreamAllocate");
 8000b9a:	4604      	mov	r4, r0
 8000b9c:	b910      	cbnz	r0, 8000ba4 <dmaStreamAllocate+0x14>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:284 (discriminator 1)
 8000b9e:	481a      	ldr	r0, [pc, #104]	; (8000c08 <dmaStreamAllocate+0x78>)
 8000ba0:	f000 fa4e 	bl	8001040 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:287

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8000ba4:	7a62      	ldrb	r2, [r4, #9]
 8000ba6:	2001      	movs	r0, #1
 8000ba8:	fa00 fc02 	lsl.w	ip, r0, r2
 8000bac:	4e17      	ldr	r6, [pc, #92]	; (8000c0c <dmaStreamAllocate+0x7c>)
 8000bae:	6831      	ldr	r1, [r6, #0]
 8000bb0:	ea1c 0f01 	tst.w	ip, r1
 8000bb4:	d126      	bne.n	8000c04 <dmaStreamAllocate+0x74>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:291
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000bb6:	4816      	ldr	r0, [pc, #88]	; (8000c10 <dmaStreamAllocate+0x80>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8000bb8:	ea4c 0301 	orr.w	r3, ip, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:291
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000bbc:	f840 5032 	str.w	r5, [r0, r2, lsl #3]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8000bc0:	6033      	str	r3, [r6, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000bc2:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8000bc6:	065b      	lsls	r3, r3, #25
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000bc8:	f8c2 8004 	str.w	r8, [r2, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8000bcc:	d004      	beq.n	8000bd8 <dmaStreamAllocate+0x48>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:297
    rccEnableDMA1(FALSE);
 8000bce:	4b11      	ldr	r3, [pc, #68]	; (8000c14 <dmaStreamAllocate+0x84>)
 8000bd0:	69da      	ldr	r2, [r3, #28]
 8000bd2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000bd6:	61da      	str	r2, [r3, #28]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:300

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000bd8:	6823      	ldr	r3, [r4, #0]
 8000bda:	200f      	movs	r0, #15
 8000bdc:	681a      	ldr	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000bde:	2600      	movs	r6, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:300
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000be0:	f022 020f 	bic.w	r2, r2, #15
 8000be4:	601a      	str	r2, [r3, #0]
 8000be6:	7a21      	ldrb	r1, [r4, #8]
 8000be8:	6862      	ldr	r2, [r4, #4]
 8000bea:	fa00 f101 	lsl.w	r1, r0, r1
 8000bee:	6011      	str	r1, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000bf0:	601e      	str	r6, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:304

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 8000bf2:	b135      	cbz	r5, 8000c02 <dmaStreamAllocate+0x72>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:305
    nvicEnableVector(dmastp->vector, CORTEX_PRIORITY_MASK(priority));
 8000bf4:	7aa0      	ldrb	r0, [r4, #10]
 8000bf6:	0139      	lsls	r1, r7, #4
 8000bf8:	f7ff fec2 	bl	8000980 <nvicEnableVector>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:307

  return FALSE;
 8000bfc:	4630      	mov	r0, r6
 8000bfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000c02:	4628      	mov	r0, r5
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/stm32_dma.c:308
}
 8000c04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000c08:	08001840 	.word	0x08001840
 8000c0c:	20000860 	.word	0x20000860
 8000c10:	20000828 	.word	0x20000828
 8000c14:	40023800 	.word	0x40023800
	...

08000c20 <_unhandled_exception>:
_unhandled_exception():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../os/hal/vectors.c:169
 * @notapi
 */
#if !defined(__DOXYGEN__)
__attribute__ ((naked))
#endif
void _unhandled_exception(void) {
 8000c20:	e7fe      	b.n	8000c20 <_unhandled_exception>
	...

08000c30 <Clk_t::EnableHSI()>:
_ZN5Clk_t9EnableHSIEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:26
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

uint8_t Clk_t::EnableHSI() {
    RCC->CR |= RCC_CR_HSION;
 8000c30:	4b08      	ldr	r3, [pc, #32]	; (8000c54 <Clk_t::EnableHSI()+0x24>)
 8000c32:	681a      	ldr	r2, [r3, #0]
 8000c34:	f042 0201 	orr.w	r2, r2, #1
 8000c38:	601a      	str	r2, [r3, #0]
 8000c3a:	f44f 63a0 	mov.w	r3, #1280	; 0x500
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:30
    // Wait until ready
    uint32_t StartUpCounter=0;
    do {
        if(RCC->CR & RCC_CR_HSIRDY) return 0;   // HSI is ready
 8000c3e:	4a05      	ldr	r2, [pc, #20]	; (8000c54 <Clk_t::EnableHSI()+0x24>)
 8000c40:	6812      	ldr	r2, [r2, #0]
 8000c42:	0792      	lsls	r2, r2, #30
 8000c44:	d403      	bmi.n	8000c4e <Clk_t::EnableHSI()+0x1e>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:29

uint8_t Clk_t::EnableHSI() {
    RCC->CR |= RCC_CR_HSION;
    // Wait until ready
    uint32_t StartUpCounter=0;
    do {
 8000c46:	3b01      	subs	r3, #1
 8000c48:	d1f9      	bne.n	8000c3e <Clk_t::EnableHSI()+0xe>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:33
        if(RCC->CR & RCC_CR_HSIRDY) return 0;   // HSI is ready
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
 8000c4a:	2001      	movs	r0, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:34
}
 8000c4c:	4770      	bx	lr
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:30
uint8_t Clk_t::EnableHSI() {
    RCC->CR |= RCC_CR_HSION;
    // Wait until ready
    uint32_t StartUpCounter=0;
    do {
        if(RCC->CR & RCC_CR_HSIRDY) return 0;   // HSI is ready
 8000c4e:	2000      	movs	r0, #0
 8000c50:	4770      	bx	lr
 8000c52:	bf00      	nop
 8000c54:	40023800 	.word	0x40023800
	...

08000c60 <Clk_t::UpdateFreqValues()>:
_ZN5Clk_t16UpdateFreqValuesEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8000c60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000c62:	b093      	sub	sp, #76	; 0x4c
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000c64:	2100      	movs	r1, #0
 8000c66:	2220      	movs	r2, #32
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8000c68:	4605      	mov	r5, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000c6a:	a80a      	add	r0, sp, #40	; 0x28
 8000c6c:	f000 fd10 	bl	8001690 <memset>
 8000c70:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c74:	930a      	str	r3, [sp, #40]	; 0x28
 8000c76:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000c7a:	930b      	str	r3, [sp, #44]	; 0x2c
 8000c7c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000c80:	930c      	str	r3, [sp, #48]	; 0x30
 8000c82:	4b34      	ldr	r3, [pc, #208]	; (8000d54 <Clk_t::UpdateFreqValues()+0xf4>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000c84:	4a34      	ldr	r2, [pc, #208]	; (8000d58 <Clk_t::UpdateFreqValues()+0xf8>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000c86:	930d      	str	r3, [sp, #52]	; 0x34
 8000c88:	4b34      	ldr	r3, [pc, #208]	; (8000d5c <Clk_t::UpdateFreqValues()+0xfc>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000c8a:	6851      	ldr	r1, [r2, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000c8c:	930e      	str	r3, [sp, #56]	; 0x38
 8000c8e:	4b34      	ldr	r3, [pc, #208]	; (8000d60 <Clk_t::UpdateFreqValues()+0x100>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000c90:	6810      	ldr	r0, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000c92:	930f      	str	r3, [sp, #60]	; 0x3c
 8000c94:	4b33      	ldr	r3, [pc, #204]	; (8000d64 <Clk_t::UpdateFreqValues()+0x104>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:64
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8000c96:	ae06      	add	r6, sp, #24
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000c98:	9310      	str	r3, [sp, #64]	; 0x40
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000c9a:	ab03      	add	r3, sp, #12
 8000c9c:	c303      	stmia	r3!, {r0, r1}
 8000c9e:	7a11      	ldrb	r1, [r2, #8]
 8000ca0:	7019      	strb	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:64
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8000ca2:	f102 0309 	add.w	r3, r2, #9
 8000ca6:	3219      	adds	r2, #25
 8000ca8:	4617      	mov	r7, r2
 8000caa:	6818      	ldr	r0, [r3, #0]
 8000cac:	6859      	ldr	r1, [r3, #4]
 8000cae:	4634      	mov	r4, r6
 8000cb0:	c403      	stmia	r4!, {r0, r1}
 8000cb2:	3308      	adds	r3, #8
 8000cb4:	4293      	cmp	r3, r2
 8000cb6:	4626      	mov	r6, r4
 8000cb8:	d1f7      	bne.n	8000caa <Clk_t::UpdateFreqValues()+0x4a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:65
    const uint8_t APBPrescTable[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8000cba:	6838      	ldr	r0, [r7, #0]
 8000cbc:	6879      	ldr	r1, [r7, #4]
 8000cbe:	ab01      	add	r3, sp, #4
 8000cc0:	c303      	stmia	r3!, {r0, r1}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:68

    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000cc2:	4b29      	ldr	r3, [pc, #164]	; (8000d68 <Clk_t::UpdateFreqValues()+0x108>)
 8000cc4:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:69
    tmp >>= 2;
 8000cc6:	f3c2 0281 	ubfx	r2, r2, #2, #2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:70
    switch(tmp) {
 8000cca:	2a02      	cmp	r2, #2
 8000ccc:	d024      	beq.n	8000d18 <Clk_t::UpdateFreqValues()+0xb8>
 8000cce:	2a03      	cmp	r2, #3
 8000cd0:	d00c      	beq.n	8000cec <Clk_t::UpdateFreqValues()+0x8c>
 8000cd2:	2a01      	cmp	r2, #1
 8000cd4:	d101      	bne.n	8000cda <Clk_t::UpdateFreqValues()+0x7a>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:77
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
            SysClkHz = MSIClk[tmp];
            break;

        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
 8000cd6:	4b25      	ldr	r3, [pc, #148]	; (8000d6c <Clk_t::UpdateFreqValues()+0x10c>)
 8000cd8:	e01f      	b.n	8000d1a <Clk_t::UpdateFreqValues()+0xba>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8000cda:	685b      	ldr	r3, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8000cdc:	a812      	add	r0, sp, #72	; 0x48
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8000cde:	f3c3 3342 	ubfx	r3, r3, #13, #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8000ce2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8000ce6:	f853 3c20 	ldr.w	r3, [r3, #-32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:74
            break;
 8000cea:	e016      	b.n	8000d1a <Clk_t::UpdateFreqValues()+0xba>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8000cec:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8000cee:	a912      	add	r1, sp, #72	; 0x48
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8000cf0:	f3c2 4283 	ubfx	r2, r2, #18, #4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8000cf4:	440a      	add	r2, r1
 8000cf6:	f812 1c3c 	ldrb.w	r1, [r2, #-60]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:88
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000cfa:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8000cfc:	689b      	ldr	r3, [r3, #8]
 8000cfe:	481c      	ldr	r0, [pc, #112]	; (8000d70 <Clk_t::UpdateFreqValues()+0x110>)
 8000d00:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8000d04:	4b19      	ldr	r3, [pc, #100]	; (8000d6c <Clk_t::UpdateFreqValues()+0x10c>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000d06:	f3c2 5281 	ubfx	r2, r2, #22, #2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8000d0a:	bf18      	it	ne
 8000d0c:	4603      	movne	r3, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:91
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8000d0e:	434b      	muls	r3, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000d10:	3201      	adds	r2, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:91
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8000d12:	fbb3 f3f2 	udiv	r3, r3, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:92
            break;
 8000d16:	e000      	b.n	8000d1a <Clk_t::UpdateFreqValues()+0xba>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:81
        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
            break;

        case 0b10: // HSE
            SysClkHz = CRYSTAL_FREQ_HZ;
 8000d18:	4b15      	ldr	r3, [pc, #84]	; (8000d70 <Clk_t::UpdateFreqValues()+0x110>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:96
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
            break;
    } // switch

    // AHB freq
    tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000d1a:	4a13      	ldr	r2, [pc, #76]	; (8000d68 <Clk_t::UpdateFreqValues()+0x108>)
 8000d1c:	a812      	add	r0, sp, #72	; 0x48
 8000d1e:	6891      	ldr	r1, [r2, #8]
 8000d20:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8000d24:	4401      	add	r1, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:97
    AHBFreqHz = SysClkHz >> tmp;
 8000d26:	f811 1c30 	ldrb.w	r1, [r1, #-48]
 8000d2a:	40cb      	lsrs	r3, r1
 8000d2c:	602b      	str	r3, [r5, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:99
    // APB freq
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> 8];
 8000d2e:	6891      	ldr	r1, [r2, #8]
 8000d30:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8000d34:	4401      	add	r1, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:100
    APB1FreqHz = AHBFreqHz >> tmp;
 8000d36:	f811 1c44 	ldrb.w	r1, [r1, #-68]
 8000d3a:	fa23 f101 	lsr.w	r1, r3, r1
 8000d3e:	6069      	str	r1, [r5, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:101
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> 11];
 8000d40:	6892      	ldr	r2, [r2, #8]
 8000d42:	f3c2 22c2 	ubfx	r2, r2, #11, #3
 8000d46:	4402      	add	r2, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:102
    APB2FreqHz = AHBFreqHz >> tmp;
 8000d48:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 8000d4c:	40d3      	lsrs	r3, r2
 8000d4e:	60ab      	str	r3, [r5, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:103
}
 8000d50:	b013      	add	sp, #76	; 0x4c
 8000d52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d54:	0007ff9c 	.word	0x0007ff9c
 8000d58:	08001730 	.word	0x08001730
 8000d5c:	000ffdc0 	.word	0x000ffdc0
 8000d60:	001fff68 	.word	0x001fff68
 8000d64:	003ffed0 	.word	0x003ffed0
 8000d68:	40023800 	.word	0x40023800
 8000d6c:	00f42400 	.word	0x00f42400
 8000d70:	007a1200 	.word	0x007a1200
	...

08000d80 <Clk_t::SwitchToHSI()>:
_ZN5Clk_t11SwitchToHSIEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:118
    tmp |= ((uint32_t)APB2Div) << 11;
    RCC->CFGR = tmp;
}

// Enables HSI, switches to HSI
uint8_t Clk_t::SwitchToHSI() {
 8000d80:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:119
    if(EnableHSI() != 0) return 1;
 8000d82:	f7ff ff55 	bl	8000c30 <Clk_t::EnableHSI()>
 8000d86:	b960      	cbnz	r0, 8000da2 <Clk_t::SwitchToHSI()+0x22>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:120
    uint32_t tmp = RCC->CFGR;
 8000d88:	4b07      	ldr	r3, [pc, #28]	; (8000da8 <Clk_t::SwitchToHSI()+0x28>)
 8000d8a:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:121
    tmp &= ~RCC_CFGR_SW;
 8000d8c:	f022 0203 	bic.w	r2, r2, #3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:122
    tmp |=  RCC_CFGR_SW_HSI;  // Select HSI as system clock src
 8000d90:	f042 0201 	orr.w	r2, r2, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:123
    RCC->CFGR = tmp;
 8000d94:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:124 (discriminator 1)
    while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI); // Wait till ready
 8000d96:	689a      	ldr	r2, [r3, #8]
 8000d98:	f002 020c 	and.w	r2, r2, #12
 8000d9c:	2a04      	cmp	r2, #4
 8000d9e:	d1fa      	bne.n	8000d96 <Clk_t::SwitchToHSI()+0x16>
 8000da0:	bd08      	pop	{r3, pc}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:119
    RCC->CFGR = tmp;
}

// Enables HSI, switches to HSI
uint8_t Clk_t::SwitchToHSI() {
    if(EnableHSI() != 0) return 1;
 8000da2:	2001      	movs	r0, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:126
    tmp &= ~RCC_CFGR_SW;
    tmp |=  RCC_CFGR_SW_HSI;  // Select HSI as system clock src
    RCC->CFGR = tmp;
    while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI); // Wait till ready
    return 0;
}
 8000da4:	bd08      	pop	{r3, pc}
 8000da6:	bf00      	nop
 8000da8:	40023800 	.word	0x40023800
$d():
 8000dac:	00000000 	.word	0x00000000

08000db0 <SetupVCore(VCore_t)>:
_Z10SetupVCore7VCore_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:198

// =============================== V Core ======================================
VCore_t VCore;
void SetupVCore(VCore_t AVCore) {
    // PWR clock enable
    RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000db0:	4b09      	ldr	r3, [pc, #36]	; (8000dd8 <SetupVCore(VCore_t)+0x28>)
 8000db2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000db6:	625a      	str	r2, [r3, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:200 (discriminator 1)
    // Core voltage setup
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8000db8:	4b08      	ldr	r3, [pc, #32]	; (8000ddc <SetupVCore(VCore_t)+0x2c>)
 8000dba:	685a      	ldr	r2, [r3, #4]
 8000dbc:	06d1      	lsls	r1, r2, #27
 8000dbe:	d4fb      	bmi.n	8000db8 <SetupVCore(VCore_t)+0x8>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:201
    uint32_t tmp = PWR->CR;
 8000dc0:	681a      	ldr	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:202
    tmp &= ~PWR_CR_VOS;
 8000dc2:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:203
    tmp |= ((uint32_t)AVCore) << 11;
 8000dc6:	ea42 22c0 	orr.w	r2, r2, r0, lsl #11
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:204
    PWR->CR = tmp;
 8000dca:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:205 (discriminator 1)
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8000dcc:	685a      	ldr	r2, [r3, #4]
 8000dce:	06d2      	lsls	r2, r2, #27
 8000dd0:	d4fc      	bmi.n	8000dcc <SetupVCore(VCore_t)+0x1c>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/clocking_L1xx.cpp:206
    VCore = AVCore;
 8000dd2:	4b03      	ldr	r3, [pc, #12]	; (8000de0 <SetupVCore(VCore_t)+0x30>)
 8000dd4:	7018      	strb	r0, [r3, #0]
 8000dd6:	4770      	bx	lr
 8000dd8:	40023800 	.word	0x40023800
 8000ddc:	40007000 	.word	0x40007000
 8000de0:	20000864 	.word	0x20000864
	...

08000df0 <CmdUart_t::ISendViaDMA()>:
_ZN9CmdUart_t11ISendViaDMAEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:45
    // Start transmission if Idle
    if(IDmaIsIdle) ISendViaDMA();
}

void CmdUart_t::ISendViaDMA() {
    uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead; // Cnt from PRead to end of buf
 8000df0:	f8d0 15dc 	ldr.w	r1, [r0, #1500]	; 0x5dc
 8000df4:	f200 52dc 	addw	r2, r0, #1500	; 0x5dc
 8000df8:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 8000dfc:	1a52      	subs	r2, r2, r1
 8000dfe:	429a      	cmp	r2, r3
 8000e00:	bf28      	it	cs
 8000e02:	461a      	movcs	r2, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:46
    ITransSize = MIN(IFullSlotsCount, PartSz);
 8000e04:	f8c0 25ec 	str.w	r2, [r0, #1516]	; 0x5ec
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:47
    if(ITransSize != 0) {
 8000e08:	b162      	cbz	r2, 8000e24 <CmdUart_t::ISendViaDMA()+0x34>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:48
        IDmaIsIdle = false;
 8000e0a:	2300      	movs	r3, #0
 8000e0c:	f880 35e4 	strb.w	r3, [r0, #1508]	; 0x5e4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:49
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8000e10:	4b05      	ldr	r3, [pc, #20]	; (8000e28 <CmdUart_t::ISendViaDMA()+0x38>)
 8000e12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000e14:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:50
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8000e16:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:51
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8000e18:	2292      	movs	r2, #146	; 0x92
 8000e1a:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:52
        dmaStreamEnable(UART_DMA_TX);
 8000e1c:	681a      	ldr	r2, [r3, #0]
 8000e1e:	f042 0201 	orr.w	r2, r2, #1
 8000e22:	601a      	str	r2, [r3, #0]
 8000e24:	4770      	bx	lr
 8000e26:	bf00      	nop
 8000e28:	08001890 	.word	0x08001890
$d():
 8000e2c:	00000000 	.word	0x00000000

08000e30 <CmdUart_t::Init(unsigned long)>:
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:91
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
 8000e30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000e34:	4f54      	ldr	r7, [pc, #336]	; (8000f88 <CmdUart_t::Init(unsigned long)+0x158>)
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:95
    PWrite = TXBuf;
    PRead = TXBuf;
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
 8000e36:	f04f 0800 	mov.w	r8, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:91
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
 8000e3a:	4606      	mov	r6, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:92
    PWrite = TXBuf;
 8000e3c:	f8c6 05e0 	str.w	r0, [r6, #1504]	; 0x5e0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:93
    PRead = TXBuf;
 8000e40:	f8c6 05dc 	str.w	r0, [r6, #1500]	; 0x5dc
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:94
    IDmaIsIdle = true;
 8000e44:	2301      	movs	r3, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:95
    IFullSlotsCount = 0;
 8000e46:	f8c0 85e8 	str.w	r8, [r0, #1512]	; 0x5e8
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:94
}

void CmdUart_t::Init(uint32_t ABaudrate) {
    PWrite = TXBuf;
    PRead = TXBuf;
    IDmaIsIdle = true;
 8000e4a:	f880 35e4 	strb.w	r3, [r0, #1508]	; 0x5e4
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
 8000e4e:	69fb      	ldr	r3, [r7, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000e50:	4c4e      	ldr	r4, [pc, #312]	; (8000f8c <CmdUart_t::Init(unsigned long)+0x15c>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000e52:	f043 0301 	orr.w	r3, r3, #1
 8000e56:	61fb      	str	r3, [r7, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000e58:	6823      	ldr	r3, [r4, #0]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:100
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
    UART->CR1 = USART_CR1_UE;     // Enable USART
 8000e5a:	4d4d      	ldr	r5, [pc, #308]	; (8000f90 <CmdUart_t::Init(unsigned long)+0x160>)
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
 8000e5c:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8000e60:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8000e62:	6823      	ldr	r3, [r4, #0]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:105
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8000e64:	f8df b134 	ldr.w	fp, [pc, #308]	; 8000f9c <CmdUart_t::Init(unsigned long)+0x16c>
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:245
 8000e68:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000e6c:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000e6e:	88a0      	ldrh	r0, [r4, #4]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:105
 8000e70:	4a48      	ldr	r2, [pc, #288]	; (8000f94 <CmdUart_t::Init(unsigned long)+0x164>)
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:247
 8000e72:	f420 7000 	bic.w	r0, r0, #512	; 0x200
 8000e76:	0400      	lsls	r0, r0, #16
 8000e78:	0c00      	lsrs	r0, r0, #16
 8000e7a:	80a0      	strh	r0, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000e7c:	88a3      	ldrh	r3, [r4, #4]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:106
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 8000e7e:	46d9      	mov	r9, fp
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
 8000e80:	b29b      	uxth	r3, r3
 8000e82:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000e84:	68e3      	ldr	r3, [r4, #12]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:105
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8000e86:	4658      	mov	r0, fp
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:250
 8000e88:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8000e8c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000e8e:	68e3      	ldr	r3, [r4, #12]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:106
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 8000e90:	f8df a10c 	ldr.w	sl, [pc, #268]	; 8000fa0 <CmdUart_t::Init(unsigned long)+0x170>
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:251
 8000e94:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000e96:	68a3      	ldr	r3, [r4, #8]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:117

    PinSetupAlterFunc(UART_GPIO, UART_RX_PIN,  omOpenDrain, pudPullUp, UART_AF);

    dmaStreamAllocate     (UART_DMA_RX, IRQ_PRIO_LOW, nullptr, NULL);
    dmaStreamSetPeripheral(UART_DMA_RX, &UART->DR);
    dmaStreamSetMemory0   (UART_DMA_RX, IRxBuf);
 8000e98:	f506 66bf 	add.w	r6, r6, #1528	; 0x5f8
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:253
 8000e9c:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8000ea0:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8000ea2:	68a3      	ldr	r3, [r4, #8]
 8000ea4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000ea8:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8000eaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000eac:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000eb0:	6263      	str	r3, [r4, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8000eb2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000eb4:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 8000eb8:	6263      	str	r3, [r4, #36]	; 0x24
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:99
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8000eba:	6a3b      	ldr	r3, [r7, #32]
 8000ebc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000ec0:	623b      	str	r3, [r7, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:100
    UART->CR1 = USART_CR1_UE;     // Enable USART
 8000ec2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000ec6:	81ab      	strh	r3, [r5, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:101
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
 8000ec8:	4b33      	ldr	r3, [pc, #204]	; (8000f98 <CmdUart_t::Init(unsigned long)+0x168>)
 8000eca:	689b      	ldr	r3, [r3, #8]
 8000ecc:	fbb3 f1f1 	udiv	r1, r3, r1
 8000ed0:	b28b      	uxth	r3, r1
 8000ed2:	812b      	strh	r3, [r5, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:105
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8000ed4:	2107      	movs	r1, #7
 8000ed6:	4643      	mov	r3, r8
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:103
    // ==== USART configuration ====
    UART_RCC_ENABLE();
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
 8000ed8:	f8a5 8010 	strh.w	r8, [r5, #16]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:105
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8000edc:	f7ff fe58 	bl	8000b90 <dmaStreamAllocate>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:106
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 8000ee0:	f859 3924 	ldr.w	r3, [r9], #-36
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:107
    dmaStreamSetMode      (UART_DMA_TX, UART_DMA_TX_MODE);
 8000ee4:	2292      	movs	r2, #146	; 0x92
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:106
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 8000ee6:	f8c3 a008 	str.w	sl, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:107
    dmaStreamSetMode      (UART_DMA_TX, UART_DMA_TX_MODE);
 8000eea:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:110

#if UART_RX_ENABLED
    UART->CR1 = USART_CR1_TE | USART_CR1_RE;        // TX & RX enable
 8000eec:	230c      	movs	r3, #12
 8000eee:	81ab      	strh	r3, [r5, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:111
    UART->CR3 = USART_CR3_DMAT | USART_CR3_DMAR;    // Enable DMA at TX & RX
 8000ef0:	23c0      	movs	r3, #192	; 0xc0
 8000ef2:	82ab      	strh	r3, [r5, #20]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000ef4:	69fb      	ldr	r3, [r7, #28]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:115

    PinSetupAlterFunc(UART_GPIO, UART_RX_PIN,  omOpenDrain, pudPullUp, UART_AF);

    dmaStreamAllocate     (UART_DMA_RX, IRQ_PRIO_LOW, nullptr, NULL);
 8000ef6:	4642      	mov	r2, r8
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
 8000ef8:	f043 0301 	orr.w	r3, r3, #1
 8000efc:	61fb      	str	r3, [r7, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000efe:	6823      	ldr	r3, [r4, #0]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:115
 8000f00:	f10b 000c 	add.w	r0, fp, #12
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
 8000f04:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8000f08:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8000f0a:	6823      	ldr	r3, [r4, #0]
 8000f0c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000f10:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000f12:	88a1      	ldrh	r1, [r4, #4]
 8000f14:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8000f18:	0409      	lsls	r1, r1, #16
 8000f1a:	0c09      	lsrs	r1, r1, #16
 8000f1c:	80a1      	strh	r1, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000f1e:	88a3      	ldrh	r3, [r4, #4]
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:115
 8000f20:	210f      	movs	r1, #15
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
 8000f22:	b29b      	uxth	r3, r3
 8000f24:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000f28:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000f2a:	68e3      	ldr	r3, [r4, #12]
 8000f2c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8000f30:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000f32:	68e3      	ldr	r3, [r4, #12]
 8000f34:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000f38:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000f3a:	68a3      	ldr	r3, [r4, #8]
 8000f3c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8000f40:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8000f42:	68a3      	ldr	r3, [r4, #8]
 8000f44:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000f48:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8000f4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000f4c:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8000f50:	6263      	str	r3, [r4, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8000f52:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000f54:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 8000f58:	6263      	str	r3, [r4, #36]	; 0x24
_ZN9CmdUart_t4InitEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:115
 8000f5a:	4643      	mov	r3, r8
 8000f5c:	f7ff fe18 	bl	8000b90 <dmaStreamAllocate>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:116
    dmaStreamSetPeripheral(UART_DMA_RX, &UART->DR);
 8000f60:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:118
    dmaStreamSetMemory0   (UART_DMA_RX, IRxBuf);
    dmaStreamSetTransactionSize(UART_DMA_RX, UART_RXBUF_SZ);
 8000f64:	2248      	movs	r2, #72	; 0x48
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:116
    UART->CR3 = USART_CR3_DMAT | USART_CR3_DMAR;    // Enable DMA at TX & RX

    PinSetupAlterFunc(UART_GPIO, UART_RX_PIN,  omOpenDrain, pudPullUp, UART_AF);

    dmaStreamAllocate     (UART_DMA_RX, IRQ_PRIO_LOW, nullptr, NULL);
    dmaStreamSetPeripheral(UART_DMA_RX, &UART->DR);
 8000f66:	f8c3 a008 	str.w	sl, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:117
    dmaStreamSetMemory0   (UART_DMA_RX, IRxBuf);
 8000f6a:	60de      	str	r6, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:118
    dmaStreamSetTransactionSize(UART_DMA_RX, UART_RXBUF_SZ);
 8000f6c:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:119
    dmaStreamSetMode      (UART_DMA_RX, UART_DMA_RX_MODE);
 8000f6e:	22a0      	movs	r2, #160	; 0xa0
 8000f70:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:120
    dmaStreamEnable       (UART_DMA_RX);
 8000f72:	681a      	ldr	r2, [r3, #0]
 8000f74:	f042 0201 	orr.w	r2, r2, #1
 8000f78:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:125
#else
    UART->CR1 = USART_CR1_TE;     // Transmitter enabled
    UART->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
 8000f7a:	89ab      	ldrh	r3, [r5, #12]
 8000f7c:	b29b      	uxth	r3, r3
 8000f7e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000f82:	81ab      	strh	r3, [r5, #12]
 8000f84:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f88:	40023800 	.word	0x40023800
 8000f8c:	40020000 	.word	0x40020000
 8000f90:	40013800 	.word	0x40013800
 8000f94:	08001011 	.word	0x08001011
 8000f98:	20000868 	.word	0x20000868
 8000f9c:	080018b4 	.word	0x080018b4
 8000fa0:	40013804 	.word	0x40013804
	...

08000fb0 <CmdUart_t::IRQDmaTxHandler()>:
_ZN9CmdUart_t15IRQDmaTxHandlerEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:130
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8000fb0:	4a13      	ldr	r2, [pc, #76]	; (8001000 <CmdUart_t::IRQDmaTxHandler()+0x50>)
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:129
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
 8000fb2:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:130
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8000fb4:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8000fb6:	680c      	ldr	r4, [r1, #0]
 8000fb8:	f024 040f 	bic.w	r4, r4, #15
 8000fbc:	600c      	str	r4, [r1, #0]
 8000fbe:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8000fc0:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8000fc4:	240f      	movs	r4, #15
 8000fc6:	fa04 f202 	lsl.w	r2, r4, r2
 8000fca:	600a      	str	r2, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:132
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8000fcc:	f8d0 45dc 	ldr.w	r4, [r0, #1500]	; 0x5dc
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:131
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8000fd0:	f8d0 15ec 	ldr.w	r1, [r0, #1516]	; 0x5ec
 8000fd4:	f8d0 25e8 	ldr.w	r2, [r0, #1512]	; 0x5e8
 8000fd8:	1a52      	subs	r2, r2, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:132
    PRead += ITransSize;
 8000fda:	4421      	add	r1, r4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:133
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer
 8000fdc:	f200 54dc 	addw	r4, r0, #1500	; 0x5dc
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:132

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8000fe0:	42a1      	cmp	r1, r4
 8000fe2:	bf28      	it	cs
 8000fe4:	4601      	movcs	r1, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:131
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8000fe6:	f8c0 25e8 	str.w	r2, [r0, #1512]	; 0x5e8
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:132
    PRead += ITransSize;
 8000fea:	f8c0 15dc 	str.w	r1, [r0, #1500]	; 0x5dc
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:135
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer

    if(IFullSlotsCount == 0) IDmaIsIdle = true; // Nothing left to send
 8000fee:	b91a      	cbnz	r2, 8000ff8 <CmdUart_t::IRQDmaTxHandler()+0x48>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:135 (discriminator 1)
 8000ff0:	2201      	movs	r2, #1
 8000ff2:	f880 25e4 	strb.w	r2, [r0, #1508]	; 0x5e4
 8000ff6:	bd10      	pop	{r4, pc}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:137
    else ISendViaDMA();
}
 8000ff8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:136
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer

    if(IFullSlotsCount == 0) IDmaIsIdle = true; // Nothing left to send
    else ISendViaDMA();
 8000ffc:	f7ff bef8 	b.w	8000df0 <CmdUart_t::ISendViaDMA()>
 8001000:	08001890 	.word	0x08001890
	...

08001010 <CmdUartTxIrq>:
CmdUartTxIrq():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.cpp:88
#endif

// ==== Init & DMA ====
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
 8001010:	4801      	ldr	r0, [pc, #4]	; (8001018 <CmdUartTxIrq+0x8>)
 8001012:	f7ff bfcd 	b.w	8000fb0 <CmdUart_t::IRQDmaTxHandler()>
 8001016:	bf00      	nop
 8001018:	20000874 	.word	0x20000874
$d():
 800101c:	00000000 	.word	0x00000000

08001020 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>:
_ZN9CmdUart_t8PrintNowEPKc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.h:98
#endif
public:
    void Printf(const char *S, ...);
    void PrintfI(const char *S, ...);
    void FlushTx() { while(!IDmaIsIdle); }  // wait DMA
    void PrintNow(const char *S) {
 8001020:	3801      	subs	r0, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.h:99
        while(*S != 0) {
 8001022:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8001026:	b12b      	cbz	r3, 8001034 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x14>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.h:100
            while(!(UART->SR & USART_SR_TXE));
 8001028:	4a03      	ldr	r2, [pc, #12]	; (8001038 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x18>)
 800102a:	8811      	ldrh	r1, [r2, #0]
 800102c:	0609      	lsls	r1, r1, #24
 800102e:	d5fb      	bpl.n	8001028 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x8>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.h:101
            UART->DR = *S++;
 8001030:	8093      	strh	r3, [r2, #4]
 8001032:	e7f6      	b.n	8001022 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x2>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/cmd_uart.h:103
        }
    }
 8001034:	4770      	bx	lr
 8001036:	bf00      	nop
 8001038:	40013800 	.word	0x40013800
$d():
 800103c:	00000000 	.word	0x00000000

08001040 <chDbgPanic>:
chDbgPanic():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.cpp:144
    Tim->PSC = (uint16_t)FPrescaler;
}
#endif

#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
 8001040:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.cpp:145
    Uart.PrintNow(msg1);
 8001042:	f7ff ffed 	bl	8001020 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.cpp:146
    Uart.PrintNow(" @");
 8001046:	4806      	ldr	r0, [pc, #24]	; (8001060 <chDbgPanic+0x20>)
 8001048:	f7ff ffea 	bl	8001020 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.cpp:147
    Uart.PrintNow(chThdSelf()->p_name);
 800104c:	4b05      	ldr	r3, [pc, #20]	; (8001064 <chDbgPanic+0x24>)
 800104e:	699b      	ldr	r3, [r3, #24]
 8001050:	6998      	ldr	r0, [r3, #24]
 8001052:	f7ff ffe5 	bl	8001020 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.cpp:149
    Uart.PrintNow("\r");
}
 8001056:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.cpp:148
#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
    Uart.PrintNow(msg1);
    Uart.PrintNow(" @");
    Uart.PrintNow(chThdSelf()->p_name);
    Uart.PrintNow("\r");
 800105a:	4803      	ldr	r0, [pc, #12]	; (8001068 <chDbgPanic+0x28>)
 800105c:	f7ff bfe0 	b.w	8001020 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
 8001060:	080018f0 	.word	0x080018f0
 8001064:	20000f70 	.word	0x20000f70
 8001068:	080018f3 	.word	0x080018f3
$d():
 800106c:	00000000 	.word	0x00000000

08001070 <cc1101_t::BusyWait() [clone .isra.6]>:
PinIsSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:179
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 8001070:	4b02      	ldr	r3, [pc, #8]	; (800107c <cc1101_t::BusyWait() [clone .isra.6]+0xc>)
 8001072:	8a1b      	ldrh	r3, [r3, #16]
_ZN8cc1101_t8BusyWaitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:38
 8001074:	065b      	lsls	r3, r3, #25
 8001076:	d4fb      	bmi.n	8001070 <cc1101_t::BusyWait() [clone .isra.6]>
 8001078:	4770      	bx	lr
 800107a:	bf00      	nop
 800107c:	40020000 	.word	0x40020000

08001080 <Spi_t::ReadWriteByte(unsigned char)>:
_ZN5Spi_t13ReadWriteByteEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:479
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
    void Disable() { PSpi->CR1 &= ~SPI_CR1_SPE; }
    void EnableTxDma() { PSpi->CR2 |= SPI_CR2_TXDMAEN; }
    void WaitBsyHi2Lo() { while(PSpi->SR & SPI_SR_BSY); }
    uint8_t ReadWriteByte(uint8_t AByte) {
        PSpi->DR = AByte;
 8001080:	6803      	ldr	r3, [r0, #0]
 8001082:	8199      	strh	r1, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:480 (discriminator 1)
        while(!(PSpi->SR & SPI_SR_RXNE));  // Wait for SPI transmission to complete
 8001084:	891a      	ldrh	r2, [r3, #8]
 8001086:	07d2      	lsls	r2, r2, #31
 8001088:	d5fc      	bpl.n	8001084 <Spi_t::ReadWriteByte(unsigned char)+0x4>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:481
        return PSpi->DR;
 800108a:	8998      	ldrh	r0, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:482
    }
 800108c:	b2c0      	uxtb	r0, r0
 800108e:	4770      	bx	lr

08001090 <cc1101_t::RSSI_dBm(unsigned char)>:
_ZN8cc1101_t8RSSI_dBmEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:105
}

// Return RSSI in dBm
int8_t cc1101_t::RSSI_dBm(uint8_t ARawRSSI) {
    int16_t RSSI = ARawRSSI;
    if (RSSI >= 128) RSSI -= 256;
 8001090:	297f      	cmp	r1, #127	; 0x7f
 8001092:	bfc4      	itt	gt
 8001094:	f5a1 7180 	subgt.w	r1, r1, #256	; 0x100
 8001098:	b289      	uxthgt	r1, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:106
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
 800109a:	b208      	sxth	r0, r1
 800109c:	2302      	movs	r3, #2
 800109e:	fb90 f0f3 	sdiv	r0, r0, r3
 80010a2:	384a      	subs	r0, #74	; 0x4a
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:108
    return RSSI;
}
 80010a4:	b240      	sxtb	r0, r0
 80010a6:	4770      	bx	lr
	...

080010b0 <cc1101_t::ReadRegister(unsigned char)>:
_ZN8cc1101_t12ReadRegisterEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:137
     }
     else return FAILURE;
}

// =========================== Registers & Strobes =============================
uint8_t cc1101_t::ReadRegister (uint8_t ARegAddr){
 80010b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80010b2:	4c09      	ldr	r4, [pc, #36]	; (80010d8 <cc1101_t::ReadRegister(unsigned char)+0x28>)
_ZN8cc1101_t12ReadRegisterEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:137
 80010b4:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
 80010b6:	2510      	movs	r5, #16
_ZN8cc1101_t12ReadRegisterEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:137
 80010b8:	460f      	mov	r7, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:140
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
 80010ba:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
 80010bc:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t12ReadRegisterEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:139
}

// =========================== Registers & Strobes =============================
uint8_t cc1101_t::ReadRegister (uint8_t ARegAddr){
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 80010be:	f7ff ffd7 	bl	8001070 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:140
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
 80010c2:	f047 0180 	orr.w	r1, r7, #128	; 0x80
 80010c6:	4630      	mov	r0, r6
 80010c8:	f7ff ffda 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:141
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
 80010cc:	4630      	mov	r0, r6
 80010ce:	2100      	movs	r1, #0
 80010d0:	f7ff ffd6 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 80010d4:	8325      	strh	r5, [r4, #24]
_ZN8cc1101_t12ReadRegisterEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:144
    CsHi();                                 // End transmission
    return FReply;
}
 80010d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80010d8:	40020000 	.word	0x40020000
$d():
 80010dc:	00000000 	.word	0x00000000

080010e0 <cc1101_t::ReadFIFO(rPkt_t*)>:
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:111
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
    return RSSI;
}


uint8_t cc1101_t::ReadFIFO(rPkt_t *pPkt) {
 80010e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80010e4:	460d      	mov	r5, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:114
    uint8_t b, *p = (uint8_t*)pPkt;
     // Check if received successfully
     b = ReadRegister(CC_PKTSTATUS);
 80010e6:	2178      	movs	r1, #120	; 0x78
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:111
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
    return RSSI;
}


uint8_t cc1101_t::ReadFIFO(rPkt_t *pPkt) {
 80010e8:	4606      	mov	r6, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:114
    uint8_t b, *p = (uint8_t*)pPkt;
     // Check if received successfully
     b = ReadRegister(CC_PKTSTATUS);
 80010ea:	f7ff ffe1 	bl	80010b0 <cc1101_t::ReadRegister(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:116
     //    Uart.Printf("St: %X  ", b);
     if(b & 0x80) {  // CRC OK
 80010ee:	0603      	lsls	r3, r0, #24
 80010f0:	d524      	bpl.n	800113c <cc1101_t::ReadFIFO(rPkt_t*)+0x5c>
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80010f2:	4f14      	ldr	r7, [pc, #80]	; (8001144 <cc1101_t::ReadFIFO(rPkt_t*)+0x64>)
 80010f4:	f04f 0810 	mov.w	r8, #16
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:120
         // Read FIFO
         CsLo();                                            // Start transmission
         BusyWait();                                        // Wait for chip to become ready
         ISpi.ReadWriteByte(CC_FIFO|CC_READ_FLAG|CC_BURST_FLAG); // Address with read & burst flags
 80010f8:	f106 0408 	add.w	r4, r6, #8
_ZN8cc1101_t4CsLoEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
 80010fc:	f8a7 801a 	strh.w	r8, [r7, #26]
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:119
     b = ReadRegister(CC_PKTSTATUS);
     //    Uart.Printf("St: %X  ", b);
     if(b & 0x80) {  // CRC OK
         // Read FIFO
         CsLo();                                            // Start transmission
         BusyWait();                                        // Wait for chip to become ready
 8001100:	f7ff ffb6 	bl	8001070 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:120
         ISpi.ReadWriteByte(CC_FIFO|CC_READ_FLAG|CC_BURST_FLAG); // Address with read & burst flags
 8001104:	4620      	mov	r0, r4
 8001106:	21ff      	movs	r1, #255	; 0xff
 8001108:	f7ff ffba 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:122
         for(uint8_t i=0; i<RPKT_LEN; i++) {                // Read bytes
             b = ISpi.ReadWriteByte(0);
 800110c:	4620      	mov	r0, r4
 800110e:	2100      	movs	r1, #0
 8001110:	f7ff ffb6 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:127
             *p++ = b;
             // Uart.Printf(" %X", b);
         }
         // Receive two additional info bytes
         b = ISpi.ReadWriteByte(0); // RSSI
 8001114:	2100      	movs	r1, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:123
         CsLo();                                            // Start transmission
         BusyWait();                                        // Wait for chip to become ready
         ISpi.ReadWriteByte(CC_FIFO|CC_READ_FLAG|CC_BURST_FLAG); // Address with read & burst flags
         for(uint8_t i=0; i<RPKT_LEN; i++) {                // Read bytes
             b = ISpi.ReadWriteByte(0);
             *p++ = b;
 8001116:	7028      	strb	r0, [r5, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:127
             // Uart.Printf(" %X", b);
         }
         // Receive two additional info bytes
         b = ISpi.ReadWriteByte(0); // RSSI
 8001118:	4620      	mov	r0, r4
 800111a:	f7ff ffb1 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:128
         ISpi.ReadWriteByte(0);     // LQI
 800111e:	2100      	movs	r1, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:127
             b = ISpi.ReadWriteByte(0);
             *p++ = b;
             // Uart.Printf(" %X", b);
         }
         // Receive two additional info bytes
         b = ISpi.ReadWriteByte(0); // RSSI
 8001120:	4681      	mov	r9, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:128
         ISpi.ReadWriteByte(0);     // LQI
 8001122:	4620      	mov	r0, r4
 8001124:	f7ff ffac 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001128:	f8a7 8018 	strh.w	r8, [r7, #24]
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:130
         CsHi();                    // End transmission
         pPkt->RSSI = RSSI_dBm(b);
 800112c:	4630      	mov	r0, r6
 800112e:	4649      	mov	r1, r9
 8001130:	f7ff ffae 	bl	8001090 <cc1101_t::RSSI_dBm(unsigned char)>
 8001134:	7068      	strb	r0, [r5, #1]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:131
         return OK;
 8001136:	2000      	movs	r0, #0
 8001138:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:133
     }
     else return FAILURE;
 800113c:	2001      	movs	r0, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:134
}
 800113e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001142:	bf00      	nop
 8001144:	40020000 	.word	0x40020000
	...

08001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>:
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:145
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister (uint8_t ARegAddr, uint8_t AData){
 8001150:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001154:	4c09      	ldr	r4, [pc, #36]	; (800117c <cc1101_t::WriteRegister(unsigned char, unsigned char)+0x2c>)
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:145
 8001156:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
 8001158:	2510      	movs	r5, #16
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:145
 800115a:	4688      	mov	r8, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:148
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 800115c:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
 800115e:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:145
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister (uint8_t ARegAddr, uint8_t AData){
 8001160:	4617      	mov	r7, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:147
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
 8001162:	f7ff ff85 	bl	8001070 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:148
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 8001166:	4641      	mov	r1, r8
 8001168:	4630      	mov	r0, r6
 800116a:	f7ff ff89 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:149
    ISpi.ReadWriteByte(AData);      // Write data
 800116e:	4630      	mov	r0, r6
 8001170:	4639      	mov	r1, r7
 8001172:	f7ff ff85 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001176:	8325      	strh	r5, [r4, #24]
 8001178:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800117c:	40020000 	.word	0x40020000

08001180 <cc1101_t::WriteStrobe(unsigned char)>:
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:152
    CsHi();                         // End transmission
}
void cc1101_t::WriteStrobe (uint8_t AStrobe){
 8001180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001182:	4d09      	ldr	r5, [pc, #36]	; (80011a8 <cc1101_t::WriteStrobe(unsigned char)+0x28>)
 8001184:	2610      	movs	r6, #16
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:152
 8001186:	4604      	mov	r4, r0
 8001188:	460f      	mov	r7, r1
_ZN8cc1101_t4CsLoEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:176
 800118a:	836e      	strh	r6, [r5, #26]
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:154
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 800118c:	f7ff ff70 	bl	8001070 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:155
    IState = ISpi.ReadWriteByte(AStrobe);   // Write strobe
 8001190:	f104 0008 	add.w	r0, r4, #8
 8001194:	4639      	mov	r1, r7
 8001196:	f7ff ff73 	bl	8001080 <Spi_t::ReadWriteByte(unsigned char)>
 800119a:	7020      	strb	r0, [r4, #0]
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800119c:	832e      	strh	r6, [r5, #24]
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:157
    CsHi();                                 // End transmission
    IState &= 0b01110000;                   // Mask needed bits
 800119e:	7823      	ldrb	r3, [r4, #0]
 80011a0:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80011a4:	7023      	strb	r3, [r4, #0]
 80011a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80011a8:	40020000 	.word	0x40020000
$d():
 80011ac:	00000000 	.word	0x00000000

080011b0 <cc1101_t::EnterIdle()>:
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:65
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 80011b0:	b510      	push	{r4, lr}
 80011b2:	2136      	movs	r1, #54	; 0x36
 80011b4:	4604      	mov	r4, r0
 80011b6:	f7ff ffe3 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
 80011ba:	2300      	movs	r3, #0
 80011bc:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80011c0:	bd10      	pop	{r4, pc}
	...

080011d0 <cc1101_t::SetChannel(unsigned char)>:
_ZN8cc1101_t10SetChannelEh():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:40
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIrq(IRQ_PRIO_MEDIUM);
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
 80011d0:	b538      	push	{r3, r4, r5, lr}
 80011d2:	4604      	mov	r4, r0
 80011d4:	460d      	mov	r5, r1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:41 (discriminator 1)
    while(IState != CC_STB_IDLE) EnterIdle();   // CC must be in IDLE mode
 80011d6:	7823      	ldrb	r3, [r4, #0]
 80011d8:	4620      	mov	r0, r4
 80011da:	b113      	cbz	r3, 80011e2 <cc1101_t::SetChannel(unsigned char)+0x12>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:41 (discriminator 2)
 80011dc:	f7ff ffe8 	bl	80011b0 <cc1101_t::EnterIdle()>
 80011e0:	e7f9      	b.n	80011d6 <cc1101_t::SetChannel(unsigned char)+0x6>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:42
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 80011e2:	462a      	mov	r2, r5
 80011e4:	210a      	movs	r1, #10
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:43
}
 80011e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:42
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
    while(IState != CC_STB_IDLE) EnterIdle();   // CC must be in IDLE mode
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 80011ea:	f7ff bfb1 	b.w	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

080011f0 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)>:
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:79
}

/*
 * Enter RX mode and wait reception for Timeout_ms.
 */
uint8_t cc1101_t::ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt) {
 80011f0:	b570      	push	{r4, r5, r6, lr}
 80011f2:	460d      	mov	r5, r1
_ZN8cc1101_t11FlushRxFIFOEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:54
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 80011f4:	213a      	movs	r1, #58	; 0x3a
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:79
 80011f6:	4604      	mov	r4, r0
 80011f8:	4616      	mov	r6, r2
_ZN8cc1101_t11FlushRxFIFOEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:54
 80011fa:	f7ff ffc1 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:81
    FlushRxFIFO();
    chSysLock();
 80011fe:	2320      	movs	r3, #32
 8001200:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:82
    PWaitingThread = chThdSelf();
 8001204:	4b10      	ldr	r3, [pc, #64]	; (8001248 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)+0x58>)
_ZN8cc1101_t7EnterRXEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:53
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
 8001206:	2134      	movs	r1, #52	; 0x34
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:82
 8001208:	6998      	ldr	r0, [r3, #24]
 800120a:	6060      	str	r0, [r4, #4]
_ZN8cc1101_t7EnterRXEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:53
 800120c:	4620      	mov	r0, r4
 800120e:	f7ff ffb7 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:84
    EnterRX();      // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
 8001212:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001216:	435d      	muls	r5, r3
 8001218:	f5a5 757a 	sub.w	r5, r5, #1000	; 0x3e8
 800121c:	fbb5 f1f3 	udiv	r1, r5, r3
 8001220:	3101      	adds	r1, #1
 8001222:	2002      	movs	r0, #2
 8001224:	f7ff f88c 	bl	8000340 <chSchGoSleepTimeoutS>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:85
    chSysUnlock();  // Will be here when IRQ will fire, or timeout occur - with appropriate message
 8001228:	2300      	movs	r3, #0
 800122a:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:87

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
 800122e:	3001      	adds	r0, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:88
        EnterIdle();            // Get out of RX mode
 8001230:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:87
    PWaitingThread = chThdSelf();
    EnterRX();      // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
    chSysUnlock();  // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
 8001232:	d004      	beq.n	800123e <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)+0x4e>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:92
        EnterIdle();            // Get out of RX mode
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
 8001234:	4631      	mov	r1, r6
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:93
}
 8001236:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:92
    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
        EnterIdle();            // Get out of RX mode
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
 800123a:	f7ff bf51 	b.w	80010e0 <cc1101_t::ReadFIFO(rPkt_t*)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:88
    EnterRX();      // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
    chSysUnlock();  // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
        EnterIdle();            // Get out of RX mode
 800123e:	f7ff ffb7 	bl	80011b0 <cc1101_t::EnterIdle()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:93
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
}
 8001242:	2002      	movs	r0, #2
 8001244:	bd70      	pop	{r4, r5, r6, pc}
 8001246:	bf00      	nop
 8001248:	20000f70 	.word	0x20000f70
$d():
 800124c:	00000000 	.word	0x00000000

08001250 <cc1101_t::RfConfig()>:
_ZN8cc1101_t8RfConfigEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:176
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 8001250:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:177
    WriteRegister(CC_FSCTRL1,  CC_FSCTRL1_VALUE);    // Frequency synthesizer control.
 8001252:	210b      	movs	r1, #11
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:176
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 8001254:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:177
    WriteRegister(CC_FSCTRL1,  CC_FSCTRL1_VALUE);    // Frequency synthesizer control.
 8001256:	220c      	movs	r2, #12
 8001258:	f7ff ff7a 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:178
    WriteRegister(CC_FSCTRL0,  CC_FSCTRL0_VALUE);    // Frequency synthesizer control.
 800125c:	4620      	mov	r0, r4
 800125e:	210c      	movs	r1, #12
 8001260:	2200      	movs	r2, #0
 8001262:	f7ff ff75 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:179
    WriteRegister(CC_FREQ2,    CC_FREQ2_VALUE);      // Frequency control word, high byte.
 8001266:	4620      	mov	r0, r4
 8001268:	210d      	movs	r1, #13
 800126a:	2220      	movs	r2, #32
 800126c:	f7ff ff70 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:180
    WriteRegister(CC_FREQ1,    CC_FREQ1_VALUE);      // Frequency control word, middle byte.
 8001270:	4620      	mov	r0, r4
 8001272:	210e      	movs	r1, #14
 8001274:	2225      	movs	r2, #37	; 0x25
 8001276:	f7ff ff6b 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:181
    WriteRegister(CC_FREQ0,    CC_FREQ0_VALUE);      // Frequency control word, low byte.
 800127a:	4620      	mov	r0, r4
 800127c:	210f      	movs	r1, #15
 800127e:	22ed      	movs	r2, #237	; 0xed
 8001280:	f7ff ff66 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:182
    WriteRegister(CC_MDMCFG4,  CC_MDMCFG4_VALUE);    // Modem configuration.
 8001284:	4620      	mov	r0, r4
 8001286:	2110      	movs	r1, #16
 8001288:	222d      	movs	r2, #45	; 0x2d
 800128a:	f7ff ff61 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:183
    WriteRegister(CC_MDMCFG3,  CC_MDMCFG3_VALUE);    // Modem configuration.
 800128e:	4620      	mov	r0, r4
 8001290:	2111      	movs	r1, #17
 8001292:	222f      	movs	r2, #47	; 0x2f
 8001294:	f7ff ff5c 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:184
    WriteRegister(CC_MDMCFG2,  CC_MDMCFG2_VALUE);    // Modem configuration.
 8001298:	4620      	mov	r0, r4
 800129a:	2112      	movs	r1, #18
 800129c:	2213      	movs	r2, #19
 800129e:	f7ff ff57 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:185
    WriteRegister(CC_MDMCFG1,  CC_MDMCFG1_VALUE);    // Modem configuration.
 80012a2:	4620      	mov	r0, r4
 80012a4:	2113      	movs	r1, #19
 80012a6:	2222      	movs	r2, #34	; 0x22
 80012a8:	f7ff ff52 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:186
    WriteRegister(CC_MDMCFG0,  CC_MDMCFG0_VALUE);    // Modem configuration.
 80012ac:	4620      	mov	r0, r4
 80012ae:	2114      	movs	r1, #20
 80012b0:	22e5      	movs	r2, #229	; 0xe5
 80012b2:	f7ff ff4d 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:187
    WriteRegister(CC_CHANNR,   CC_CHANNR_VALUE);     // Channel number.
 80012b6:	4620      	mov	r0, r4
 80012b8:	210a      	movs	r1, #10
 80012ba:	2200      	movs	r2, #0
 80012bc:	f7ff ff48 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:188
    WriteRegister(CC_DEVIATN,  CC_DEVIATN_VALUE);    // Modem deviation setting (when FSK modulation is enabled).
 80012c0:	4620      	mov	r0, r4
 80012c2:	2115      	movs	r1, #21
 80012c4:	2262      	movs	r2, #98	; 0x62
 80012c6:	f7ff ff43 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:189
    WriteRegister(CC_FREND1,   CC_FREND1_VALUE);     // Front end RX configuration.
 80012ca:	4620      	mov	r0, r4
 80012cc:	2121      	movs	r1, #33	; 0x21
 80012ce:	22b6      	movs	r2, #182	; 0xb6
 80012d0:	f7ff ff3e 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:190
    WriteRegister(CC_FREND0,   CC_FREND0_VALUE);     // Front end RX configuration.
 80012d4:	4620      	mov	r0, r4
 80012d6:	2122      	movs	r1, #34	; 0x22
 80012d8:	2210      	movs	r2, #16
 80012da:	f7ff ff39 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:191
    WriteRegister(CC_MCSM0,    CC_MCSM0_VALUE);      // Main Radio Control State Machine configuration.
 80012de:	4620      	mov	r0, r4
 80012e0:	2118      	movs	r1, #24
 80012e2:	2208      	movs	r2, #8
 80012e4:	f7ff ff34 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:192
    WriteRegister(CC_FOCCFG,   CC_FOCCFG_VALUE);     // Frequency Offset Compensation Configuration.
 80012e8:	4620      	mov	r0, r4
 80012ea:	2119      	movs	r1, #25
 80012ec:	221d      	movs	r2, #29
 80012ee:	f7ff ff2f 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:193
    WriteRegister(CC_BSCFG,    CC_BSCFG_VALUE);      // Bit synchronization Configuration.
 80012f2:	4620      	mov	r0, r4
 80012f4:	211a      	movs	r1, #26
 80012f6:	221c      	movs	r2, #28
 80012f8:	f7ff ff2a 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:194
    WriteRegister(CC_AGCCTRL2, CC_AGCCTRL2_VALUE);   // AGC control.
 80012fc:	4620      	mov	r0, r4
 80012fe:	211b      	movs	r1, #27
 8001300:	22c7      	movs	r2, #199	; 0xc7
 8001302:	f7ff ff25 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:195
    WriteRegister(CC_AGCCTRL1, CC_AGCCTRL1_VALUE);   // AGC control.
 8001306:	4620      	mov	r0, r4
 8001308:	211c      	movs	r1, #28
 800130a:	2200      	movs	r2, #0
 800130c:	f7ff ff20 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:196
    WriteRegister(CC_AGCCTRL0, CC_AGCCTRL0_VALUE);   // AGC control.
 8001310:	4620      	mov	r0, r4
 8001312:	211d      	movs	r1, #29
 8001314:	22b0      	movs	r2, #176	; 0xb0
 8001316:	f7ff ff1b 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:197
    WriteRegister(CC_FSCAL3,   CC_FSCAL3_VALUE);     // Frequency synthesizer calibration.
 800131a:	4620      	mov	r0, r4
 800131c:	2123      	movs	r1, #35	; 0x23
 800131e:	22ea      	movs	r2, #234	; 0xea
 8001320:	f7ff ff16 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:198
    WriteRegister(CC_FSCAL2,   CC_FSCAL2_VALUE);     // Frequency synthesizer calibration.
 8001324:	4620      	mov	r0, r4
 8001326:	2124      	movs	r1, #36	; 0x24
 8001328:	222a      	movs	r2, #42	; 0x2a
 800132a:	f7ff ff11 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:199
    WriteRegister(CC_FSCAL1,   CC_FSCAL1_VALUE);     // Frequency synthesizer calibration.
 800132e:	4620      	mov	r0, r4
 8001330:	2125      	movs	r1, #37	; 0x25
 8001332:	2200      	movs	r2, #0
 8001334:	f7ff ff0c 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:200
    WriteRegister(CC_FSCAL0,   CC_FSCAL0_VALUE);     // Frequency synthesizer calibration.
 8001338:	4620      	mov	r0, r4
 800133a:	2126      	movs	r1, #38	; 0x26
 800133c:	221f      	movs	r2, #31
 800133e:	f7ff ff07 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:201
    WriteRegister(CC_TEST2,    CC_TEST2_VALUE);      // Various test settings.
 8001342:	4620      	mov	r0, r4
 8001344:	212c      	movs	r1, #44	; 0x2c
 8001346:	2288      	movs	r2, #136	; 0x88
 8001348:	f7ff ff02 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:202
    WriteRegister(CC_TEST1,    CC_TEST1_VALUE);      // Various test settings.
 800134c:	4620      	mov	r0, r4
 800134e:	212d      	movs	r1, #45	; 0x2d
 8001350:	2231      	movs	r2, #49	; 0x31
 8001352:	f7ff fefd 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:203
    WriteRegister(CC_TEST0,    CC_TEST0_VALUE);      // Various test settings.
 8001356:	4620      	mov	r0, r4
 8001358:	212e      	movs	r1, #46	; 0x2e
 800135a:	2209      	movs	r2, #9
 800135c:	f7ff fef8 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:204
    WriteRegister(CC_FIFOTHR,  CC_FIFOTHR_VALUE);    // fifo threshold
 8001360:	4620      	mov	r0, r4
 8001362:	2103      	movs	r1, #3
 8001364:	2207      	movs	r2, #7
 8001366:	f7ff fef3 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:205
    WriteRegister(CC_IOCFG2,   CC_IOCFG2_VALUE);     // GDO2 output pin configuration.
 800136a:	4620      	mov	r0, r4
 800136c:	2100      	movs	r1, #0
 800136e:	2207      	movs	r2, #7
 8001370:	f7ff feee 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:206
    WriteRegister(CC_IOCFG0,   CC_IOCFG0_VALUE);     // GDO0 output pin configuration.
 8001374:	4620      	mov	r0, r4
 8001376:	2102      	movs	r1, #2
 8001378:	2206      	movs	r2, #6
 800137a:	f7ff fee9 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:207
    WriteRegister(CC_PKTCTRL1, CC_PKTCTRL1_VALUE);   // Packet automation control.
 800137e:	4620      	mov	r0, r4
 8001380:	2107      	movs	r1, #7
 8001382:	220c      	movs	r2, #12
 8001384:	f7ff fee4 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:208
    WriteRegister(CC_PKTCTRL0, CC_PKTCTRL0_VALUE);   // Packet automation control.
 8001388:	4620      	mov	r0, r4
 800138a:	2108      	movs	r1, #8
 800138c:	2244      	movs	r2, #68	; 0x44
 800138e:	f7ff fedf 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:209
    WriteRegister(CC_PKTLEN,   RPKT_LEN);            // Packet length, dummy
 8001392:	4620      	mov	r0, r4
 8001394:	2106      	movs	r1, #6
 8001396:	2201      	movs	r2, #1
 8001398:	f7ff feda 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:211

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);
 800139c:	4620      	mov	r0, r4
 800139e:	213e      	movs	r1, #62	; 0x3e
 80013a0:	2250      	movs	r2, #80	; 0x50
 80013a2:	f7ff fed5 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:213

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
 80013a6:	4620      	mov	r0, r4
 80013a8:	2116      	movs	r1, #22
 80013aa:	2207      	movs	r2, #7
 80013ac:	f7ff fed0 	bl	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:214
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 80013b0:	4620      	mov	r0, r4
 80013b2:	2117      	movs	r1, #23
 80013b4:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:215
}
 80013b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:214
    WriteRegister(CC_PKTLEN,   RPKT_LEN);            // Packet length, dummy

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 80013ba:	f7ff bec9 	b.w	8001150 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

080013c0 <cc1101_t::Init()>:
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:13
#include "cc1101.h"
#include "ch.h"

cc1101_t CC;

void cc1101_t::Init() {
 80013c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80013c2:	4d8e      	ldr	r5, [pc, #568]	; (80015fc <cc1101_t::Init()+0x23c>)
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80013c4:	4c8e      	ldr	r4, [pc, #568]	; (8001600 <cc1101_t::Init()+0x240>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80013c6:	69eb      	ldr	r3, [r5, #28]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:471
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
        PSpi->CR2 = 0;
 80013c8:	2700      	movs	r7, #0
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80013ca:	f043 0301 	orr.w	r3, r3, #1
 80013ce:	61eb      	str	r3, [r5, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80013d0:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:13
 80013d2:	4606      	mov	r6, r0
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:198
 80013d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80013d8:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:199
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 80013da:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t6CResetEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:49
    void WriteRegister (const uint8_t Addr, const uint8_t AData);
    uint8_t ReadRegister (const uint8_t Addr);
    void WriteStrobe(uint8_t AStrobe);
    void WriteTX(uint8_t* Ptr, uint8_t Length);
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
 80013dc:	2130      	movs	r1, #48	; 0x30
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:199
 80013de:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80013e2:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:201
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80013e4:	88a3      	ldrh	r3, [r4, #4]
 80013e6:	f023 0310 	bic.w	r3, r3, #16
 80013ea:	041b      	lsls	r3, r3, #16
 80013ec:	0c1b      	lsrs	r3, r3, #16
 80013ee:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:202
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80013f0:	88a3      	ldrh	r3, [r4, #4]
 80013f2:	b29b      	uxth	r3, r3
 80013f4:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:204
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80013f6:	68e3      	ldr	r3, [r4, #12]
 80013f8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80013fc:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:205
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80013fe:	68e3      	ldr	r3, [r4, #12]
 8001400:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:207
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001402:	68a3      	ldr	r3, [r4, #8]
 8001404:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001408:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:208
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800140a:	68a3      	ldr	r3, [r4, #8]
 800140c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8001410:	60a3      	str	r3, [r4, #8]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001412:	69eb      	ldr	r3, [r5, #28]
 8001414:	f043 0301 	orr.w	r3, r3, #1
 8001418:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800141a:	6823      	ldr	r3, [r4, #0]
 800141c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8001420:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001422:	6823      	ldr	r3, [r4, #0]
 8001424:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001428:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 800142a:	88a3      	ldrh	r3, [r4, #4]
 800142c:	f023 0320 	bic.w	r3, r3, #32
 8001430:	041b      	lsls	r3, r3, #16
 8001432:	0c1b      	lsrs	r3, r3, #16
 8001434:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001436:	88a3      	ldrh	r3, [r4, #4]
 8001438:	b29b      	uxth	r3, r3
 800143a:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 800143c:	68e3      	ldr	r3, [r4, #12]
 800143e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8001442:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001444:	68e3      	ldr	r3, [r4, #12]
 8001446:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001448:	68a3      	ldr	r3, [r4, #8]
 800144a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800144e:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001450:	68a3      	ldr	r3, [r4, #8]
 8001452:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001456:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001458:	6a23      	ldr	r3, [r4, #32]
 800145a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800145e:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001460:	6a23      	ldr	r3, [r4, #32]
 8001462:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 8001466:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001468:	69eb      	ldr	r3, [r5, #28]
 800146a:	f043 0301 	orr.w	r3, r3, #1
 800146e:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001470:	6823      	ldr	r3, [r4, #0]
 8001472:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8001476:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001478:	6823      	ldr	r3, [r4, #0]
 800147a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800147e:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001480:	88a3      	ldrh	r3, [r4, #4]
 8001482:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001486:	041b      	lsls	r3, r3, #16
 8001488:	0c1b      	lsrs	r3, r3, #16
 800148a:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 800148c:	88a3      	ldrh	r3, [r4, #4]
 800148e:	b29b      	uxth	r3, r3
 8001490:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001492:	68e3      	ldr	r3, [r4, #12]
 8001494:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8001498:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800149a:	68e3      	ldr	r3, [r4, #12]
 800149c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 800149e:	68a3      	ldr	r3, [r4, #8]
 80014a0:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80014a4:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80014a6:	68a3      	ldr	r3, [r4, #8]
 80014a8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80014ac:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 80014ae:	6a23      	ldr	r3, [r4, #32]
 80014b0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80014b4:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 80014b6:	6a23      	ldr	r3, [r4, #32]
 80014b8:	f043 63a0 	orr.w	r3, r3, #83886080	; 0x5000000
 80014bc:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80014be:	69eb      	ldr	r3, [r5, #28]
 80014c0:	f043 0301 	orr.w	r3, r3, #1
 80014c4:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80014c6:	6823      	ldr	r3, [r4, #0]
 80014c8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80014cc:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80014ce:	6823      	ldr	r3, [r4, #0]
 80014d0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80014d4:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80014d6:	88a3      	ldrh	r3, [r4, #4]
 80014d8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80014dc:	041b      	lsls	r3, r3, #16
 80014de:	0c1b      	lsrs	r3, r3, #16
 80014e0:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80014e2:	88a3      	ldrh	r3, [r4, #4]
 80014e4:	b29b      	uxth	r3, r3
 80014e6:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80014e8:	68e3      	ldr	r3, [r4, #12]
 80014ea:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80014ee:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80014f0:	68e3      	ldr	r3, [r4, #12]
 80014f2:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80014f4:	68a3      	ldr	r3, [r4, #8]
 80014f6:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80014fa:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80014fc:	68a3      	ldr	r3, [r4, #8]
 80014fe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001502:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001504:	6a23      	ldr	r3, [r4, #32]
 8001506:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800150a:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 800150c:	6a23      	ldr	r3, [r4, #32]
 800150e:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
 8001512:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001514:	69eb      	ldr	r3, [r5, #28]
 8001516:	f043 0301 	orr.w	r3, r3, #1
 800151a:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:219
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 800151c:	6823      	ldr	r3, [r4, #0]
 800151e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8001522:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:221
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001524:	68e3      	ldr	r3, [r4, #12]
 8001526:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800152a:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:222
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 800152c:	68e3      	ldr	r3, [r4, #12]
 800152e:	60e3      	str	r3, [r4, #12]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001530:	69eb      	ldr	r3, [r5, #28]
 8001532:	f043 0301 	orr.w	r3, r3, #1
 8001536:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:219
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001538:	6823      	ldr	r3, [r4, #0]
 800153a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800153e:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:221
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001540:	68e3      	ldr	r3, [r4, #12]
 8001542:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8001546:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:222
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 8001548:	68e3      	ldr	r3, [r4, #12]
 800154a:	60e3      	str	r3, [r4, #12]
PinSet():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800154c:	2310      	movs	r3, #16
 800154e:	8323      	strh	r3, [r4, #24]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:461
private:
    SPI_TypeDef *PSpi;
public:
    void Setup(SPI_TypeDef *Spi, BitOrder_t BitOrder,
            CPOL_t CPOL, CPHA_t CPHA, SpiBaudrate_t Baudrate) {
        PSpi = Spi;
 8001550:	4b2c      	ldr	r3, [pc, #176]	; (8001604 <cc1101_t::Init()+0x244>)
 8001552:	6083      	str	r3, [r0, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:463
        // Clocking
        if      (PSpi == SPI1) { rccEnableSPI1(FALSE); }
 8001554:	6a2a      	ldr	r2, [r5, #32]
 8001556:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800155a:	622a      	str	r2, [r5, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:466
        else if (PSpi == SPI2) { rccEnableSPI2(FALSE); }
        // Mode: Master, NSS software controlled and is 1, 8bit, NoCRC, FullDuplex
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
 800155c:	f44f 7241 	mov.w	r2, #772	; 0x304
 8001560:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:470
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
 8001562:	881a      	ldrh	r2, [r3, #0]
 8001564:	b292      	uxth	r2, r2
 8001566:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:471
        PSpi->CR2 = 0;
 8001568:	809f      	strh	r7, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:472
        PSpi->I2SCFGR &= ~((uint16_t)SPI_I2SCFGR_I2SMOD);       // Disable I2S
 800156a:	8b9a      	ldrh	r2, [r3, #28]
 800156c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001570:	0412      	lsls	r2, r2, #16
 8001572:	0c12      	lsrs	r2, r2, #16
 8001574:	839a      	strh	r2, [r3, #28]
_ZN5Spi_t6EnableEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:474
    }
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
 8001576:	881a      	ldrh	r2, [r3, #0]
 8001578:	b292      	uxth	r2, r2
 800157a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800157e:	801a      	strh	r2, [r3, #0]
_ZN8cc1101_t6CResetEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:49
 8001580:	f7ff fdfe 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11FlushRxFIFOEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.h:54
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 8001584:	4630      	mov	r0, r6
 8001586:	213a      	movs	r1, #58	; 0x3a
 8001588:	f7ff fdfa 	bl	8001180 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:30
    ISpi.Enable();

    // ==== Init CC ====
    CReset();
    FlushRxFIFO();
    RfConfig();
 800158c:	4630      	mov	r0, r6
 800158e:	f7ff fe5f 	bl	8001250 <cc1101_t::RfConfig()>
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:303
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
        IPinNumber = APinNumber;
 8001592:	2303      	movs	r3, #3
 8001594:	7533      	strb	r3, [r6, #20]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:304
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 8001596:	6a2b      	ldr	r3, [r5, #32]
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:31
    PWaitingThread = nullptr;
 8001598:	6077      	str	r7, [r6, #4]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:304
 800159a:	f043 0301 	orr.w	r3, r3, #1
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:32
    State = ccIdle;
 800159e:	f886 7024 	strb.w	r7, [r6, #36]	; 0x24
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:302
                break;
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
 80015a2:	6134      	str	r4, [r6, #16]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:304
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 80015a4:	622b      	str	r3, [r5, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:308
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80015a6:	4b18      	ldr	r3, [pc, #96]	; (8001608 <cc1101_t::Init()+0x248>)
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:284
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 80015a8:	2101      	movs	r1, #1
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:308
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80015aa:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:319
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 80015ac:	2009      	movs	r0, #9
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:308
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80015ae:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 80015b2:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:314
        // GPIOA requires all zeroes => nothing to do in this case
        if     (GPIO == GPIOB) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0001 << Offset;
        else if(GPIO == GPIOC) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0010 << Offset;
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
 80015b4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 80015b8:	f042 0208 	orr.w	r2, r2, #8
 80015bc:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:315
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
 80015c0:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 80015c4:	f022 0208 	bic.w	r2, r2, #8
 80015c8:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:284
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 80015cc:	7d32      	ldrb	r2, [r6, #20]
 80015ce:	fa01 f202 	lsl.w	r2, r1, r2
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:291
            case ttRising:
                EXTI->RTSR |=  IrqMsk;  // Rising trigger enabled
                EXTI->FTSR &= ~IrqMsk;  // Falling trigger disabled
                break;
            case ttFalling:
                EXTI->RTSR &= ~IrqMsk;  // Rising trigger disabled
 80015d2:	f8d3 1408 	ldr.w	r1, [r3, #1032]	; 0x408
 80015d6:	ea21 0102 	bic.w	r1, r1, r2
 80015da:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:292
                EXTI->FTSR |=  IrqMsk;  // Falling trigger enabled
 80015de:	f8d3 140c 	ldr.w	r1, [r3, #1036]	; 0x40c
 80015e2:	430a      	orrs	r2, r1
 80015e4:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:317
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
 80015e8:	2208      	movs	r2, #8
 80015ea:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
_ZN8PinIrq_t9EnableIrqEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:323
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIrq(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 80015ee:	2190      	movs	r1, #144	; 0x90
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:319
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 80015f0:	60f0      	str	r0, [r6, #12]
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:37

    // ==== IRQ ====
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIrq(IRQ_PRIO_MEDIUM);
}
 80015f2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
_ZN8PinIrq_t9EnableIrqEm():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:323
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIrq(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 80015f6:	f7ff b9c3 	b.w	8000980 <nvicEnableVector>
 80015fa:	bf00      	nop
 80015fc:	40023800 	.word	0x40023800
 8001600:	40020000 	.word	0x40020000
 8001604:	40013000 	.word	0x40013000
 8001608:	40010000 	.word	0x40010000
$d():
 800160c:	00000000 	.word	0x00000000

08001610 <cc1101_t::IHandleAsync()>:
_ZN8cc1101_t12IHandleAsyncEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:223
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcTx);  // FIXME
    }
    else if(State == ccReceiving) {
 8001610:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8001614:	3b02      	subs	r3, #2
 8001616:	b2db      	uxtb	r3, r3
 8001618:	2b01      	cmp	r3, #1
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:220
}

// ============================= Interrupts ====================================
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
 800161a:	bf9c      	itt	ls
 800161c:	2300      	movls	r3, #0
 800161e:	f880 3024 	strbls.w	r3, [r0, #36]	; 0x24
 8001622:	4770      	bx	lr
	...

08001630 <cc1101_t::IGdo0IrqHandler()>:
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:229
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcRx);  // FIXME
    }
}

void cc1101_t::IGdo0IrqHandler() {
 8001630:	b510      	push	{r4, lr}
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:325
    void DisableIrq() { nvicDisableVector(IIrqChnl); }
    void CleanIrqFlag() { EXTI->PR = (1 << IPinNumber); }
 8001632:	7d03      	ldrb	r3, [r0, #20]
 8001634:	2201      	movs	r2, #1
 8001636:	409a      	lsls	r2, r3
 8001638:	4b0c      	ldr	r3, [pc, #48]	; (800166c <cc1101_t::IGdo0IrqHandler()+0x3c>)
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:229
 800163a:	4604      	mov	r4, r0
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../kl_lib/kl_lib_L15x.h:325
 800163c:	615a      	str	r2, [r3, #20]
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:232
    IGdo0.CleanIrqFlag();
    // Resume thread if any
    chSysLockFromIsr();
 800163e:	2320      	movs	r3, #32
 8001640:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:233
    if(PWaitingThread != NULL) {
 8001644:	6843      	ldr	r3, [r0, #4]
 8001646:	b153      	cbz	r3, 800165e <cc1101_t::IGdo0IrqHandler()+0x2e>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:234
        if(PWaitingThread->p_state == THD_STATE_SUSPENDED) {
 8001648:	7f1a      	ldrb	r2, [r3, #28]
 800164a:	2a02      	cmp	r2, #2
 800164c:	d104      	bne.n	8001658 <cc1101_t::IGdo0IrqHandler()+0x28>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:235
            PWaitingThread->p_u.rdymsg = RDY_OK;    // Signal that IRQ fired
 800164e:	2200      	movs	r2, #0
 8001650:	621a      	str	r2, [r3, #32]
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:236
            chSchReadyI(PWaitingThread);
 8001652:	6840      	ldr	r0, [r0, #4]
 8001654:	f7fe fe24 	bl	80002a0 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:238 (discriminator 1)
        }
        PWaitingThread = NULL;
 8001658:	2300      	movs	r3, #0
 800165a:	6063      	str	r3, [r4, #4]
 800165c:	e001      	b.n	8001662 <cc1101_t::IGdo0IrqHandler()+0x32>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:240
    }
    else IHandleAsync(); // Async task completed
 800165e:	f7ff ffd7 	bl	8001610 <cc1101_t::IHandleAsync()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:241
    chSysUnlockFromIsr();
 8001662:	2300      	movs	r3, #0
 8001664:	f383 8811 	msr	BASEPRI, r3
 8001668:	bd10      	pop	{r4, pc}
 800166a:	bf00      	nop
 800166c:	40010400 	.word	0x40010400

08001670 <Vector64>:
Vector64():
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:245
}

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
 8001670:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:247
    CH_IRQ_PROLOGUE();
    CC.IGdo0IrqHandler();
 8001672:	4803      	ldr	r0, [pc, #12]	; (8001680 <Vector64+0x10>)
 8001674:	f7ff ffdc 	bl	8001630 <cc1101_t::IGdo0IrqHandler()>
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:249
    CH_IRQ_EPILOGUE();
}
 8001678:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\ccrx\Debug/../Radio/cc1101.cpp:248

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
    CH_IRQ_PROLOGUE();
    CC.IGdo0IrqHandler();
    CH_IRQ_EPILOGUE();
 800167c:	f7ff b870 	b.w	8000760 <_port_irq_epilogue>
 8001680:	20000f44 	.word	0x20000f44
	...

08001690 <memset>:
memset():
 8001690:	b4f0      	push	{r4, r5, r6, r7}
 8001692:	0784      	lsls	r4, r0, #30
 8001694:	d043      	beq.n	800171e <memset+0x8e>
 8001696:	1e54      	subs	r4, r2, #1
 8001698:	2a00      	cmp	r2, #0
 800169a:	d03e      	beq.n	800171a <memset+0x8a>
 800169c:	b2cd      	uxtb	r5, r1
 800169e:	4603      	mov	r3, r0
 80016a0:	e003      	b.n	80016aa <memset+0x1a>
 80016a2:	1e62      	subs	r2, r4, #1
 80016a4:	2c00      	cmp	r4, #0
 80016a6:	d038      	beq.n	800171a <memset+0x8a>
 80016a8:	4614      	mov	r4, r2
 80016aa:	f803 5b01 	strb.w	r5, [r3], #1
 80016ae:	079a      	lsls	r2, r3, #30
 80016b0:	d1f7      	bne.n	80016a2 <memset+0x12>
 80016b2:	2c03      	cmp	r4, #3
 80016b4:	d92a      	bls.n	800170c <memset+0x7c>
 80016b6:	b2cd      	uxtb	r5, r1
 80016b8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80016bc:	2c0f      	cmp	r4, #15
 80016be:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80016c2:	d915      	bls.n	80016f0 <memset+0x60>
 80016c4:	f1a4 0710 	sub.w	r7, r4, #16
 80016c8:	093f      	lsrs	r7, r7, #4
 80016ca:	f103 0610 	add.w	r6, r3, #16
 80016ce:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80016d2:	461a      	mov	r2, r3
 80016d4:	6015      	str	r5, [r2, #0]
 80016d6:	6055      	str	r5, [r2, #4]
 80016d8:	6095      	str	r5, [r2, #8]
 80016da:	60d5      	str	r5, [r2, #12]
 80016dc:	3210      	adds	r2, #16
 80016de:	42b2      	cmp	r2, r6
 80016e0:	d1f8      	bne.n	80016d4 <memset+0x44>
 80016e2:	f004 040f 	and.w	r4, r4, #15
 80016e6:	3701      	adds	r7, #1
 80016e8:	2c03      	cmp	r4, #3
 80016ea:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80016ee:	d90d      	bls.n	800170c <memset+0x7c>
 80016f0:	461e      	mov	r6, r3
 80016f2:	4622      	mov	r2, r4
 80016f4:	3a04      	subs	r2, #4
 80016f6:	2a03      	cmp	r2, #3
 80016f8:	f846 5b04 	str.w	r5, [r6], #4
 80016fc:	d8fa      	bhi.n	80016f4 <memset+0x64>
 80016fe:	1f22      	subs	r2, r4, #4
 8001700:	f022 0203 	bic.w	r2, r2, #3
 8001704:	3204      	adds	r2, #4
 8001706:	4413      	add	r3, r2
 8001708:	f004 0403 	and.w	r4, r4, #3
 800170c:	b12c      	cbz	r4, 800171a <memset+0x8a>
 800170e:	b2c9      	uxtb	r1, r1
 8001710:	441c      	add	r4, r3
 8001712:	f803 1b01 	strb.w	r1, [r3], #1
 8001716:	42a3      	cmp	r3, r4
 8001718:	d1fb      	bne.n	8001712 <memset+0x82>
 800171a:	bcf0      	pop	{r4, r5, r6, r7}
 800171c:	4770      	bx	lr
 800171e:	4614      	mov	r4, r2
 8001720:	4603      	mov	r3, r0
 8001722:	e7c6      	b.n	80016b2 <memset+0x22>
	...
$d():
 8001730:	08060403 	.word	0x08060403
 8001734:	2018100c 	.word	0x2018100c
 8001738:	00000030 	.word	0x00000030
 800173c:	00000000 	.word	0x00000000
 8001740:	03020100 	.word	0x03020100
 8001744:	08070604 	.word	0x08070604
 8001748:	00000009 	.word	0x00000009
 800174c:	03020100 	.word	0x03020100
 8001750:	00000004 	.word	0x00000004
	...

08001760 <ch_debug>:
 8001760:	6e69616d 11801600 08280404 1814100c     main......(.....
 8001770:	001d1c00 0000001e 00000000 00000000     ................
 8001780:	63536863 61655268 28497964 23202c29     chSchReadyI(), #
 8001790:	00000031 00000000 00000000 00000000     1...............
 80017a0:	656c6469 00000000 00000000 00000000     idle............
 80017b0:	54686322 72436468 65746165 29282249     "chThdCreateI"()
 80017c0:	68632200 53646854 72507465 69726f69     ."chThdSetPriori
 80017d0:	28227974 68630029 52646854 6d757365     ty"().chThdResum
 80017e0:	2c292865 00312320 54686322 6c536468     e(), #1."chThdSl
 80017f0:	22706565 63002928 64685468 74697845     eep"().chThdExit
 8001800:	2c292853 00312320 00000000 00000000     S(), #1.........
 8001810:	56686322 74655354 29282249 68632200     "chVTSetI"()."ch
 8001820:	65525456 49746573 00292822 54566863     VTResetI"().chVT
 8001830:	65736552 29284974 3123202c 00000000     ResetI(), #1....
 8001840:	616d6422 65727453 6c416d61 61636f6c     "dmaStreamAlloca
 8001850:	28226574 64220029 7453616d 6d616572     te"()."dmaStream
 8001860:	656c6552 22657361 64002928 7453616d     Release"().dmaSt
 8001870:	6d616572 656c6552 28657361 23202c29     reamRelease(), #
 8001880:	00000031 00000000 00000000 00000000     1...............

08001890 <_stm32_dma_streams>:
 8001890:	40026008 40026004 000b0000 4002601c     .`.@.`.@.....`.@
 80018a0:	40026004 000c0104 40026030 40026004     .`.@....0`.@.`.@
 80018b0:	000d0208 40026044 40026004 000e030c     ....D`.@.`.@....
 80018c0:	40026058 40026004 000f0410 4002606c     X`.@.`.@....l`.@
 80018d0:	40026004 00100514 40026080 40026004     .`.@.....`.@.`.@
 80018e0:	00110618 00000000 00000000 00000000     ................
 80018f0:	0d004020 20200d00 30202020 20312020      @....     0  1 
 8001900:	20203220 34202033 20352020 20203620      2  3  4  5  6  
 8001910:	38202037 20392020 20204120 43202042     7  8  9  A  B  C
 8001920:	20442020 20204520 250d0046 3a583230       D  E  F..%02X:
 8001930:	20200020 30250020 00205832 00202d2d      .   .%02X .-- .
