
ccTx.elf:     file format elf32-littlearm
ccTx.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080007d1

Program Header:
    LOAD off    0x00008000 vaddr 0x08000000 paddr 0x08000000 align 2**15
         filesz 0x00001500 memsz 0x00001500 flags rwx
    LOAD off    0x00010800 vaddr 0x20000800 paddr 0x08001500 align 2**15
         filesz 0x00000000 memsz 0x00000830 flags rw-
    LOAD off    0x00010000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000800 flags rw-
private flags = 5000002: [Version5 EABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 startup       000000f4  08000000  08000000  00008000  2**4  CONTENTS, ALLOC, LOAD, DATA
  1 constructors  00000004  080000f4  080000f4  000080f4  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .text         00001400  08000100  08000100  00008100  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .stacks       00000800  20000000  20000000  00010000  2**0  ALLOC
  4 .bss          00000830  20000800  08001500  00010800  2**3  ALLOC
  5 .debug_info   0000dd26  00000000  00000000  00009500  2**0  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002c07  00000000  00000000  00017226  2**0  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000034ee  00000000  00000000  00019e2d  2**0  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000005d0  00000000  00000000  0001d31b  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000b28  00000000  00000000  0001d8eb  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000027fb  00000000  00000000  0001e413  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000321b  00000000  00000000  00020c0e  2**0  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000070  00000000  00000000  00023e29  2**0  CONTENTS, READONLY
 13 .ARM.attributes 00000033  00000000  00000000  00023e99  2**0  CONTENTS, READONLY
 14 .debug_frame  00000d34  00000000  00000000  00023ecc  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  startup	00000000 startup
080000f4 l    d  constructors	00000000 constructors
08000100 l    d  .text	00000000 .text
20000000 l    d  .stacks	00000000 .stacks
20000800 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00000000 l    df *ABS*	00000000 cmd_uart.cpp
08000100 l     F .text	00000024 _GLOBAL__sub_I_Uart
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 chschd.c
08000270 l     F .text	00000034 wakeup
00000000 l    df *ABS*	00000000 chsys.c
20000800 l     O .bss	00000028 mainthread.4583
00000000 l    df *ABS*	00000000 chthreads.c
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 chcore_v7m.c
08000684 l       .text	00000000 _port_exit_from_isr
00000000 l    df *ABS*	00000000 crt0.c
00000000 l    df *ABS*	00000000 hal.c
00000000 l    df *ABS*	00000000 hal_lld.cpp
00000000 l    df *ABS*	00000000 nvic.c
00000000 l    df *ABS*	00000000 stm32_dma.c
20000828 l     O .bss	00000038 dma_isr_redir
20000860 l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 clocking_L1xx.cpp
00000000 l    df *ABS*	00000000 kl_lib_L15x.cpp
08000cf0 l     F .text	0000001c CmdUart_t::PrintNow(char const*) [clone .isra.12]
00000000 l    df *ABS*	00000000 cc1101.cpp
08000d40 l     F .text	00000010 cc1101_t::BusyWait() [clone .isra.6]
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 
20001030 l       .bss	00000000 __heap_base__
08001500 l       .text	00000000 _etext
20004000 l       *ABS*	00000000 __heap_end__
00004000 l       *ABS*	00000000 __ram_size__
00000000 l       startup	00000000 _text
20000000 l       startup	00000000 __ram_start__
20004000 l       *ABS*	00000000 __ram_end__
20001030 l       .bss	00000000 _end
00000400 l       *ABS*	00000000 __main_stack_size__
00000400 l       *ABS*	00000000 __process_stack_size__
08000b20  w    F .text	00000002 Vector58
08000b20  w    F .text	00000002 VectorE8
08000b20  w    F .text	00000002 Vector9C
08000910 g     F .text	00000046 nvicEnableVector
08000cb0 g     F .text	00000034 SetupVCore(VCore_t)
08000b20  w    F .text	00000002 VectorAC
080005c0 g     F .text	0000000a chThdExit
08000460 g     F .text	00000050 chSysTimerHandlerI
080002d0 g     F .text	0000003c chSchGoSleepTimeoutS
08000b20  w    F .text	00000002 Vector5C
08000e30 g     F .text	00000040 cc1101_t::TransmitSync(rPkt_t*)
08000b20  w    F .text	00000002 NMIVector
08000ae0 g     F .text	00000038 dmaInit
08000b20  w    F .text	00000002 Vector8C
08000b20  w    F .text	00000002 VectorDC
08000000 g     O startup	000000f4 _vectors
080002b0 g     F .text	00000020 chSchGoSleepS
080004e0 g     F .text	00000048 chThdCreateI
08000b20  w    F .text	00000002 VectorC8
08000310 g     F .text	00000038 chSchWakeupS
08000210 g     F .text	00000014 _scheduler_init
08000530 g     F .text	00000028 chThdCreateStatic
08000b20  w    F .text	00000002 Vector94
08000b20  w    F .text	00000002 VectorA8
08000b20  w    F .text	00000002 VectorB4
08000230 g     F .text	00000038 chSchReadyI
080000f8 g       constructors	00000000 __fini_array_end
20000800 g       .stacks	00000000 __main_thread_stack_end__
080005d0 g     F .text	00000018 _vt_init
080009f0 g     F .text	0000002c Vector74
08000890 g     F .text	00000004 halInit
08000b20  w    F .text	00000002 VectorEC
20000800 g       .bss	00000000 _bss_start
08000350 g     F .text	00000030 chSchDoRescheduleBehind
08000b20  w    F .text	00000002 UsageFaultVector
08000b20  w    F .text	00000002 DebugMonitorVector
08000b20  w    F .text	00000002 Vector40
080007d0 g     F .text	000000c0 ResetHandler
08000b20  w    F .text	00000002 VectorBC
080006b0 g     F .text	00000034 _port_init
080008a0 g     F .text	00000064 hal_lld_init
08000590 g     F .text	00000030 chThdExitS
08001240 g     F .text	00000040 cc1101_t::IGdo0IrqHandler()
08000b20  w    F .text	00000002 PendSVVector
08000e70 g     F .text	0000016e cc1101_t::RfConfig()
080005f0 g     F .text	0000004c chVTSetI
08001280 g     F .text	00000014 Vector64
20001030 g       .bss	00000000 _bss_end
080007c0  w    F .text	00000002 _default_exit
08000b20  w    F .text	00000002 VectorCC
08000b20  w    F .text	00000002 Vector54
08000b20  w    F .text	00000002 Vector98
08000b20  w    F .text	00000002 VectorD8
08000b20  w    F .text	00000002 Vector24
08000d90 g     F .text	0000002c cc1101_t::WriteStrobe(unsigned char)
080003c0 g     F .text	00000014 chSchDoReschedule
08000400 g     F .text	00000058 chSysInit
08000560 g     F .text	00000028 chThdSleep
08001450 g     O .text	00000054 _stm32_dma_streams
08000ab0 g     F .text	0000002c Vector84
08000760 g     F .text	0000001a SysTickVector
20000874 g     O .bss	000006d0 Uart
08000b20  w    F .text	00000002 BusFaultVector
08000c80 g     F .text	0000002c Clk_t::SwitchToHSI()
08000b20  w    F .text	00000002 VectorD0
08000b60 g     F .text	00000114 Clk_t::UpdateFreqValues()
08000fe0 g     F .text	00000248 cc1101_t::Init()
08000b20  w    F .text	00000002 VectorE4
08000b20  w    F .text	00000002 VectorC0
08000780 g     F .text	00000010 _port_switch
08000690 g     F .text	00000012 SVCallVector
080007b0  w    F .text	00000002 __late_init
08000d10 g     F .text	0000002c chDbgPanic
20001020 g     O .bss	00000010 vtlist
08000d60 g     F .text	00000030 cc1101_t::WriteRegister(unsigned char, unsigned char)
08000b20  w    F .text	00000002 HardFaultVector
080006f0 g     F .text	00000068 _port_irq_epilogue
08000b20  w    F .text	00000002 VectorF0
20000868 g     O .bss	0000000c Clk
08000d50  w    F .text	00000010 Spi_t::ReadWriteByte(unsigned char)
08001500 g       .text	00000000 _textdata
08000b20  w    F .text	00000002 VectorE0
08000b20  w    F .text	00000002 MemManageVector
080000f8 g       constructors	00000000 __fini_array_start
20000f44 g     O .bss	0000001c CC
080012a0 g     F .text	00000094 memset
08000130 g     F .text	000000e0 main
08000990 g     F .text	00000028 Vector6C
20000f64 g     O .bss	0000001c rlist
08000b20  w    F .text	00000002 VectorA0
080000f8 g       constructors	00000000 __init_array_end
08000b20  w    F .text	00000002 VectorC4
08000a50 g     F .text	0000002c Vector7C
080003e0 g     F .text	00000014 _idle_thread
08000b20  w    F .text	00000002 VectorB0
08001370 g     O .text	00000016 ch_debug
08000dd0 g     F .text	0000001e cc1101_t::SetChannel(unsigned char)
08000b20  w    F .text	00000002 Vector90
08000790 g     F .text	00000010 _port_thread_start
08000b20  w    F .text	00000002 Vector60
08000b20  w    F .text	00000002 Vector1C
08000380 g     F .text	00000038 chSchDoRescheduleAhead
08000b20  w    F .text	00000002 Vector48
20000400 g       .stacks	00000000 __process_stack_base__
20000864 g     O .bss	00000001 VCore
080009c0 g     F .text	00000028 Vector70
08000b20  w    F .text	00000002 VectorD4
08000960 g     F .text	00000026 nvicSetSystemHandlerPriority
20000f80 g     O .bss	000000a0 _idle_thread_wa
20000800 g       .bss	00000000 _data
08000b20  w    F .text	00000002 Vector4C
08000a80 g     F .text	0000002c Vector80
08000680 g     F .text	00000006 _port_switch_from_isr
08000b20  w    F .text	00000002 Vector68
20000400 g       .stacks	00000000 __main_stack_end__
08000a20 g     F .text	0000002c Vector78
20000800 g       .bss	00000000 _edata
08000df0 g     F .text	0000003c cc1101_t::WriteTX(unsigned char*, unsigned char)
08000b30 g     F .text	00000028 Clk_t::EnableHSI()
08000640 g     F .text	00000040 chVTResetI
08000b20 g     F .text	00000002 _unhandled_exception
08000b20  w    F .text	00000002 Vector88
20000400 g       .stacks	00000000 __main_thread_stack_base__
08001230 g     F .text	00000010 cc1101_t::IHandleAsync()
20000f60 g     O .bss	00000002 PktTx
080000f4 g       constructors	00000000 __init_array_start
080004b0 g     F .text	00000024 _thread_init
08000b20  w    F .text	00000002 Vector50
08000dc0  w    F .text	00000010 cc1101_t::EnterIdle()
20000000 g       .stacks	00000000 __main_stack_base__
08000b20  w    F .text	00000002 Vector44
08000b20  w    F .text	00000002 Vector28
08000b20  w    F .text	00000002 VectorB8
20000800 g       .stacks	00000000 __process_stack_end__
08000b20  w    F .text	00000002 Vector34
080007a0  w    F .text	00000002 __early_init
08000b20  w    F .text	00000002 VectorA4
08000b20  w    F .text	00000002 Vector20



Disassembly of section .text:

08000100 <_GLOBAL__sub_I_Uart>:
CmdUart_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/cmd_uart.h:81
    uint8_t TryConvertTokenToNumber( int32_t *POutput) { return Convert::TryStrToInt32(Token, POutput); }
    bool NameIs(const char *SCmd) { return (strcasecmp(Name, SCmd) == 0); }
    friend class CmdUart_t;
};

class CmdUart_t {
 8000100:	4b07      	ldr	r3, [pc, #28]	; (8000120 <_GLOBAL__sub_I_Uart+0x20>)
 8000102:	2200      	movs	r2, #0
 8000104:	f8c3 25f0 	str.w	r2, [r3, #1520]	; 0x5f0
 8000108:	f8c3 25f4 	str.w	r2, [r3, #1524]	; 0x5f4
 800010c:	f503 62c8 	add.w	r2, r3, #1600	; 0x640
 8000110:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
 8000114:	f203 6284 	addw	r2, r3, #1668	; 0x684
 8000118:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
 800011c:	4770      	bx	lr
 800011e:	bf00      	nop
 8000120:	20000874 	.word	0x20000874
	...

08000130 <main>:
main():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:29
#define DBG1_CLR()  PinClear(DBG_GPIO1, DBG_PIN1)
#endif

rPkt_t PktTx;

int main(void) {
 8000130:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:31
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V5);
 8000132:	2002      	movs	r0, #2
 8000134:	f000 fdbc 	bl	8000cb0 <SetupVCore(VCore_t)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:32
    Clk.EnableHSI();
 8000138:	4830      	ldr	r0, [pc, #192]	; (80001fc <main+0xcc>)
 800013a:	f000 fcf9 	bl	8000b30 <Clk_t::EnableHSI()>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:33
    Clk.SwitchToHSI();
 800013e:	482f      	ldr	r0, [pc, #188]	; (80001fc <main+0xcc>)
 8000140:	f000 fd9e 	bl	8000c80 <Clk_t::SwitchToHSI()>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:34
    Clk.UpdateFreqValues();
 8000144:	482d      	ldr	r0, [pc, #180]	; (80001fc <main+0xcc>)
 8000146:	f000 fd0b 	bl	8000b60 <Clk_t::UpdateFreqValues()>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:37

    // ==== Init OS ====
    halInit();
 800014a:	f000 fba1 	bl	8000890 <halInit>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:38
    chSysInit();
 800014e:	f000 f957 	bl	8000400 <chSysInit>
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:183
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8000152:	4b2b      	ldr	r3, [pc, #172]	; (8000200 <main+0xd0>)
main():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:44

    // ==== Init Hard & Soft ====
    PinSetupOut(GPIOB, 1, omPushPull, pudNone);

    //Uart.Init(115200);
    CC.Init();
 8000154:	482b      	ldr	r0, [pc, #172]	; (8000204 <main+0xd4>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:183
 8000156:	69da      	ldr	r2, [r3, #28]
 8000158:	f042 0202 	orr.w	r2, r2, #2
 800015c:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800015e:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 8000162:	681a      	ldr	r2, [r3, #0]
 8000164:	f022 020c 	bic.w	r2, r2, #12
 8000168:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:199
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 800016a:	681a      	ldr	r2, [r3, #0]
 800016c:	f042 0204 	orr.w	r2, r2, #4
 8000170:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:201
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000172:	889a      	ldrh	r2, [r3, #4]
 8000174:	f022 0202 	bic.w	r2, r2, #2
 8000178:	0412      	lsls	r2, r2, #16
 800017a:	0c12      	lsrs	r2, r2, #16
 800017c:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:202
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 800017e:	889a      	ldrh	r2, [r3, #4]
 8000180:	b292      	uxth	r2, r2
 8000182:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:204
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000184:	68da      	ldr	r2, [r3, #12]
 8000186:	f022 020c 	bic.w	r2, r2, #12
 800018a:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:205
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800018c:	68da      	ldr	r2, [r3, #12]
 800018e:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:207
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000190:	689a      	ldr	r2, [r3, #8]
 8000192:	f022 020c 	bic.w	r2, r2, #12
 8000196:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:208
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8000198:	689a      	ldr	r2, [r3, #8]
 800019a:	f042 020c 	orr.w	r2, r2, #12
 800019e:	609a      	str	r2, [r3, #8]
main():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:44
 80001a0:	f000 ff1e 	bl	8000fe0 <cc1101_t::Init()>
_ZN8cc1101_t10SetTxPowerEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:58
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
public:
    CCState_t State;
    void Init();
    void SetChannel(uint8_t AChannel);
    void SetTxPower(uint8_t APwr) { WriteRegister(CC_PATABLE, APwr); }
 80001a4:	2286      	movs	r2, #134	; 0x86
 80001a6:	4817      	ldr	r0, [pc, #92]	; (8000204 <main+0xd4>)
 80001a8:	213e      	movs	r1, #62	; 0x3e
 80001aa:	f000 fdd9 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
main():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:46
    CC.SetTxPower(CC_PwrPlus5dBm);
    CC.SetChannel(CHANNEL_ZERO);
 80001ae:	4815      	ldr	r0, [pc, #84]	; (8000204 <main+0xd4>)
 80001b0:	2100      	movs	r1, #0
 80001b2:	f000 fe0d 	bl	8000dd0 <cc1101_t::SetChannel(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:48

    PktTx.Value = 8;
 80001b6:	4b14      	ldr	r3, [pc, #80]	; (8000208 <main+0xd8>)
 80001b8:	2208      	movs	r2, #8
 80001ba:	701a      	strb	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:49
    PktTx.RSSI = 1;
 80001bc:	2201      	movs	r2, #1
 80001be:	705a      	strb	r2, [r3, #1]
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:67
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 80001c0:	4c10      	ldr	r4, [pc, #64]	; (8000204 <main+0xd4>)
 80001c2:	7823      	ldrb	r3, [r4, #0]
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:64
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 80001c4:	4620      	mov	r0, r4
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:67
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 80001c6:	b12b      	cbz	r3, 80001d4 <main+0xa4>
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:64
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 80001c8:	2136      	movs	r1, #54	; 0x36
 80001ca:	f000 fde1 	bl	8000d90 <cc1101_t::WriteStrobe(unsigned char)>
 80001ce:	2300      	movs	r3, #0
 80001d0:	7623      	strb	r3, [r4, #24]
 80001d2:	e7f5      	b.n	80001c0 <main+0x90>
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:68
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
        WriteStrobe(CC_SCAL);
 80001d4:	2133      	movs	r1, #51	; 0x33
 80001d6:	f000 fddb 	bl	8000d90 <cc1101_t::WriteStrobe(unsigned char)>
PinIsSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:179
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 80001da:	4c0c      	ldr	r4, [pc, #48]	; (800020c <main+0xdc>)
 80001dc:	8a23      	ldrh	r3, [r4, #16]
_ZN8cc1101_t8BusyWaitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:37
    PinIrq_t IGdo0;
    void CsHi() { PinSet(CC_GPIO, CC_CS); }
    void CsLo() { PinClear(CC_GPIO, CC_CS); }
    bool GDO0IsHi() { return PinIsSet(CC_GPIO, CC_GDO0); }
    bool GDO2IsHi() { return PinIsSet(CC_GPIO, CC_GDO2); }
    void BusyWait() { while(PinIsSet(CC_GPIO, CC_MISO)); }
 80001de:	065b      	lsls	r3, r3, #25
 80001e0:	d4fb      	bmi.n	80001da <main+0xaa>
PinSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:175 (discriminator 1)
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 80001e2:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 80001e6:	8325      	strh	r5, [r4, #24]
main():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:56 (discriminator 1)
    while(true) {
        //PinSet(GPIOB, 1);
        CC.Recalibrate(); // Recalibrate manually every cycle, as auto recalibration disabled
        // Transmit
        DBG1_SET();
        CC.TransmitSync(&PktTx);
 80001e8:	4806      	ldr	r0, [pc, #24]	; (8000204 <main+0xd4>)
 80001ea:	4907      	ldr	r1, [pc, #28]	; (8000208 <main+0xd8>)
 80001ec:	f000 fe20 	bl	8000e30 <cc1101_t::TransmitSync(rPkt_t*)>
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176 (discriminator 1)
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80001f0:	8365      	strh	r5, [r4, #26]
main():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:58 (discriminator 1)
        DBG1_CLR();
        chThdSleepMilliseconds(20);
 80001f2:	2014      	movs	r0, #20
 80001f4:	f000 f9b4 	bl	8000560 <chThdSleep>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../main.cpp:29 (discriminator 1)
#define DBG1_CLR()  PinClear(DBG_GPIO1, DBG_PIN1)
#endif

rPkt_t PktTx;

int main(void) {
 80001f8:	e7e2      	b.n	80001c0 <main+0x90>
 80001fa:	bf00      	nop
 80001fc:	20000868 	.word	0x20000868
 8000200:	40023800 	.word	0x40023800
 8000204:	20000f44 	.word	0x20000f44
 8000208:	20000f60 	.word	0x20000f60
 800020c:	40020000 	.word	0x40020000

08000210 <_scheduler_init>:
_scheduler_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000210:	4b03      	ldr	r3, [pc, #12]	; (8000220 <_scheduler_init+0x10>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000212:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000214:	605b      	str	r3, [r3, #4]
 8000216:	601b      	str	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000218:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:60
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 800021a:	615b      	str	r3, [r3, #20]
 800021c:	611b      	str	r3, [r3, #16]
 800021e:	4770      	bx	lr
 8000220:	20000f64 	.word	0x20000f64
	...

08000230 <chSchReadyI>:
chSchReadyI():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 8000230:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:87
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 8000232:	7f03      	ldrb	r3, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 8000234:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:87
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 8000236:	b10b      	cbz	r3, 800023c <chSchReadyI+0xc>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:87 (discriminator 2)
 8000238:	2b0e      	cmp	r3, #14
 800023a:	d102      	bne.n	8000242 <chSchReadyI+0x12>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:87 (discriminator 1)
 800023c:	4808      	ldr	r0, [pc, #32]	; (8000260 <chSchReadyI+0x30>)
 800023e:	f000 fd67 	bl	8000d10 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:92
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 8000242:	2300      	movs	r3, #0
 8000244:	7723      	strb	r3, [r4, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:96
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 8000246:	68a1      	ldr	r1, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:93
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 8000248:	4b06      	ldr	r3, [pc, #24]	; (8000264 <chSchReadyI+0x34>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:95 (discriminator 1)
  do {
    cp = cp->p_next;
 800024a:	681b      	ldr	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:96 (discriminator 1)
  } while (cp->p_prio >= tp->p_prio);
 800024c:	689a      	ldr	r2, [r3, #8]
 800024e:	428a      	cmp	r2, r1
 8000250:	d2fb      	bcs.n	800024a <chSchReadyI+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:99
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000252:	685a      	ldr	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:98
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000254:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:99
  tp->p_prev = cp->p_prev;
 8000256:	6062      	str	r2, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:102
  tp->p_prev->p_next = cp->p_prev = tp;
  return tp;
}
 8000258:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:100
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800025a:	605c      	str	r4, [r3, #4]
 800025c:	6014      	str	r4, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:102
  return tp;
}
 800025e:	bd10      	pop	{r4, pc}
 8000260:	08001390 	.word	0x08001390
 8000264:	20000f64 	.word	0x20000f64
	...

08000270 <wakeup>:
wakeup():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:136

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000270:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:139
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
 8000272:	2320      	movs	r3, #32
 8000274:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:140
  switch (tp->p_state) {
 8000278:	7f03      	ldrb	r3, [r0, #28]
 800027a:	b183      	cbz	r3, 800029e <wakeup+0x2e>
 800027c:	2b03      	cmp	r3, #3
 800027e:	d108      	bne.n	8000292 <wakeup+0x22>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:150
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 8000280:	6a03      	ldr	r3, [r0, #32]
 8000282:	689a      	ldr	r2, [r3, #8]
 8000284:	3201      	adds	r2, #1
 8000286:	609a      	str	r2, [r3, #8]
dequeue():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:75
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000288:	e890 000c 	ldmia.w	r0, {r2, r3}
 800028c:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:76
  tp->p_next->p_prev = tp->p_prev;
 800028e:	6802      	ldr	r2, [r0, #0]
 8000290:	6053      	str	r3, [r2, #4]
wakeup():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:163
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 8000292:	f04f 33ff 	mov.w	r3, #4294967295
 8000296:	6203      	str	r3, [r0, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:164
  chSchReadyI(tp);
 8000298:	f7ff ffca 	bl	8000230 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:165
  chSysUnlockFromIsr();
 800029c:	2300      	movs	r3, #0
 800029e:	f383 8811 	msr	BASEPRI, r3
 80002a2:	bd08      	pop	{r3, pc}
	...

080002b0 <chSchGoSleepS>:
chSchGoSleepS():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 80002b0:	4b06      	ldr	r3, [pc, #24]	; (80002cc <chSchGoSleepS+0x1c>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 80002b2:	2214      	movs	r2, #20
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 80002b4:	6999      	ldr	r1, [r3, #24]
 80002b6:	7708      	strb	r0, [r1, #28]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 80002b8:	6818      	ldr	r0, [r3, #0]
chSchGoSleepS():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 80002ba:	778a      	strb	r2, [r1, #30]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80002bc:	6802      	ldr	r2, [r0, #0]
 80002be:	6053      	str	r3, [r2, #4]
 80002c0:	601a      	str	r2, [r3, #0]
chSchGoSleepS():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:126
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 80002c2:	6198      	str	r0, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:127
  currp->p_state = THD_STATE_CURRENT;
 80002c4:	2301      	movs	r3, #1
 80002c6:	7703      	strb	r3, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:128
  chSysSwitch(currp, otp);
 80002c8:	f000 ba5a 	b.w	8000780 <_port_switch>
 80002cc:	20000f64 	.word	0x20000f64

080002d0 <chSchGoSleepTimeoutS>:
chSchGoSleepTimeoutS():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80002d0:	b530      	push	{r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:193

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80002d2:	1c4b      	adds	r3, r1, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80002d4:	b087      	sub	sp, #28
 80002d6:	4605      	mov	r5, r0
 80002d8:	4c0a      	ldr	r4, [pc, #40]	; (8000304 <chSchGoSleepTimeoutS+0x34>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:193

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80002da:	d00d      	beq.n	80002f8 <chSchGoSleepTimeoutS+0x28>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:196
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 80002dc:	69a3      	ldr	r3, [r4, #24]
 80002de:	a801      	add	r0, sp, #4
 80002e0:	4a09      	ldr	r2, [pc, #36]	; (8000308 <chSchGoSleepTimeoutS+0x38>)
 80002e2:	f000 f985 	bl	80005f0 <chVTSetI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:197
    chSchGoSleepS(newstate);
 80002e6:	4628      	mov	r0, r5
 80002e8:	f7ff ffe2 	bl	80002b0 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:198
    if (chVTIsArmedI(&vt))
 80002ec:	9b04      	ldr	r3, [sp, #16]
 80002ee:	b12b      	cbz	r3, 80002fc <chSchGoSleepTimeoutS+0x2c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:199
      chVTResetI(&vt);
 80002f0:	a801      	add	r0, sp, #4
 80002f2:	f000 f9a5 	bl	8000640 <chVTResetI>
 80002f6:	e001      	b.n	80002fc <chSchGoSleepTimeoutS+0x2c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:202
  }
  else
    chSchGoSleepS(newstate);
 80002f8:	f7ff ffda 	bl	80002b0 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:203
  return currp->p_u.rdymsg;
 80002fc:	69a3      	ldr	r3, [r4, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:204
}
 80002fe:	6a18      	ldr	r0, [r3, #32]
 8000300:	b007      	add	sp, #28
 8000302:	bd30      	pop	{r4, r5, pc}
 8000304:	20000f64 	.word	0x20000f64
 8000308:	08000271 	.word	0x08000271
$d():
 800030c:	00000000 	.word	0x00000000

08000310 <chSchWakeupS>:
chSchWakeupS():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 8000310:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8000312:	4d0c      	ldr	r5, [pc, #48]	; (8000344 <chSchWakeupS+0x34>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:229
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 8000314:	6201      	str	r1, [r0, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:234
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8000316:	69ab      	ldr	r3, [r5, #24]
 8000318:	6881      	ldr	r1, [r0, #8]
 800031a:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 800031c:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 800031e:	4291      	cmp	r1, r2
 8000320:	d803      	bhi.n	800032a <chSchWakeupS+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:242
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000322:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:235
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
 8000326:	f7ff bf83 	b.w	8000230 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:237
  else {
    Thread *otp = chSchReadyI(currp);
 800032a:	4618      	mov	r0, r3
 800032c:	f7ff ff80 	bl	8000230 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 8000330:	2301      	movs	r3, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:237
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
 8000332:	4601      	mov	r1, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:238
    setcurrp(ntp);
 8000334:	61ac      	str	r4, [r5, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:239
    ntp->p_state = THD_STATE_CURRENT;
 8000336:	7723      	strb	r3, [r4, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:240
    chSysSwitch(ntp, otp);
 8000338:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:242
  }
}
 800033a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:240
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800033e:	f000 ba1f 	b.w	8000780 <_port_switch>
 8000342:	bf00      	nop
 8000344:	20000f64 	.word	0x20000f64
	...

08000350 <chSchDoRescheduleBehind>:
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:304
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
 8000350:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:307
  Thread *otp;

  otp = currp;
 8000352:	4c0a      	ldr	r4, [pc, #40]	; (800037c <chSchDoRescheduleBehind+0x2c>)
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8000354:	6823      	ldr	r3, [r4, #0]
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:307
 8000356:	69a5      	ldr	r5, [r4, #24]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8000358:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:314
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
 800035a:	4628      	mov	r0, r5
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:62
 800035c:	6054      	str	r4, [r2, #4]
 800035e:	6022      	str	r2, [r4, #0]
chSchDoRescheduleBehind():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:310
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8000360:	2201      	movs	r2, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:309
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000362:	61a3      	str	r3, [r4, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:310
  currp->p_state = THD_STATE_CURRENT;
 8000364:	771a      	strb	r2, [r3, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:312
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
 8000366:	2314      	movs	r3, #20
 8000368:	77ab      	strb	r3, [r5, #30]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:314
#endif
  chSchReadyI(otp);
 800036a:	f7ff ff61 	bl	8000230 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:315
  chSysSwitch(currp, otp);
 800036e:	69a0      	ldr	r0, [r4, #24]
 8000370:	4629      	mov	r1, r5
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:316
}
 8000372:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:315
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8000376:	f000 ba03 	b.w	8000780 <_port_switch>
 800037a:	bf00      	nop
 800037c:	20000f64 	.word	0x20000f64

08000380 <chSchDoRescheduleAhead>:
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:332
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
 8000380:	4b0c      	ldr	r3, [pc, #48]	; (80003b4 <chSchDoRescheduleAhead+0x34>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:329
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
 8000382:	b510      	push	{r4, lr}
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8000384:	6818      	ldr	r0, [r3, #0]
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:332
  Thread *otp, *cp;

  otp = currp;
 8000386:	6999      	ldr	r1, [r3, #24]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8000388:	6802      	ldr	r2, [r0, #0]
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:341

  otp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800038a:	688c      	ldr	r4, [r1, #8]
fifo_remove():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/include/chinline.h:62
 800038c:	6053      	str	r3, [r2, #4]
 800038e:	601a      	str	r2, [r3, #0]
chSchDoRescheduleAhead():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:335
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8000390:	2201      	movs	r2, #1
 8000392:	7702      	strb	r2, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:337

  otp->p_state = THD_STATE_READY;
 8000394:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:334
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000396:	6198      	str	r0, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:337
  currp->p_state = THD_STATE_CURRENT;

  otp->p_state = THD_STATE_READY;
 8000398:	770a      	strb	r2, [r1, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:340 (discriminator 1)
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
 800039a:	681b      	ldr	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:341 (discriminator 1)
  } while (cp->p_prio > otp->p_prio);
 800039c:	689a      	ldr	r2, [r3, #8]
 800039e:	42a2      	cmp	r2, r4
 80003a0:	d8fb      	bhi.n	800039a <chSchDoRescheduleAhead+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:344
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80003a2:	685a      	ldr	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:343
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80003a4:	600b      	str	r3, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:344
  otp->p_prev = cp->p_prev;
 80003a6:	604a      	str	r2, [r1, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:348
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
}
 80003a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:345
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 80003ac:	6059      	str	r1, [r3, #4]
 80003ae:	6011      	str	r1, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:347

  chSysSwitch(currp, otp);
 80003b0:	f000 b9e6 	b.w	8000780 <_port_switch>
 80003b4:	20000f64 	.word	0x20000f64
	...

080003c0 <chSchDoReschedule>:
chSchDoReschedule():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:367
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
 80003c0:	4b03      	ldr	r3, [pc, #12]	; (80003d0 <chSchDoReschedule+0x10>)
 80003c2:	699b      	ldr	r3, [r3, #24]
 80003c4:	7f9b      	ldrb	r3, [r3, #30]
 80003c6:	b90b      	cbnz	r3, 80003cc <chSchDoReschedule+0xc>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:370
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 80003c8:	f7ff bfc2 	b.w	8000350 <chSchDoRescheduleBehind>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chschd.c:375
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 80003cc:	f7ff bfd8 	b.w	8000380 <chSchDoRescheduleAhead>
 80003d0:	20000f64 	.word	0x20000f64
	...

080003e0 <_idle_thread>:
_idle_thread():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:64
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 80003e0:	4b02      	ldr	r3, [pc, #8]	; (80003ec <_idle_thread+0xc>)
 80003e2:	4a03      	ldr	r2, [pc, #12]	; (80003f0 <_idle_thread+0x10>)
 80003e4:	699b      	ldr	r3, [r3, #24]
 80003e6:	619a      	str	r2, [r3, #24]
 80003e8:	e7fe      	b.n	80003e8 <_idle_thread+0x8>
 80003ea:	bf00      	nop
 80003ec:	20000f64 	.word	0x20000f64
 80003f0:	080013b0 	.word	0x080013b0
	...

08000400 <chSysInit>:
chSysInit():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:84
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 8000400:	b507      	push	{r0, r1, r2, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:90
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8000402:	f000 f955 	bl	80006b0 <_port_init>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:91
  _scheduler_init();
 8000406:	f7ff ff03 	bl	8000210 <_scheduler_init>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:92
  _vt_init();
 800040a:	f000 f8e1 	bl	80005d0 <_vt_init>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:104
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 800040e:	2140      	movs	r1, #64	; 0x40
 8000410:	480c      	ldr	r0, [pc, #48]	; (8000444 <chSysInit+0x44>)
 8000412:	f000 f84d 	bl	80004b0 <_thread_init>
 8000416:	4b0c      	ldr	r3, [pc, #48]	; (8000448 <chSysInit+0x48>)
 8000418:	6198      	str	r0, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:105
  currp->p_state = THD_STATE_CURRENT;
 800041a:	2301      	movs	r3, #1
 800041c:	7703      	strb	r3, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:111
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 800041e:	2300      	movs	r3, #0
 8000420:	f383 8811 	msr	BASEPRI, r3
 8000424:	b662      	cpsie	i
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:115

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000426:	4b08      	ldr	r3, [pc, #32]	; (8000448 <chSysInit+0x48>)
 8000428:	4a08      	ldr	r2, [pc, #32]	; (800044c <chSysInit+0x4c>)
 800042a:	699b      	ldr	r3, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800042c:	21a0      	movs	r1, #160	; 0xa0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:115
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 800042e:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 8000430:	2300      	movs	r3, #0
 8000432:	9300      	str	r3, [sp, #0]
 8000434:	2201      	movs	r2, #1
 8000436:	4b06      	ldr	r3, [pc, #24]	; (8000450 <chSysInit+0x50>)
 8000438:	4806      	ldr	r0, [pc, #24]	; (8000454 <chSysInit+0x54>)
 800043a:	f000 f879 	bl	8000530 <chThdCreateStatic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:124
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 800043e:	b003      	add	sp, #12
 8000440:	f85d fb04 	ldr.w	pc, [sp], #4
 8000444:	20000800 	.word	0x20000800
 8000448:	20000f64 	.word	0x20000f64
 800044c:	08001370 	.word	0x08001370
 8000450:	080003e1 	.word	0x080003e1
 8000454:	20000f80 	.word	0x20000f80
	...

08000460 <chSysTimerHandlerI>:
chSysTimerHandlerI():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:137
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000460:	b538      	push	{r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:143

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
 8000462:	4b11      	ldr	r3, [pc, #68]	; (80004a8 <chSysTimerHandlerI+0x48>)
 8000464:	699b      	ldr	r3, [r3, #24]
 8000466:	7f9a      	ldrb	r2, [r3, #30]
 8000468:	b10a      	cbz	r2, 800046e <chSysTimerHandlerI+0xe>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:145
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800046a:	3a01      	subs	r2, #1
 800046c:	779a      	strb	r2, [r3, #30]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:150
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
#endif
  chVTDoTickI();
 800046e:	4b0f      	ldr	r3, [pc, #60]	; (80004ac <chSysTimerHandlerI+0x4c>)
 8000470:	68da      	ldr	r2, [r3, #12]
 8000472:	461c      	mov	r4, r3
 8000474:	3201      	adds	r2, #1
 8000476:	60da      	str	r2, [r3, #12]
 8000478:	681a      	ldr	r2, [r3, #0]
 800047a:	429a      	cmp	r2, r3
 800047c:	d013      	beq.n	80004a6 <chSysTimerHandlerI+0x46>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:150 (discriminator 1)
 800047e:	6891      	ldr	r1, [r2, #8]
 8000480:	3901      	subs	r1, #1
 8000482:	6091      	str	r1, [r2, #8]
 8000484:	6822      	ldr	r2, [r4, #0]
 8000486:	4909      	ldr	r1, [pc, #36]	; (80004ac <chSysTimerHandlerI+0x4c>)
 8000488:	6893      	ldr	r3, [r2, #8]
 800048a:	b963      	cbnz	r3, 80004a6 <chSysTimerHandlerI+0x46>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chsys.c:150 (discriminator 2)
 800048c:	6810      	ldr	r0, [r2, #0]
 800048e:	68d5      	ldr	r5, [r2, #12]
 8000490:	6008      	str	r0, [r1, #0]
 8000492:	60d3      	str	r3, [r2, #12]
 8000494:	6041      	str	r1, [r0, #4]
 8000496:	f383 8811 	msr	BASEPRI, r3
 800049a:	6910      	ldr	r0, [r2, #16]
 800049c:	47a8      	blx	r5
 800049e:	2320      	movs	r3, #32
 80004a0:	f383 8811 	msr	BASEPRI, r3
 80004a4:	e7ee      	b.n	8000484 <chSysTimerHandlerI+0x24>
 80004a6:	bd38      	pop	{r3, r4, r5, pc}
 80004a8:	20000f64 	.word	0x20000f64
 80004ac:	20001020 	.word	0x20001020

080004b0 <_thread_init>:
_thread_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:79
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 80004b0:	2202      	movs	r2, #2
 80004b2:	7702      	strb	r2, [r0, #28]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:80
  tp->p_flags = THD_MEM_MODE_STATIC;
 80004b4:	2200      	movs	r2, #0
 80004b6:	7742      	strb	r2, [r0, #29]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:89
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 80004b8:	6242      	str	r2, [r0, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:98
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 80004ba:	6182      	str	r2, [r0, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:99
  REG_INSERT(tp);
 80004bc:	4a04      	ldr	r2, [pc, #16]	; (80004d0 <_thread_init+0x20>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:78
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 80004be:	6081      	str	r1, [r0, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:82
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 80004c0:	2114      	movs	r1, #20
 80004c2:	7781      	strb	r1, [r0, #30]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80004c4:	6951      	ldr	r1, [r2, #20]
 80004c6:	6102      	str	r2, [r0, #16]
 80004c8:	6141      	str	r1, [r0, #20]
 80004ca:	6150      	str	r0, [r2, #20]
 80004cc:	6108      	str	r0, [r1, #16]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:114
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
 80004ce:	4770      	bx	lr
 80004d0:	20000f64 	.word	0x20000f64
	...

080004e0 <chThdCreateI>:
chThdCreateI():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:158
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
 80004e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80004e4:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80004e8:	460d      	mov	r5, r1
 80004ea:	4616      	mov	r6, r2
 80004ec:	461f      	mov	r7, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:164
  /* Thread structure is laid out in the lower part of the thread workspace.*/
  Thread *tp = wsp;

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
 80004ee:	4604      	mov	r4, r0
 80004f0:	b120      	cbz	r0, 80004fc <chThdCreateI+0x1c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:164 (discriminator 2)
 80004f2:	298f      	cmp	r1, #143	; 0x8f
 80004f4:	d902      	bls.n	80004fc <chThdCreateI+0x1c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:164 (discriminator 1)
 80004f6:	2a7f      	cmp	r2, #127	; 0x7f
 80004f8:	d800      	bhi.n	80004fc <chThdCreateI+0x1c>
 80004fa:	b913      	cbnz	r3, 8000502 <chThdCreateI+0x22>
 80004fc:	4808      	ldr	r0, [pc, #32]	; (8000520 <chThdCreateI+0x40>)
 80004fe:	f000 fc07 	bl	8000d10 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:167
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8000502:	3d24      	subs	r5, #36	; 0x24
 8000504:	4b07      	ldr	r3, [pc, #28]	; (8000524 <chThdCreateI+0x44>)
 8000506:	1960      	adds	r0, r4, r5
 8000508:	60e0      	str	r0, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 800050a:	4631      	mov	r1, r6
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:167
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 800050c:	5167      	str	r7, [r4, r5]
 800050e:	f8c0 8004 	str.w	r8, [r0, #4]
 8000512:	6203      	str	r3, [r0, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 8000514:	4620      	mov	r0, r4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:169
}
 8000516:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:168

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
 800051a:	f7ff bfc9 	b.w	80004b0 <_thread_init>
 800051e:	bf00      	nop
 8000520:	080013c0 	.word	0x080013c0
 8000524:	08000791 	.word	0x08000791
	...

08000530 <chThdCreateStatic>:
chThdCreateStatic():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 8000530:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000532:	461d      	mov	r5, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:199
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
 8000534:	2320      	movs	r3, #32
 8000536:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:200
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 800053a:	9c06      	ldr	r4, [sp, #24]
 800053c:	462b      	mov	r3, r5
 800053e:	9400      	str	r4, [sp, #0]
 8000540:	f7ff ffce 	bl	80004e0 <chThdCreateI>
 8000544:	2100      	movs	r1, #0
 8000546:	4604      	mov	r4, r0
 8000548:	f7ff fee2 	bl	8000310 <chSchWakeupS>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:201
  chSysUnlock();
 800054c:	2300      	movs	r3, #0
 800054e:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:203
  return tp;
}
 8000552:	4620      	mov	r0, r4
 8000554:	b003      	add	sp, #12
 8000556:	bd30      	pop	{r4, r5, pc}
	...

08000560 <chThdSleep>:
chThdSleep():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:292
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000560:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:294

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");
 8000562:	4604      	mov	r4, r0
 8000564:	b910      	cbnz	r0, 800056c <chThdSleep+0xc>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:294 (discriminator 1)
 8000566:	4807      	ldr	r0, [pc, #28]	; (8000584 <chThdSleep+0x24>)
 8000568:	f000 fbd2 	bl	8000d10 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:296

  chSysLock();
 800056c:	2320      	movs	r3, #32
 800056e:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:297
  chThdSleepS(time);
 8000572:	2006      	movs	r0, #6
 8000574:	4621      	mov	r1, r4
 8000576:	f7ff feab 	bl	80002d0 <chSchGoSleepTimeoutS>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:298
  chSysUnlock();
 800057a:	2300      	movs	r3, #0
 800057c:	f383 8811 	msr	BASEPRI, r3
 8000580:	bd10      	pop	{r4, pc}
 8000582:	bf00      	nop
 8000584:	080013f8 	.word	0x080013f8
	...

08000590 <chThdExitS>:
chThdExitS():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:366
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000590:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:367
  Thread *tp = currp;
 8000592:	4b09      	ldr	r3, [pc, #36]	; (80005b8 <chThdExitS+0x28>)
 8000594:	699b      	ldr	r3, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:380
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 8000596:	7f5a      	ldrb	r2, [r3, #29]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:369
 * @sclass
 */
void chThdExitS(msg_t msg) {
  Thread *tp = currp;

  tp->p_u.exitcode = msg;
 8000598:	6218      	str	r0, [r3, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:380
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 800059a:	0792      	lsls	r2, r2, #30
 800059c:	d104      	bne.n	80005a8 <chThdExitS+0x18>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:381
    REG_REMOVE(tp);
 800059e:	695a      	ldr	r2, [r3, #20]
 80005a0:	6919      	ldr	r1, [r3, #16]
 80005a2:	6111      	str	r1, [r2, #16]
 80005a4:	691b      	ldr	r3, [r3, #16]
 80005a6:	615a      	str	r2, [r3, #20]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:383
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 80005a8:	200e      	movs	r0, #14
 80005aa:	f7ff fe81 	bl	80002b0 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:386
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 80005ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:385
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
 80005b2:	4802      	ldr	r0, [pc, #8]	; (80005bc <chThdExitS+0x2c>)
 80005b4:	f000 bbac 	b.w	8000d10 <chDbgPanic>
 80005b8:	20000f64 	.word	0x20000f64
 80005bc:	08001407 	.word	0x08001407

080005c0 <chThdExit>:
chThdExit():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:347
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
 80005c0:	2320      	movs	r3, #32
 80005c2:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chthreads.c:348
  chThdExitS(msg);
 80005c6:	f7ff bfe3 	b.w	8000590 <chThdExitS>
 80005ca:	0000      	movs	r0, r0
 80005cc:	0000      	movs	r0, r0
	...

080005d0 <_vt_init>:
_vt_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 80005d0:	4b04      	ldr	r3, [pc, #16]	; (80005e4 <_vt_init+0x14>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:53
  vtlist.vt_time = (systime_t)-1;
 80005d2:	f04f 32ff 	mov.w	r2, #4294967295
 80005d6:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:54
  vtlist.vt_systime = 0;
 80005d8:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 80005da:	605b      	str	r3, [r3, #4]
 80005dc:	601b      	str	r3, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:54
  vtlist.vt_time = (systime_t)-1;
  vtlist.vt_systime = 0;
 80005de:	60da      	str	r2, [r3, #12]
 80005e0:	4770      	bx	lr
 80005e2:	bf00      	nop
 80005e4:	20001020 	.word	0x20001020
	...

080005f0 <chVTSetI>:
chVTSetI():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:76
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 80005f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80005f2:	460d      	mov	r5, r1
 80005f4:	4616      	mov	r6, r2
 80005f6:	461f      	mov	r7, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:80
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
 80005f8:	4604      	mov	r4, r0
 80005fa:	b108      	cbz	r0, 8000600 <chVTSetI+0x10>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:80 (discriminator 2)
 80005fc:	b102      	cbz	r2, 8000600 <chVTSetI+0x10>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:80 (discriminator 1)
 80005fe:	b911      	cbnz	r1, 8000606 <chVTSetI+0x16>
 8000600:	480c      	ldr	r0, [pc, #48]	; (8000634 <chVTSetI+0x44>)
 8000602:	f000 fb85 	bl	8000d10 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:85
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 8000606:	4a0c      	ldr	r2, [pc, #48]	; (8000638 <chVTSetI+0x48>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:83

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
 8000608:	6127      	str	r7, [r4, #16]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:85
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 800060a:	6813      	ldr	r3, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:84
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800060c:	60e6      	str	r6, [r4, #12]
 800060e:	4611      	mov	r1, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:86 (discriminator 1)
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 8000610:	689a      	ldr	r2, [r3, #8]
 8000612:	42aa      	cmp	r2, r5
 8000614:	d202      	bcs.n	800061c <chVTSetI+0x2c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:87
    time -= p->vt_time;
 8000616:	1aad      	subs	r5, r5, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:88
    p = p->vt_next;
 8000618:	681b      	ldr	r3, [r3, #0]
 800061a:	e7f9      	b.n	8000610 <chVTSetI+0x20>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:91
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 800061c:	685a      	ldr	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:94
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_time = time;
  if (p != (void *)&vtlist)
 800061e:	428b      	cmp	r3, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:91
  while (p->vt_time < time) {
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8000620:	6023      	str	r3, [r4, #0]
 8000622:	6062      	str	r2, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:92
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8000624:	605c      	str	r4, [r3, #4]
 8000626:	6014      	str	r4, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:93
  vtp->vt_time = time;
 8000628:	60a5      	str	r5, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:94
  if (p != (void *)&vtlist)
 800062a:	d002      	beq.n	8000632 <chVTSetI+0x42>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:95
    p->vt_time -= time;
 800062c:	689a      	ldr	r2, [r3, #8]
 800062e:	1b55      	subs	r5, r2, r5
 8000630:	609d      	str	r5, [r3, #8]
 8000632:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000634:	08001420 	.word	0x08001420
 8000638:	20001020 	.word	0x20001020
$d():
 800063c:	00000000 	.word	0x00000000

08000640 <chVTResetI>:
chVTResetI():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:106
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 8000640:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:109

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL, "chVTResetI");
 8000642:	4604      	mov	r4, r0
 8000644:	b910      	cbnz	r0, 800064c <chVTResetI+0xc>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:109 (discriminator 1)
 8000646:	480b      	ldr	r0, [pc, #44]	; (8000674 <chVTResetI+0x34>)
 8000648:	f000 fb62 	bl	8000d10 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:110
  chDbgAssert(vtp->vt_func != NULL,
 800064c:	68e3      	ldr	r3, [r4, #12]
 800064e:	b913      	cbnz	r3, 8000656 <chVTResetI+0x16>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:110 (discriminator 1)
 8000650:	4809      	ldr	r0, [pc, #36]	; (8000678 <chVTResetI+0x38>)
 8000652:	f000 fb5d 	bl	8000d10 <chDbgPanic>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:114
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 8000656:	6823      	ldr	r3, [r4, #0]
 8000658:	4a08      	ldr	r2, [pc, #32]	; (800067c <chVTResetI+0x3c>)
 800065a:	4293      	cmp	r3, r2
 800065c:	d003      	beq.n	8000666 <chVTResetI+0x26>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:115
    vtp->vt_next->vt_time += vtp->vt_time;
 800065e:	6899      	ldr	r1, [r3, #8]
 8000660:	68a2      	ldr	r2, [r4, #8]
 8000662:	440a      	add	r2, r1
 8000664:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:116
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000666:	6862      	ldr	r2, [r4, #4]
 8000668:	6013      	str	r3, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:117
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800066a:	6823      	ldr	r3, [r4, #0]
 800066c:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/kernel/src/chvt.c:118
  vtp->vt_func = (vtfunc_t)NULL;
 800066e:	2300      	movs	r3, #0
 8000670:	60e3      	str	r3, [r4, #12]
 8000672:	bd10      	pop	{r4, pc}
 8000674:	0800142d 	.word	0x0800142d
 8000678:	0800143c 	.word	0x0800143c
 800067c:	20001020 	.word	0x20001020

08000680 <_port_switch_from_isr>:
_port_switch_from_isr():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:210
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
  chSchDoReschedule();
 8000680:	f7ff fe9e 	bl	80003c0 <chSchDoReschedule>

08000684 <_port_exit_from_isr>:
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:214
  dbg_check_unlock();
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
 8000684:	df00      	svc	0
	...

08000690 <SVCallVector>:
SVCallVector():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:69
 */
void SVCallVector(void) {
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000690:	f3ef 8309 	mrs	r3, PSP
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:73

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000694:	3320      	adds	r3, #32
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:80
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000696:	f383 8809 	msr	PSP, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:81
  port_unlock_from_isr();
 800069a:	2300      	movs	r3, #0
 800069c:	f383 8811 	msr	BASEPRI, r3
 80006a0:	4770      	bx	lr
	...

080006b0 <_port_init>:
_port_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:118
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
 80006b0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:121

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
 80006b2:	4b0a      	ldr	r3, [pc, #40]	; (80006dc <_port_init+0x2c>)
 80006b4:	2200      	movs	r2, #0
 80006b6:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:122
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 80006b8:	4a09      	ldr	r2, [pc, #36]	; (80006e0 <_port_init+0x30>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 80006ba:	2007      	movs	r0, #7
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:122
 */
void _port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 80006bc:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 80006be:	2110      	movs	r1, #16
 80006c0:	f000 f94e 	bl	8000960 <nvicSetSystemHandlerPriority>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:127
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
 80006c4:	200a      	movs	r0, #10
 80006c6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80006ca:	f000 f949 	bl	8000960 <nvicSetSystemHandlerPriority>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:131
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
}
 80006ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:129
  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
 80006d2:	200b      	movs	r0, #11
 80006d4:	2180      	movs	r1, #128	; 0x80
 80006d6:	f000 b943 	b.w	8000960 <nvicSetSystemHandlerPriority>
 80006da:	bf00      	nop
 80006dc:	e000ed00 	.word	0xe000ed00
 80006e0:	05fa0300 	.word	0x05fa0300
	...

080006f0 <_port_irq_epilogue>:
_port_irq_epilogue():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:150
/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
 80006f0:	2320      	movs	r3, #32
 80006f2:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:151
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
 80006f6:	4b14      	ldr	r3, [pc, #80]	; (8000748 <_port_irq_epilogue+0x58>)
 80006f8:	685b      	ldr	r3, [r3, #4]
 80006fa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80006fe:	d020      	beq.n	8000742 <_port_irq_epilogue+0x52>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:155
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000700:	f3ef 8309 	mrs	r3, PSP
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:159

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000704:	f1a3 0220 	sub.w	r2, r3, #32
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:160
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000708:	f382 8809 	msr	PSP, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:161
    ctxp->xpsr = (regarm_t)0x01000000;
 800070c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000710:	f843 2c04 	str.w	r2, [r3, #-4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000714:	4a0d      	ldr	r2, [pc, #52]	; (800074c <_port_irq_epilogue+0x5c>)
 8000716:	6991      	ldr	r1, [r2, #24]
 8000718:	6812      	ldr	r2, [r2, #0]
 800071a:	7f88      	ldrb	r0, [r1, #30]
 800071c:	6892      	ldr	r2, [r2, #8]
 800071e:	6889      	ldr	r1, [r1, #8]
 8000720:	b120      	cbz	r0, 800072c <_port_irq_epilogue+0x3c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165 (discriminator 1)
 8000722:	428a      	cmp	r2, r1
 8000724:	bf94      	ite	ls
 8000726:	2200      	movls	r2, #0
 8000728:	2201      	movhi	r2, #1
 800072a:	e003      	b.n	8000734 <_port_irq_epilogue+0x44>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165 (discriminator 2)
 800072c:	428a      	cmp	r2, r1
 800072e:	bf34      	ite	cc
 8000730:	2200      	movcc	r2, #0
 8000732:	2201      	movcs	r2, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:165 (discriminator 3)
 8000734:	b10a      	cbz	r2, 800073a <_port_irq_epilogue+0x4a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:167
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
 8000736:	4a06      	ldr	r2, [pc, #24]	; (8000750 <_port_irq_epilogue+0x60>)
 8000738:	e000      	b.n	800073c <_port_irq_epilogue+0x4c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:176
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
 800073a:	4a06      	ldr	r2, [pc, #24]	; (8000754 <_port_irq_epilogue+0x64>)
 800073c:	f843 2c08 	str.w	r2, [r3, #-8]
 8000740:	4770      	bx	lr
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:197

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8000742:	f383 8811 	msr	BASEPRI, r3
 8000746:	4770      	bx	lr
 8000748:	e000ed00 	.word	0xe000ed00
 800074c:	20000f64 	.word	0x20000f64
 8000750:	08000681 	.word	0x08000681
 8000754:	08000684 	.word	0x08000684
	...

08000760 <SysTickVector>:
SysTickVector():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:47
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
 8000760:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:51

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
 8000762:	2320      	movs	r3, #32
 8000764:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:52
  chSysTimerHandlerI();
 8000768:	f7ff fe7a 	bl	8000460 <chSysTimerHandlerI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:53
  chSysUnlockFromIsr();
 800076c:	2300      	movs	r3, #0
 800076e:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:56

  CH_IRQ_EPILOGUE();
}
 8000772:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:55

  chSysLockFromIsr();
  chSysTimerHandlerI();
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
 8000776:	f7ff bfbb 	b.w	80006f0 <_port_irq_epilogue>
 800077a:	0000      	movs	r0, r0
 800077c:	0000      	movs	r0, r0
	...

08000780 <_port_switch>:
_port_switch():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:238
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
 8000780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:244
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
 8000784:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000788:	f8d0 d00c 	ldr.w	sp, [r0, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:250
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
 800078c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000790 <_port_thread_start>:
_port_thread_start():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:261
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
 8000790:	2300      	movs	r3, #0
 8000792:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/chcore_v7m.c:262
  asm volatile ("mov     r0, r5                                 \n\t"
 8000796:	4628      	mov	r0, r5
 8000798:	47a0      	blx	r4
 800079a:	f7ff ff11 	bl	80005c0 <chThdExit>
 800079e:	4770      	bx	lr

080007a0 <__early_init>:
__early_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:234
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __early_init(void) {}
 80007a0:	4770      	bx	lr
	...

080007b0 <__late_init>:
__late_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:246
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 80007b0:	4770      	bx	lr
	...

080007c0 <_default_exit>:
_default_exit():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:257
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak, naked))
#endif
void _default_exit(void) {
 80007c0:	e7fe      	b.n	80007c0 <_default_exit>
	...

080007d0 <ResetHandler>:
ResetHandler():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:274
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 80007d0:	b672      	cpsid	i
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:276
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 80007d2:	4b22      	ldr	r3, [pc, #136]	; (800085c <ResetHandler+0x8c>)
 80007d4:	f383 8809 	msr	PSP, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:296
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 80007d8:	2302      	movs	r3, #2
 80007da:	f383 8814 	msr	CONTROL, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:297
  asm volatile ("isb");
 80007de:	f3bf 8f6f 	isb	sy
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:301

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 80007e2:	4b1f      	ldr	r3, [pc, #124]	; (8000860 <ResetHandler+0x90>)
 80007e4:	4a1d      	ldr	r2, [pc, #116]	; (800085c <ResetHandler+0x8c>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:301 (discriminator 1)
 80007e6:	491f      	ldr	r1, [pc, #124]	; (8000864 <ResetHandler+0x94>)
 80007e8:	428b      	cmp	r3, r1
 80007ea:	d204      	bcs.n	80007f6 <ResetHandler+0x26>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:301 (discriminator 2)
 80007ec:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 80007f0:	f843 1b04 	str.w	r1, [r3], #4
 80007f4:	e7f7      	b.n	80007e6 <ResetHandler+0x16>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:301
 80007f6:	4b1c      	ldr	r3, [pc, #112]	; (8000868 <ResetHandler+0x98>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:304 (discriminator 1)
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 80007f8:	4293      	cmp	r3, r2
 80007fa:	d204      	bcs.n	8000806 <ResetHandler+0x36>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:304 (discriminator 2)
 80007fc:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000800:	f843 1b04 	str.w	r1, [r3], #4
 8000804:	e7f8      	b.n	80007f8 <ResetHandler+0x28>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:310
         &__process_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
#endif

  /* Early initialization hook invocation.*/
  __early_init();
 8000806:	f7ff ffcb 	bl	80007a0 <__early_init>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 800080a:	2300      	movs	r3, #0
 800080c:	4a17      	ldr	r2, [pc, #92]	; (800086c <ResetHandler+0x9c>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:319 (discriminator 1)
 800080e:	4918      	ldr	r1, [pc, #96]	; (8000870 <ResetHandler+0xa0>)
 8000810:	1898      	adds	r0, r3, r2
 8000812:	4288      	cmp	r0, r1
 8000814:	d204      	bcs.n	8000820 <ResetHandler+0x50>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:320
      *dp++ = *tp++;
 8000816:	4917      	ldr	r1, [pc, #92]	; (8000874 <ResetHandler+0xa4>)
 8000818:	5859      	ldr	r1, [r3, r1]
 800081a:	5099      	str	r1, [r3, r2]
 800081c:	3304      	adds	r3, #4
 800081e:	e7f5      	b.n	800080c <ResetHandler+0x3c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000820:	4b15      	ldr	r3, [pc, #84]	; (8000878 <ResetHandler+0xa8>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:326 (discriminator 1)
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000822:	4a16      	ldr	r2, [pc, #88]	; (800087c <ResetHandler+0xac>)
 8000824:	4293      	cmp	r3, r2
 8000826:	d203      	bcs.n	8000830 <ResetHandler+0x60>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:326 (discriminator 2)
 8000828:	2200      	movs	r2, #0
 800082a:	f843 2b04 	str.w	r2, [r3], #4
 800082e:	e7f8      	b.n	8000822 <ResetHandler+0x52>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:330
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 8000830:	f7ff ffbe 	bl	80007b0 <__late_init>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:335

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
 8000834:	4c12      	ldr	r4, [pc, #72]	; (8000880 <ResetHandler+0xb0>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:336 (discriminator 1)
    while (fpp < &__init_array_end) {
 8000836:	4b13      	ldr	r3, [pc, #76]	; (8000884 <ResetHandler+0xb4>)
 8000838:	429c      	cmp	r4, r3
 800083a:	d203      	bcs.n	8000844 <ResetHandler+0x74>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:337
      (*fpp)();
 800083c:	f854 3b04 	ldr.w	r3, [r4], #4
 8000840:	4798      	blx	r3
 8000842:	e7f8      	b.n	8000836 <ResetHandler+0x66>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:344
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000844:	f7ff fc74 	bl	8000130 <main>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:349

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
 8000848:	4c0f      	ldr	r4, [pc, #60]	; (8000888 <ResetHandler+0xb8>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:350 (discriminator 1)
    while (fpp < &__fini_array_end) {
 800084a:	4b10      	ldr	r3, [pc, #64]	; (800088c <ResetHandler+0xbc>)
 800084c:	429c      	cmp	r4, r3
 800084e:	d203      	bcs.n	8000858 <ResetHandler+0x88>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:351
      (*fpp)();
 8000850:	f854 3b04 	ldr.w	r3, [r4], #4
 8000854:	4798      	blx	r3
 8000856:	e7f8      	b.n	800084a <ResetHandler+0x7a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/ARMCMx/crt0.c:358
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000858:	f7ff ffb2 	bl	80007c0 <_default_exit>
 800085c:	20000800 	.word	0x20000800
 8000860:	20000000 	.word	0x20000000
 8000864:	20000400 	.word	0x20000400
 8000868:	20000400 	.word	0x20000400
 800086c:	20000800 	.word	0x20000800
 8000870:	20000800 	.word	0x20000800
 8000874:	08001500 	.word	0x08001500
 8000878:	20000800 	.word	0x20000800
 800087c:	20001030 	.word	0x20001030
 8000880:	080000f4 	.word	0x080000f4
 8000884:	080000f8 	.word	0x080000f8
 8000888:	080000f8 	.word	0x080000f8
 800088c:	080000f8 	.word	0x080000f8

08000890 <halInit>:
halInit():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal.c:70
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
 8000890:	f000 b806 	b.w	80008a0 <hal_lld_init>
	...

080008a0 <hal_lld_init>:
hal_lld_init():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:96
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 80008a0:	4b15      	ldr	r3, [pc, #84]	; (80008f8 <hal_lld_init+0x58>)
 80008a2:	691a      	ldr	r2, [r3, #16]
 80008a4:	f462 4200 	orn	r2, r2, #32768	; 0x8000
 80008a8:	611a      	str	r2, [r3, #16]
 80008aa:	2200      	movs	r2, #0
 80008ac:	611a      	str	r2, [r3, #16]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:97
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80008ae:	6999      	ldr	r1, [r3, #24]
 80008b0:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 80008b4:	6199      	str	r1, [r3, #24]
 80008b6:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:98
  rccResetAPB2(~0);
 80008b8:	6959      	ldr	r1, [r3, #20]
 80008ba:	f04f 31ff 	mov.w	r1, #4294967295
 80008be:	6159      	str	r1, [r3, #20]
 80008c0:	615a      	str	r2, [r3, #20]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:100

  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80008c2:	6a19      	ldr	r1, [r3, #32]
 80008c4:	f041 0101 	orr.w	r1, r1, #1
 80008c8:	6219      	str	r1, [r3, #32]
 80008ca:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80008cc:	f041 0101 	orr.w	r1, r1, #1
 80008d0:	62d9      	str	r1, [r3, #44]	; 0x2c
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:103

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = Clk.AHBFreqHz / CH_FREQUENCY - 1;
 80008d2:	490a      	ldr	r1, [pc, #40]	; (80008fc <hal_lld_init+0x5c>)
 80008d4:	6808      	ldr	r0, [r1, #0]
 80008d6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80008da:	fbb0 f0f1 	udiv	r0, r0, r1
 80008de:	4908      	ldr	r1, [pc, #32]	; (8000900 <hal_lld_init+0x60>)
 80008e0:	3801      	subs	r0, #1
 80008e2:	6048      	str	r0, [r1, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:104
  SysTick->VAL = 0;
 80008e4:	608a      	str	r2, [r1, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:107
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;
 80008e6:	2207      	movs	r2, #7
 80008e8:	600a      	str	r2, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:114
  /* DWT cycle counter enable.*/
//  SCS_DEMCR |= SCS_DEMCR_TRCENA;
//  DWT_CTRL  |= DWT_CTRL_CYCCNTENA;

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80008ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80008ec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80008f0:	625a      	str	r2, [r3, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/hal_lld.cpp:120

  /* Initializes the backup domain.*/
//  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80008f2:	f000 b8f5 	b.w	8000ae0 <dmaInit>
 80008f6:	bf00      	nop
 80008f8:	40023800 	.word	0x40023800
 80008fc:	20000868 	.word	0x20000868
 8000900:	e000e010 	.word	0xe000e010
	...

08000910 <nvicEnableVector>:
nvicEnableVector():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:47
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 8000910:	f000 0203 	and.w	r2, r0, #3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:46
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000914:	b530      	push	{r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:47
  unsigned sh = (n & 3) << 3;
 8000916:	00d2      	lsls	r2, r2, #3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:49

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000918:	24ff      	movs	r4, #255	; 0xff
 800091a:	4094      	lsls	r4, r2
 800091c:	4091      	lsls	r1, r2
 800091e:	f020 0303 	bic.w	r3, r0, #3
 8000922:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8000926:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 800092a:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 800092e:	2201      	movs	r2, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:49
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000930:	ea25 0404 	bic.w	r4, r5, r4
 8000934:	430c      	orrs	r4, r1
 8000936:	f8c3 4300 	str.w	r4, [r3, #768]	; 0x300
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 800093a:	f000 031f 	and.w	r3, r0, #31
 800093e:	fa02 f303 	lsl.w	r3, r2, r3
 8000942:	0940      	lsrs	r0, r0, #5
 8000944:	0080      	lsls	r0, r0, #2
 8000946:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800094a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800094e:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:51
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
 8000952:	6003      	str	r3, [r0, #0]
 8000954:	bd30      	pop	{r4, r5, pc}
	...

08000960 <nvicSetSystemHandlerPriority>:
nvicSetSystemHandlerPriority():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000960:	f020 0303 	bic.w	r3, r0, #3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:75
  unsigned sh = (handler & 3) * 8;
 8000964:	f000 0003 	and.w	r0, r0, #3
 8000968:	00c0      	lsls	r0, r0, #3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:78

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
                           ~(0xFF << sh)) | (prio << sh);
 800096a:	22ff      	movs	r2, #255	; 0xff
 800096c:	4082      	lsls	r2, r0
 800096e:	4081      	lsls	r1, r0
 8000970:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000974:	b510      	push	{r4, lr}
 8000976:	f503 436d 	add.w	r3, r3, #60672	; 0xed00
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:77
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 800097a:	699c      	ldr	r4, [r3, #24]
 800097c:	ea24 0202 	bic.w	r2, r4, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:78
                           ~(0xFF << sh)) | (prio << sh);
 8000980:	430a      	orrs	r2, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/nvic.c:77
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000982:	619a      	str	r2, [r3, #24]
 8000984:	bd10      	pop	{r4, pc}
	...

08000990 <Vector6C>:
Vector6C():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:114
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
 8000990:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:119
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000992:	4b07      	ldr	r3, [pc, #28]	; (80009b0 <Vector6C+0x20>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8000994:	220f      	movs	r2, #15
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000996:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8000998:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:121
  if (dma_isr_redir[0].dma_func)
 800099a:	4a06      	ldr	r2, [pc, #24]	; (80009b4 <Vector6C+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 800099c:	f001 010f 	and.w	r1, r1, #15
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:121
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
 80009a0:	6813      	ldr	r3, [r2, #0]
 80009a2:	b10b      	cbz	r3, 80009a8 <Vector6C+0x18>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:122
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 80009a4:	6850      	ldr	r0, [r2, #4]
 80009a6:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:125

  CH_IRQ_EPILOGUE();
}
 80009a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:124
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80009ac:	f7ff bea0 	b.w	80006f0 <_port_irq_epilogue>
 80009b0:	40026000 	.word	0x40026000
 80009b4:	20000828 	.word	0x20000828
	...

080009c0 <Vector70>:
Vector70():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:132
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
 80009c0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:137
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 80009c2:	4b07      	ldr	r3, [pc, #28]	; (80009e0 <Vector70+0x20>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 80009c4:	22f0      	movs	r2, #240	; 0xf0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 80009c6:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 80009c8:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:139
  if (dma_isr_redir[1].dma_func)
 80009ca:	4a06      	ldr	r2, [pc, #24]	; (80009e4 <Vector70+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 80009cc:	f3c1 1103 	ubfx	r1, r1, #4, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:139
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
 80009d0:	6893      	ldr	r3, [r2, #8]
 80009d2:	b10b      	cbz	r3, 80009d8 <Vector70+0x18>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:140
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 80009d4:	68d0      	ldr	r0, [r2, #12]
 80009d6:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:143

  CH_IRQ_EPILOGUE();
}
 80009d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:142
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80009dc:	f7ff be88 	b.w	80006f0 <_port_irq_epilogue>
 80009e0:	40026000 	.word	0x40026000
 80009e4:	20000828 	.word	0x20000828
	...

080009f0 <Vector74>:
Vector74():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:150
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
 80009f0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:155
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 80009f2:	4b08      	ldr	r3, [pc, #32]	; (8000a14 <Vector74+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 80009f4:	f44f 6270 	mov.w	r2, #3840	; 0xf00
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 80009f8:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 80009fa:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:157
  if (dma_isr_redir[2].dma_func)
 80009fc:	4a06      	ldr	r2, [pc, #24]	; (8000a18 <Vector74+0x28>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 80009fe:	f3c1 2103 	ubfx	r1, r1, #8, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:157
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
 8000a02:	6913      	ldr	r3, [r2, #16]
 8000a04:	b10b      	cbz	r3, 8000a0a <Vector74+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:158
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8000a06:	6950      	ldr	r0, [r2, #20]
 8000a08:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:161

  CH_IRQ_EPILOGUE();
}
 8000a0a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:160
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a0e:	f7ff be6f 	b.w	80006f0 <_port_irq_epilogue>
 8000a12:	bf00      	nop
 8000a14:	40026000 	.word	0x40026000
 8000a18:	20000828 	.word	0x20000828
$d():
 8000a1c:	00000000 	.word	0x00000000

08000a20 <Vector78>:
Vector78():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:168
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
 8000a20:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:173
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000a22:	4b08      	ldr	r3, [pc, #32]	; (8000a44 <Vector78+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8000a24:	f44f 4270 	mov.w	r2, #61440	; 0xf000
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000a28:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8000a2a:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:175
  if (dma_isr_redir[3].dma_func)
 8000a2c:	4a06      	ldr	r2, [pc, #24]	; (8000a48 <Vector78+0x28>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000a2e:	f3c1 3103 	ubfx	r1, r1, #12, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:175
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
 8000a32:	6993      	ldr	r3, [r2, #24]
 8000a34:	b10b      	cbz	r3, 8000a3a <Vector78+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:176
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8000a36:	69d0      	ldr	r0, [r2, #28]
 8000a38:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:179

  CH_IRQ_EPILOGUE();
}
 8000a3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:178
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a3e:	f7ff be57 	b.w	80006f0 <_port_irq_epilogue>
 8000a42:	bf00      	nop
 8000a44:	40026000 	.word	0x40026000
 8000a48:	20000828 	.word	0x20000828
$d():
 8000a4c:	00000000 	.word	0x00000000

08000a50 <Vector7C>:
Vector7C():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:186
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
 8000a50:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:191
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000a52:	4b08      	ldr	r3, [pc, #32]	; (8000a74 <Vector7C+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8000a54:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000a58:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8000a5a:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:193
  if (dma_isr_redir[4].dma_func)
 8000a5c:	4a06      	ldr	r2, [pc, #24]	; (8000a78 <Vector7C+0x28>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000a5e:	f3c1 4103 	ubfx	r1, r1, #16, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:193
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
 8000a62:	6a13      	ldr	r3, [r2, #32]
 8000a64:	b10b      	cbz	r3, 8000a6a <Vector7C+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:194
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8000a66:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8000a68:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:197

  CH_IRQ_EPILOGUE();
}
 8000a6a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:196
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a6e:	f7ff be3f 	b.w	80006f0 <_port_irq_epilogue>
 8000a72:	bf00      	nop
 8000a74:	40026000 	.word	0x40026000
 8000a78:	20000828 	.word	0x20000828
$d():
 8000a7c:	00000000 	.word	0x00000000

08000a80 <Vector80>:
Vector80():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:204
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
 8000a80:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:209
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000a82:	4b08      	ldr	r3, [pc, #32]	; (8000aa4 <Vector80+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 8000a84:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000a88:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 8000a8a:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:211
  if (dma_isr_redir[5].dma_func)
 8000a8c:	4a06      	ldr	r2, [pc, #24]	; (8000aa8 <Vector80+0x28>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000a8e:	f3c1 5103 	ubfx	r1, r1, #20, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:211
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
 8000a92:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8000a94:	b10b      	cbz	r3, 8000a9a <Vector80+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:212
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8000a96:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8000a98:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:215

  CH_IRQ_EPILOGUE();
}
 8000a9a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:214
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000a9e:	f7ff be27 	b.w	80006f0 <_port_irq_epilogue>
 8000aa2:	bf00      	nop
 8000aa4:	40026000 	.word	0x40026000
 8000aa8:	20000828 	.word	0x20000828
$d():
 8000aac:	00000000 	.word	0x00000000

08000ab0 <Vector84>:
Vector84():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:222
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
 8000ab0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:227
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000ab2:	4b08      	ldr	r3, [pc, #32]	; (8000ad4 <Vector84+0x24>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8000ab4:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000ab8:	6819      	ldr	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8000aba:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:229
  if (dma_isr_redir[6].dma_func)
 8000abc:	4a06      	ldr	r2, [pc, #24]	; (8000ad8 <Vector84+0x28>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000abe:	f3c1 6103 	ubfx	r1, r1, #24, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:229
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
 8000ac2:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000ac4:	b10b      	cbz	r3, 8000aca <Vector84+0x1a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:230
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8000ac6:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8000ac8:	4798      	blx	r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:233

  CH_IRQ_EPILOGUE();
}
 8000aca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:232
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000ace:	f7ff be0f 	b.w	80006f0 <_port_irq_epilogue>
 8000ad2:	bf00      	nop
 8000ad4:	40026000 	.word	0x40026000
 8000ad8:	20000828 	.word	0x20000828
$d():
 8000adc:	00000000 	.word	0x00000000

08000ae0 <dmaInit>:
dmaInit():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:247
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8000ae0:	4a09      	ldr	r2, [pc, #36]	; (8000b08 <dmaInit+0x28>)
 8000ae2:	2300      	movs	r3, #0
 8000ae4:	6013      	str	r3, [r2, #0]
 8000ae6:	210c      	movs	r1, #12
 8000ae8:	4359      	muls	r1, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:249 (discriminator 2)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8000aea:	4a08      	ldr	r2, [pc, #32]	; (8000b0c <dmaInit+0x2c>)
 8000aec:	5889      	ldr	r1, [r1, r2]
 8000aee:	2200      	movs	r2, #0
 8000af0:	600a      	str	r2, [r1, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:250 (discriminator 2)
    dma_isr_redir[i].dma_func = NULL;
 8000af2:	4907      	ldr	r1, [pc, #28]	; (8000b10 <dmaInit+0x30>)
 8000af4:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:248 (discriminator 2)
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000af8:	3301      	adds	r3, #1
 8000afa:	2b07      	cmp	r3, #7
 8000afc:	d1f3      	bne.n	8000ae6 <dmaInit+0x6>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/stm32_dma.c:252
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 8000afe:	4b05      	ldr	r3, [pc, #20]	; (8000b14 <dmaInit+0x34>)
 8000b00:	f04f 32ff 	mov.w	r2, #4294967295
 8000b04:	605a      	str	r2, [r3, #4]
 8000b06:	4770      	bx	lr
 8000b08:	20000860 	.word	0x20000860
 8000b0c:	08001450 	.word	0x08001450
 8000b10:	20000828 	.word	0x20000828
 8000b14:	40026000 	.word	0x40026000
	...

08000b20 <_unhandled_exception>:
_unhandled_exception():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../os/hal/vectors.c:169
 * @notapi
 */
#if !defined(__DOXYGEN__)
__attribute__ ((naked))
#endif
void _unhandled_exception(void) {
 8000b20:	e7fe      	b.n	8000b20 <_unhandled_exception>
	...

08000b30 <Clk_t::EnableHSI()>:
_ZN5Clk_t9EnableHSIEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:26
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

uint8_t Clk_t::EnableHSI() {
    RCC->CR |= RCC_CR_HSION;
 8000b30:	4b08      	ldr	r3, [pc, #32]	; (8000b54 <Clk_t::EnableHSI()+0x24>)
 8000b32:	681a      	ldr	r2, [r3, #0]
 8000b34:	f042 0201 	orr.w	r2, r2, #1
 8000b38:	601a      	str	r2, [r3, #0]
 8000b3a:	f44f 63a0 	mov.w	r3, #1280	; 0x500
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:30
    // Wait until ready
    uint32_t StartUpCounter=0;
    do {
        if(RCC->CR & RCC_CR_HSIRDY) return 0;   // HSI is ready
 8000b3e:	4a05      	ldr	r2, [pc, #20]	; (8000b54 <Clk_t::EnableHSI()+0x24>)
 8000b40:	6812      	ldr	r2, [r2, #0]
 8000b42:	0792      	lsls	r2, r2, #30
 8000b44:	d403      	bmi.n	8000b4e <Clk_t::EnableHSI()+0x1e>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:29

uint8_t Clk_t::EnableHSI() {
    RCC->CR |= RCC_CR_HSION;
    // Wait until ready
    uint32_t StartUpCounter=0;
    do {
 8000b46:	3b01      	subs	r3, #1
 8000b48:	d1f9      	bne.n	8000b3e <Clk_t::EnableHSI()+0xe>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:33
        if(RCC->CR & RCC_CR_HSIRDY) return 0;   // HSI is ready
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
 8000b4a:	2001      	movs	r0, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:34
}
 8000b4c:	4770      	bx	lr
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:30
uint8_t Clk_t::EnableHSI() {
    RCC->CR |= RCC_CR_HSION;
    // Wait until ready
    uint32_t StartUpCounter=0;
    do {
        if(RCC->CR & RCC_CR_HSIRDY) return 0;   // HSI is ready
 8000b4e:	2000      	movs	r0, #0
 8000b50:	4770      	bx	lr
 8000b52:	bf00      	nop
 8000b54:	40023800 	.word	0x40023800
	...

08000b60 <Clk_t::UpdateFreqValues()>:
_ZN5Clk_t16UpdateFreqValuesEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8000b60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b62:	b093      	sub	sp, #76	; 0x4c
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000b64:	2100      	movs	r1, #0
 8000b66:	2220      	movs	r2, #32
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8000b68:	4605      	mov	r5, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000b6a:	a80a      	add	r0, sp, #40	; 0x28
 8000b6c:	f000 fb98 	bl	80012a0 <memset>
 8000b70:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000b74:	930a      	str	r3, [sp, #40]	; 0x28
 8000b76:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000b7a:	930b      	str	r3, [sp, #44]	; 0x2c
 8000b7c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000b80:	930c      	str	r3, [sp, #48]	; 0x30
 8000b82:	4b34      	ldr	r3, [pc, #208]	; (8000c54 <Clk_t::UpdateFreqValues()+0xf4>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000b84:	4a34      	ldr	r2, [pc, #208]	; (8000c58 <Clk_t::UpdateFreqValues()+0xf8>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000b86:	930d      	str	r3, [sp, #52]	; 0x34
 8000b88:	4b34      	ldr	r3, [pc, #208]	; (8000c5c <Clk_t::UpdateFreqValues()+0xfc>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000b8a:	6851      	ldr	r1, [r2, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000b8c:	930e      	str	r3, [sp, #56]	; 0x38
 8000b8e:	4b34      	ldr	r3, [pc, #208]	; (8000c60 <Clk_t::UpdateFreqValues()+0x100>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000b90:	6810      	ldr	r0, [r2, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000b92:	930f      	str	r3, [sp, #60]	; 0x3c
 8000b94:	4b33      	ldr	r3, [pc, #204]	; (8000c64 <Clk_t::UpdateFreqValues()+0x104>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:64
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8000b96:	ae06      	add	r6, sp, #24
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000b98:	9310      	str	r3, [sp, #64]	; 0x40
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000b9a:	ab03      	add	r3, sp, #12
 8000b9c:	c303      	stmia	r3!, {r0, r1}
 8000b9e:	7a11      	ldrb	r1, [r2, #8]
 8000ba0:	7019      	strb	r1, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:64
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8000ba2:	f102 0309 	add.w	r3, r2, #9
 8000ba6:	3219      	adds	r2, #25
 8000ba8:	4617      	mov	r7, r2
 8000baa:	6818      	ldr	r0, [r3, #0]
 8000bac:	6859      	ldr	r1, [r3, #4]
 8000bae:	4634      	mov	r4, r6
 8000bb0:	c403      	stmia	r4!, {r0, r1}
 8000bb2:	3308      	adds	r3, #8
 8000bb4:	4293      	cmp	r3, r2
 8000bb6:	4626      	mov	r6, r4
 8000bb8:	d1f7      	bne.n	8000baa <Clk_t::UpdateFreqValues()+0x4a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:65
    const uint8_t APBPrescTable[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8000bba:	6838      	ldr	r0, [r7, #0]
 8000bbc:	6879      	ldr	r1, [r7, #4]
 8000bbe:	ab01      	add	r3, sp, #4
 8000bc0:	c303      	stmia	r3!, {r0, r1}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:68

    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000bc2:	4b29      	ldr	r3, [pc, #164]	; (8000c68 <Clk_t::UpdateFreqValues()+0x108>)
 8000bc4:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:69
    tmp >>= 2;
 8000bc6:	f3c2 0281 	ubfx	r2, r2, #2, #2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:70
    switch(tmp) {
 8000bca:	2a02      	cmp	r2, #2
 8000bcc:	d024      	beq.n	8000c18 <Clk_t::UpdateFreqValues()+0xb8>
 8000bce:	2a03      	cmp	r2, #3
 8000bd0:	d00c      	beq.n	8000bec <Clk_t::UpdateFreqValues()+0x8c>
 8000bd2:	2a01      	cmp	r2, #1
 8000bd4:	d101      	bne.n	8000bda <Clk_t::UpdateFreqValues()+0x7a>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:77
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
            SysClkHz = MSIClk[tmp];
            break;

        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
 8000bd6:	4b25      	ldr	r3, [pc, #148]	; (8000c6c <Clk_t::UpdateFreqValues()+0x10c>)
 8000bd8:	e01f      	b.n	8000c1a <Clk_t::UpdateFreqValues()+0xba>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8000bda:	685b      	ldr	r3, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8000bdc:	a812      	add	r0, sp, #72	; 0x48
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8000bde:	f3c3 3342 	ubfx	r3, r3, #13, #3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8000be2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8000be6:	f853 3c20 	ldr.w	r3, [r3, #-32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:74
            break;
 8000bea:	e016      	b.n	8000c1a <Clk_t::UpdateFreqValues()+0xba>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8000bec:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8000bee:	a912      	add	r1, sp, #72	; 0x48
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8000bf0:	f3c2 4283 	ubfx	r2, r2, #18, #4
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8000bf4:	440a      	add	r2, r1
 8000bf6:	f812 1c3c 	ldrb.w	r1, [r2, #-60]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:88
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000bfa:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8000bfc:	689b      	ldr	r3, [r3, #8]
 8000bfe:	481c      	ldr	r0, [pc, #112]	; (8000c70 <Clk_t::UpdateFreqValues()+0x110>)
 8000c00:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8000c04:	4b19      	ldr	r3, [pc, #100]	; (8000c6c <Clk_t::UpdateFreqValues()+0x10c>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000c06:	f3c2 5281 	ubfx	r2, r2, #22, #2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8000c0a:	bf18      	it	ne
 8000c0c:	4603      	movne	r3, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:91
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8000c0e:	434b      	muls	r3, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000c10:	3201      	adds	r2, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:91
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8000c12:	fbb3 f3f2 	udiv	r3, r3, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:92
            break;
 8000c16:	e000      	b.n	8000c1a <Clk_t::UpdateFreqValues()+0xba>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:81
        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
            break;

        case 0b10: // HSE
            SysClkHz = CRYSTAL_FREQ_HZ;
 8000c18:	4b15      	ldr	r3, [pc, #84]	; (8000c70 <Clk_t::UpdateFreqValues()+0x110>)
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:96
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
            break;
    } // switch

    // AHB freq
    tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000c1a:	4a13      	ldr	r2, [pc, #76]	; (8000c68 <Clk_t::UpdateFreqValues()+0x108>)
 8000c1c:	a812      	add	r0, sp, #72	; 0x48
 8000c1e:	6891      	ldr	r1, [r2, #8]
 8000c20:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8000c24:	4401      	add	r1, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:97
    AHBFreqHz = SysClkHz >> tmp;
 8000c26:	f811 1c30 	ldrb.w	r1, [r1, #-48]
 8000c2a:	40cb      	lsrs	r3, r1
 8000c2c:	602b      	str	r3, [r5, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:99
    // APB freq
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> 8];
 8000c2e:	6891      	ldr	r1, [r2, #8]
 8000c30:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8000c34:	4401      	add	r1, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:100
    APB1FreqHz = AHBFreqHz >> tmp;
 8000c36:	f811 1c44 	ldrb.w	r1, [r1, #-68]
 8000c3a:	fa23 f101 	lsr.w	r1, r3, r1
 8000c3e:	6069      	str	r1, [r5, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:101
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> 11];
 8000c40:	6892      	ldr	r2, [r2, #8]
 8000c42:	f3c2 22c2 	ubfx	r2, r2, #11, #3
 8000c46:	4402      	add	r2, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:102
    APB2FreqHz = AHBFreqHz >> tmp;
 8000c48:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 8000c4c:	40d3      	lsrs	r3, r2
 8000c4e:	60ab      	str	r3, [r5, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:103
}
 8000c50:	b013      	add	sp, #76	; 0x4c
 8000c52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c54:	0007ff9c 	.word	0x0007ff9c
 8000c58:	08001340 	.word	0x08001340
 8000c5c:	000ffdc0 	.word	0x000ffdc0
 8000c60:	001fff68 	.word	0x001fff68
 8000c64:	003ffed0 	.word	0x003ffed0
 8000c68:	40023800 	.word	0x40023800
 8000c6c:	00f42400 	.word	0x00f42400
 8000c70:	007a1200 	.word	0x007a1200
	...

08000c80 <Clk_t::SwitchToHSI()>:
_ZN5Clk_t11SwitchToHSIEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:118
    tmp |= ((uint32_t)APB2Div) << 11;
    RCC->CFGR = tmp;
}

// Enables HSI, switches to HSI
uint8_t Clk_t::SwitchToHSI() {
 8000c80:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:119
    if(EnableHSI() != 0) return 1;
 8000c82:	f7ff ff55 	bl	8000b30 <Clk_t::EnableHSI()>
 8000c86:	b960      	cbnz	r0, 8000ca2 <Clk_t::SwitchToHSI()+0x22>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:120
    uint32_t tmp = RCC->CFGR;
 8000c88:	4b07      	ldr	r3, [pc, #28]	; (8000ca8 <Clk_t::SwitchToHSI()+0x28>)
 8000c8a:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:121
    tmp &= ~RCC_CFGR_SW;
 8000c8c:	f022 0203 	bic.w	r2, r2, #3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:122
    tmp |=  RCC_CFGR_SW_HSI;  // Select HSI as system clock src
 8000c90:	f042 0201 	orr.w	r2, r2, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:123
    RCC->CFGR = tmp;
 8000c94:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:124 (discriminator 1)
    while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI); // Wait till ready
 8000c96:	689a      	ldr	r2, [r3, #8]
 8000c98:	f002 020c 	and.w	r2, r2, #12
 8000c9c:	2a04      	cmp	r2, #4
 8000c9e:	d1fa      	bne.n	8000c96 <Clk_t::SwitchToHSI()+0x16>
 8000ca0:	bd08      	pop	{r3, pc}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:119
    RCC->CFGR = tmp;
}

// Enables HSI, switches to HSI
uint8_t Clk_t::SwitchToHSI() {
    if(EnableHSI() != 0) return 1;
 8000ca2:	2001      	movs	r0, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:126
    tmp &= ~RCC_CFGR_SW;
    tmp |=  RCC_CFGR_SW_HSI;  // Select HSI as system clock src
    RCC->CFGR = tmp;
    while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI); // Wait till ready
    return 0;
}
 8000ca4:	bd08      	pop	{r3, pc}
 8000ca6:	bf00      	nop
 8000ca8:	40023800 	.word	0x40023800
$d():
 8000cac:	00000000 	.word	0x00000000

08000cb0 <SetupVCore(VCore_t)>:
_Z10SetupVCore7VCore_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:198

// =============================== V Core ======================================
VCore_t VCore;
void SetupVCore(VCore_t AVCore) {
    // PWR clock enable
    RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000cb0:	4b09      	ldr	r3, [pc, #36]	; (8000cd8 <SetupVCore(VCore_t)+0x28>)
 8000cb2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000cb6:	625a      	str	r2, [r3, #36]	; 0x24
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:200 (discriminator 1)
    // Core voltage setup
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8000cb8:	4b08      	ldr	r3, [pc, #32]	; (8000cdc <SetupVCore(VCore_t)+0x2c>)
 8000cba:	685a      	ldr	r2, [r3, #4]
 8000cbc:	06d1      	lsls	r1, r2, #27
 8000cbe:	d4fb      	bmi.n	8000cb8 <SetupVCore(VCore_t)+0x8>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:201
    uint32_t tmp = PWR->CR;
 8000cc0:	681a      	ldr	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:202
    tmp &= ~PWR_CR_VOS;
 8000cc2:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:203
    tmp |= ((uint32_t)AVCore) << 11;
 8000cc6:	ea42 22c0 	orr.w	r2, r2, r0, lsl #11
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:204
    PWR->CR = tmp;
 8000cca:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:205 (discriminator 1)
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8000ccc:	685a      	ldr	r2, [r3, #4]
 8000cce:	06d2      	lsls	r2, r2, #27
 8000cd0:	d4fc      	bmi.n	8000ccc <SetupVCore(VCore_t)+0x1c>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/clocking_L1xx.cpp:206
    VCore = AVCore;
 8000cd2:	4b03      	ldr	r3, [pc, #12]	; (8000ce0 <SetupVCore(VCore_t)+0x30>)
 8000cd4:	7018      	strb	r0, [r3, #0]
 8000cd6:	4770      	bx	lr
 8000cd8:	40023800 	.word	0x40023800
 8000cdc:	40007000 	.word	0x40007000
 8000ce0:	20000864 	.word	0x20000864
	...

08000cf0 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>:
_ZN9CmdUart_t8PrintNowEPKc():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/cmd_uart.h:98
#endif
public:
    void Printf(const char *S, ...);
    void PrintfI(const char *S, ...);
    void FlushTx() { while(!IDmaIsIdle); }  // wait DMA
    void PrintNow(const char *S) {
 8000cf0:	3801      	subs	r0, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/cmd_uart.h:99
        while(*S != 0) {
 8000cf2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8000cf6:	b12b      	cbz	r3, 8000d04 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x14>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/cmd_uart.h:100
            while(!(UART->SR & USART_SR_TXE));
 8000cf8:	4a03      	ldr	r2, [pc, #12]	; (8000d08 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x18>)
 8000cfa:	8811      	ldrh	r1, [r2, #0]
 8000cfc:	0609      	lsls	r1, r1, #24
 8000cfe:	d5fb      	bpl.n	8000cf8 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x8>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/cmd_uart.h:101
            UART->DR = *S++;
 8000d00:	8093      	strh	r3, [r2, #4]
 8000d02:	e7f6      	b.n	8000cf2 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x2>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/cmd_uart.h:103
        }
    }
 8000d04:	4770      	bx	lr
 8000d06:	bf00      	nop
 8000d08:	40013800 	.word	0x40013800
$d():
 8000d0c:	00000000 	.word	0x00000000

08000d10 <chDbgPanic>:
chDbgPanic():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.cpp:144
    Tim->PSC = (uint16_t)FPrescaler;
}
#endif

#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
 8000d10:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.cpp:145
    Uart.PrintNow(msg1);
 8000d12:	f7ff ffed 	bl	8000cf0 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.cpp:146
    Uart.PrintNow(" @");
 8000d16:	4806      	ldr	r0, [pc, #24]	; (8000d30 <chDbgPanic+0x20>)
 8000d18:	f7ff ffea 	bl	8000cf0 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.cpp:147
    Uart.PrintNow(chThdSelf()->p_name);
 8000d1c:	4b05      	ldr	r3, [pc, #20]	; (8000d34 <chDbgPanic+0x24>)
 8000d1e:	699b      	ldr	r3, [r3, #24]
 8000d20:	6998      	ldr	r0, [r3, #24]
 8000d22:	f7ff ffe5 	bl	8000cf0 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.cpp:149
    Uart.PrintNow("\r");
}
 8000d26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.cpp:148
#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
    Uart.PrintNow(msg1);
    Uart.PrintNow(" @");
    Uart.PrintNow(chThdSelf()->p_name);
    Uart.PrintNow("\r");
 8000d2a:	4803      	ldr	r0, [pc, #12]	; (8000d38 <chDbgPanic+0x28>)
 8000d2c:	f7ff bfe0 	b.w	8000cf0 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
 8000d30:	080014b0 	.word	0x080014b0
 8000d34:	20000f64 	.word	0x20000f64
 8000d38:	080014b3 	.word	0x080014b3
$d():
 8000d3c:	00000000 	.word	0x00000000

08000d40 <cc1101_t::BusyWait() [clone .isra.6]>:
PinIsSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:179
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 8000d40:	4b02      	ldr	r3, [pc, #8]	; (8000d4c <cc1101_t::BusyWait() [clone .isra.6]+0xc>)
 8000d42:	8a1b      	ldrh	r3, [r3, #16]
_ZN8cc1101_t8BusyWaitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:37
 8000d44:	065b      	lsls	r3, r3, #25
 8000d46:	d4fb      	bmi.n	8000d40 <cc1101_t::BusyWait() [clone .isra.6]>
 8000d48:	4770      	bx	lr
 8000d4a:	bf00      	nop
 8000d4c:	40020000 	.word	0x40020000

08000d50 <Spi_t::ReadWriteByte(unsigned char)>:
_ZN5Spi_t13ReadWriteByteEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:479
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
    void Disable() { PSpi->CR1 &= ~SPI_CR1_SPE; }
    void EnableTxDma() { PSpi->CR2 |= SPI_CR2_TXDMAEN; }
    void WaitBsyHi2Lo() { while(PSpi->SR & SPI_SR_BSY); }
    uint8_t ReadWriteByte(uint8_t AByte) {
        PSpi->DR = AByte;
 8000d50:	6803      	ldr	r3, [r0, #0]
 8000d52:	8199      	strh	r1, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:480 (discriminator 1)
        while(!(PSpi->SR & SPI_SR_RXNE));  // Wait for SPI transmission to complete
 8000d54:	891a      	ldrh	r2, [r3, #8]
 8000d56:	07d2      	lsls	r2, r2, #31
 8000d58:	d5fc      	bpl.n	8000d54 <Spi_t::ReadWriteByte(unsigned char)+0x4>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:481
        return PSpi->DR;
 8000d5a:	8998      	ldrh	r0, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:482
    }
 8000d5c:	b2c0      	uxtb	r0, r0
 8000d5e:	4770      	bx	lr

08000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>:
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:145
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister (uint8_t ARegAddr, uint8_t AData){
 8000d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000d64:	4c09      	ldr	r4, [pc, #36]	; (8000d8c <cc1101_t::WriteRegister(unsigned char, unsigned char)+0x2c>)
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:145
 8000d66:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
 8000d68:	2510      	movs	r5, #16
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:145
 8000d6a:	4688      	mov	r8, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:148
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 8000d6c:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
 8000d6e:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t13WriteRegisterEhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:145
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister (uint8_t ARegAddr, uint8_t AData){
 8000d70:	4617      	mov	r7, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:147
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
 8000d72:	f7ff ffe5 	bl	8000d40 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:148
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 8000d76:	4641      	mov	r1, r8
 8000d78:	4630      	mov	r0, r6
 8000d7a:	f7ff ffe9 	bl	8000d50 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:149
    ISpi.ReadWriteByte(AData);      // Write data
 8000d7e:	4630      	mov	r0, r6
 8000d80:	4639      	mov	r1, r7
 8000d82:	f7ff ffe5 	bl	8000d50 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000d86:	8325      	strh	r5, [r4, #24]
 8000d88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d8c:	40020000 	.word	0x40020000

08000d90 <cc1101_t::WriteStrobe(unsigned char)>:
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:152
    CsHi();                         // End transmission
}
void cc1101_t::WriteStrobe (uint8_t AStrobe){
 8000d90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000d92:	4d09      	ldr	r5, [pc, #36]	; (8000db8 <cc1101_t::WriteStrobe(unsigned char)+0x28>)
 8000d94:	2610      	movs	r6, #16
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:152
 8000d96:	4604      	mov	r4, r0
 8000d98:	460f      	mov	r7, r1
_ZN8cc1101_t4CsLoEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
 8000d9a:	836e      	strh	r6, [r5, #26]
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:154
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 8000d9c:	f7ff ffd0 	bl	8000d40 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:155
    IState = ISpi.ReadWriteByte(AStrobe);   // Write strobe
 8000da0:	f104 0008 	add.w	r0, r4, #8
 8000da4:	4639      	mov	r1, r7
 8000da6:	f7ff ffd3 	bl	8000d50 <Spi_t::ReadWriteByte(unsigned char)>
 8000daa:	7020      	strb	r0, [r4, #0]
PinSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000dac:	832e      	strh	r6, [r5, #24]
_ZN8cc1101_t11WriteStrobeEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:157
    CsHi();                                 // End transmission
    IState &= 0b01110000;                   // Mask needed bits
 8000dae:	7823      	ldrb	r3, [r4, #0]
 8000db0:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000db4:	7023      	strb	r3, [r4, #0]
 8000db6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000db8:	40020000 	.word	0x40020000
$d():
 8000dbc:	00000000 	.word	0x00000000

08000dc0 <cc1101_t::EnterIdle()>:
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:64
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 8000dc0:	b510      	push	{r4, lr}
 8000dc2:	2136      	movs	r1, #54	; 0x36
 8000dc4:	4604      	mov	r4, r0
 8000dc6:	f7ff ffe3 	bl	8000d90 <cc1101_t::WriteStrobe(unsigned char)>
 8000dca:	2300      	movs	r3, #0
 8000dcc:	7623      	strb	r3, [r4, #24]
 8000dce:	bd10      	pop	{r4, pc}

08000dd0 <cc1101_t::SetChannel(unsigned char)>:
_ZN8cc1101_t10SetChannelEh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:40
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIrq(IRQ_PRIO_MEDIUM);
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
 8000dd0:	b538      	push	{r3, r4, r5, lr}
 8000dd2:	4604      	mov	r4, r0
 8000dd4:	460d      	mov	r5, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:41 (discriminator 1)
    while(IState != CC_STB_IDLE) EnterIdle();   // CC must be in IDLE mode
 8000dd6:	7823      	ldrb	r3, [r4, #0]
 8000dd8:	4620      	mov	r0, r4
 8000dda:	b113      	cbz	r3, 8000de2 <cc1101_t::SetChannel(unsigned char)+0x12>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:41 (discriminator 2)
 8000ddc:	f7ff fff0 	bl	8000dc0 <cc1101_t::EnterIdle()>
 8000de0:	e7f9      	b.n	8000dd6 <cc1101_t::SetChannel(unsigned char)+0x6>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:42
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 8000de2:	462a      	mov	r2, r5
 8000de4:	210a      	movs	r1, #10
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:43
}
 8000de6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:42
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
    while(IState != CC_STB_IDLE) EnterIdle();   // CC must be in IDLE mode
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 8000dea:	f7ff bfb9 	b.w	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

08000df0 <cc1101_t::WriteTX(unsigned char*, unsigned char)>:
_ZN8cc1101_t7WriteTXEPhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:160
    IState = ISpi.ReadWriteByte(AStrobe);   // Write strobe
    CsHi();                                 // End transmission
    IState &= 0b01110000;                   // Mask needed bits
}

void cc1101_t::WriteTX(uint8_t* Ptr, uint8_t Length) {
 8000df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000df2:	4b0d      	ldr	r3, [pc, #52]	; (8000e28 <cc1101_t::WriteTX(unsigned char*, unsigned char)+0x38>)
_ZN8cc1101_t7WriteTXEPhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:160
 8000df4:	4605      	mov	r5, r0
 8000df6:	4616      	mov	r6, r2
PinClear():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:176
 8000df8:	2210      	movs	r2, #16
 8000dfa:	835a      	strh	r2, [r3, #26]
_ZN8cc1101_t7WriteTXEPhh():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:163
    CsLo();                                                 // Start transmission
    BusyWait();                                             // Wait for chip to become ready
    ISpi.ReadWriteByte(CC_FIFO|CC_WRITE_FLAG|CC_BURST_FLAG);// Address with write & burst flags
 8000dfc:	3508      	adds	r5, #8
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:160
    IState = ISpi.ReadWriteByte(AStrobe);   // Write strobe
    CsHi();                                 // End transmission
    IState &= 0b01110000;                   // Mask needed bits
}

void cc1101_t::WriteTX(uint8_t* Ptr, uint8_t Length) {
 8000dfe:	460f      	mov	r7, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:162
    CsLo();                                                 // Start transmission
    BusyWait();                                             // Wait for chip to become ready
 8000e00:	f7ff ff9e 	bl	8000d40 <cc1101_t::BusyWait() [clone .isra.6]>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:163
    ISpi.ReadWriteByte(CC_FIFO|CC_WRITE_FLAG|CC_BURST_FLAG);// Address with write & burst flags
 8000e04:	4628      	mov	r0, r5
 8000e06:	217f      	movs	r1, #127	; 0x7f
 8000e08:	f7ff ffa2 	bl	8000d50 <Spi_t::ReadWriteByte(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:166
    uint8_t b;
    //Uart.Printf("TX: ");
    for (uint8_t i=0; i<Length; i++) {
 8000e0c:	2400      	movs	r4, #0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:166 (discriminator 1)
 8000e0e:	b2e3      	uxtb	r3, r4
 8000e10:	42b3      	cmp	r3, r6
 8000e12:	d205      	bcs.n	8000e20 <cc1101_t::WriteTX(unsigned char*, unsigned char)+0x30>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:168 (discriminator 2)
        b = *Ptr++;
        ISpi.ReadWriteByte(b);  // Write bytes
 8000e14:	5d39      	ldrb	r1, [r7, r4]
 8000e16:	4628      	mov	r0, r5
 8000e18:	f7ff ff9a 	bl	8000d50 <Spi_t::ReadWriteByte(unsigned char)>
 8000e1c:	3401      	adds	r4, #1
 8000e1e:	e7f6      	b.n	8000e0e <cc1101_t::WriteTX(unsigned char*, unsigned char)+0x1e>
PinSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000e20:	4b01      	ldr	r3, [pc, #4]	; (8000e28 <cc1101_t::WriteTX(unsigned char*, unsigned char)+0x38>)
 8000e22:	2210      	movs	r2, #16
 8000e24:	831a      	strh	r2, [r3, #24]
 8000e26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e28:	40020000 	.word	0x40020000
$d():
 8000e2c:	00000000 	.word	0x00000000

08000e30 <cc1101_t::TransmitSync(rPkt_t*)>:
_ZN8cc1101_t12TransmitSyncEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:55
//        //Uart.Printf("C");
//    }
//    //Uart.Printf("\r");
//}

void cc1101_t::TransmitSync(rPkt_t *pPkt) {
 8000e30:	b538      	push	{r3, r4, r5, lr}
 8000e32:	4604      	mov	r4, r0
 8000e34:	460d      	mov	r5, r1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:57 (discriminator 1)
    // WaitUntilChannelIsBusy();   // If this is not done, time after time FIFO is destroyed
    while(IState != CC_STB_IDLE) EnterIdle();
 8000e36:	7823      	ldrb	r3, [r4, #0]
 8000e38:	4620      	mov	r0, r4
 8000e3a:	b113      	cbz	r3, 8000e42 <cc1101_t::TransmitSync(rPkt_t*)+0x12>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:57 (discriminator 2)
 8000e3c:	f7ff ffc0 	bl	8000dc0 <cc1101_t::EnterIdle()>
 8000e40:	e7f9      	b.n	8000e36 <cc1101_t::TransmitSync(rPkt_t*)+0x6>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:58
    WriteTX((uint8_t*)pPkt, RPKT_LEN);
 8000e42:	4629      	mov	r1, r5
 8000e44:	2201      	movs	r2, #1
 8000e46:	f7ff ffd3 	bl	8000df0 <cc1101_t::WriteTX(unsigned char*, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:60
    // Enter TX and wait IRQ
    chSysLock();
 8000e4a:	2320      	movs	r3, #32
 8000e4c:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:61
    PWaitingThread = chThdSelf();
 8000e50:	4b06      	ldr	r3, [pc, #24]	; (8000e6c <cc1101_t::TransmitSync(rPkt_t*)+0x3c>)
_ZN8cc1101_t7EnterTXEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:49
    uint8_t ReadRegister (const uint8_t Addr);
    void WriteStrobe(uint8_t AStrobe);
    void WriteTX(uint8_t* Ptr, uint8_t Length);
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
 8000e52:	4620      	mov	r0, r4
_ZN8cc1101_t12TransmitSyncEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:61
 8000e54:	699b      	ldr	r3, [r3, #24]
_ZN8cc1101_t7EnterTXEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:49
 8000e56:	2135      	movs	r1, #53	; 0x35
_ZN8cc1101_t12TransmitSyncEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:61
 8000e58:	6063      	str	r3, [r4, #4]
_ZN8cc1101_t7EnterTXEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:49
 8000e5a:	f7ff ff99 	bl	8000d90 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t12TransmitSyncEP6rPkt_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:63
    EnterTX();
    chSchGoSleepS(THD_STATE_SUSPENDED);
 8000e5e:	2002      	movs	r0, #2
 8000e60:	f7ff fa26 	bl	80002b0 <chSchGoSleepS>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:64
    chSysUnlock();  // Will be here when IRQ fires
 8000e64:	2300      	movs	r3, #0
 8000e66:	f383 8811 	msr	BASEPRI, r3
 8000e6a:	bd38      	pop	{r3, r4, r5, pc}
 8000e6c:	20000f64 	.word	0x20000f64

08000e70 <cc1101_t::RfConfig()>:
_ZN8cc1101_t8RfConfigEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:176
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 8000e70:	b510      	push	{r4, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:177
    WriteRegister(CC_FSCTRL1,  CC_FSCTRL1_VALUE);    // Frequency synthesizer control.
 8000e72:	210b      	movs	r1, #11
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:176
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 8000e74:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:177
    WriteRegister(CC_FSCTRL1,  CC_FSCTRL1_VALUE);    // Frequency synthesizer control.
 8000e76:	220c      	movs	r2, #12
 8000e78:	f7ff ff72 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:178
    WriteRegister(CC_FSCTRL0,  CC_FSCTRL0_VALUE);    // Frequency synthesizer control.
 8000e7c:	4620      	mov	r0, r4
 8000e7e:	210c      	movs	r1, #12
 8000e80:	2200      	movs	r2, #0
 8000e82:	f7ff ff6d 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:179
    WriteRegister(CC_FREQ2,    CC_FREQ2_VALUE);      // Frequency control word, high byte.
 8000e86:	4620      	mov	r0, r4
 8000e88:	210d      	movs	r1, #13
 8000e8a:	2220      	movs	r2, #32
 8000e8c:	f7ff ff68 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:180
    WriteRegister(CC_FREQ1,    CC_FREQ1_VALUE);      // Frequency control word, middle byte.
 8000e90:	4620      	mov	r0, r4
 8000e92:	210e      	movs	r1, #14
 8000e94:	2225      	movs	r2, #37	; 0x25
 8000e96:	f7ff ff63 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:181
    WriteRegister(CC_FREQ0,    CC_FREQ0_VALUE);      // Frequency control word, low byte.
 8000e9a:	4620      	mov	r0, r4
 8000e9c:	210f      	movs	r1, #15
 8000e9e:	22ed      	movs	r2, #237	; 0xed
 8000ea0:	f7ff ff5e 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:182
    WriteRegister(CC_MDMCFG4,  CC_MDMCFG4_VALUE);    // Modem configuration.
 8000ea4:	4620      	mov	r0, r4
 8000ea6:	2110      	movs	r1, #16
 8000ea8:	222d      	movs	r2, #45	; 0x2d
 8000eaa:	f7ff ff59 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:183
    WriteRegister(CC_MDMCFG3,  CC_MDMCFG3_VALUE);    // Modem configuration.
 8000eae:	4620      	mov	r0, r4
 8000eb0:	2111      	movs	r1, #17
 8000eb2:	222f      	movs	r2, #47	; 0x2f
 8000eb4:	f7ff ff54 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:184
    WriteRegister(CC_MDMCFG2,  CC_MDMCFG2_VALUE);    // Modem configuration.
 8000eb8:	4620      	mov	r0, r4
 8000eba:	2112      	movs	r1, #18
 8000ebc:	2213      	movs	r2, #19
 8000ebe:	f7ff ff4f 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:185
    WriteRegister(CC_MDMCFG1,  CC_MDMCFG1_VALUE);    // Modem configuration.
 8000ec2:	4620      	mov	r0, r4
 8000ec4:	2113      	movs	r1, #19
 8000ec6:	2222      	movs	r2, #34	; 0x22
 8000ec8:	f7ff ff4a 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:186
    WriteRegister(CC_MDMCFG0,  CC_MDMCFG0_VALUE);    // Modem configuration.
 8000ecc:	4620      	mov	r0, r4
 8000ece:	2114      	movs	r1, #20
 8000ed0:	22e5      	movs	r2, #229	; 0xe5
 8000ed2:	f7ff ff45 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:187
    WriteRegister(CC_CHANNR,   CC_CHANNR_VALUE);     // Channel number.
 8000ed6:	4620      	mov	r0, r4
 8000ed8:	210a      	movs	r1, #10
 8000eda:	2200      	movs	r2, #0
 8000edc:	f7ff ff40 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:188
    WriteRegister(CC_DEVIATN,  CC_DEVIATN_VALUE);    // Modem deviation setting (when FSK modulation is enabled).
 8000ee0:	4620      	mov	r0, r4
 8000ee2:	2115      	movs	r1, #21
 8000ee4:	2262      	movs	r2, #98	; 0x62
 8000ee6:	f7ff ff3b 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:189
    WriteRegister(CC_FREND1,   CC_FREND1_VALUE);     // Front end RX configuration.
 8000eea:	4620      	mov	r0, r4
 8000eec:	2121      	movs	r1, #33	; 0x21
 8000eee:	22b6      	movs	r2, #182	; 0xb6
 8000ef0:	f7ff ff36 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:190
    WriteRegister(CC_FREND0,   CC_FREND0_VALUE);     // Front end RX configuration.
 8000ef4:	4620      	mov	r0, r4
 8000ef6:	2122      	movs	r1, #34	; 0x22
 8000ef8:	2210      	movs	r2, #16
 8000efa:	f7ff ff31 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:191
    WriteRegister(CC_MCSM0,    CC_MCSM0_VALUE);      // Main Radio Control State Machine configuration.
 8000efe:	4620      	mov	r0, r4
 8000f00:	2118      	movs	r1, #24
 8000f02:	2208      	movs	r2, #8
 8000f04:	f7ff ff2c 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:192
    WriteRegister(CC_FOCCFG,   CC_FOCCFG_VALUE);     // Frequency Offset Compensation Configuration.
 8000f08:	4620      	mov	r0, r4
 8000f0a:	2119      	movs	r1, #25
 8000f0c:	221d      	movs	r2, #29
 8000f0e:	f7ff ff27 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:193
    WriteRegister(CC_BSCFG,    CC_BSCFG_VALUE);      // Bit synchronization Configuration.
 8000f12:	4620      	mov	r0, r4
 8000f14:	211a      	movs	r1, #26
 8000f16:	221c      	movs	r2, #28
 8000f18:	f7ff ff22 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:194
    WriteRegister(CC_AGCCTRL2, CC_AGCCTRL2_VALUE);   // AGC control.
 8000f1c:	4620      	mov	r0, r4
 8000f1e:	211b      	movs	r1, #27
 8000f20:	22c7      	movs	r2, #199	; 0xc7
 8000f22:	f7ff ff1d 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:195
    WriteRegister(CC_AGCCTRL1, CC_AGCCTRL1_VALUE);   // AGC control.
 8000f26:	4620      	mov	r0, r4
 8000f28:	211c      	movs	r1, #28
 8000f2a:	2200      	movs	r2, #0
 8000f2c:	f7ff ff18 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:196
    WriteRegister(CC_AGCCTRL0, CC_AGCCTRL0_VALUE);   // AGC control.
 8000f30:	4620      	mov	r0, r4
 8000f32:	211d      	movs	r1, #29
 8000f34:	22b0      	movs	r2, #176	; 0xb0
 8000f36:	f7ff ff13 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:197
    WriteRegister(CC_FSCAL3,   CC_FSCAL3_VALUE);     // Frequency synthesizer calibration.
 8000f3a:	4620      	mov	r0, r4
 8000f3c:	2123      	movs	r1, #35	; 0x23
 8000f3e:	22ea      	movs	r2, #234	; 0xea
 8000f40:	f7ff ff0e 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:198
    WriteRegister(CC_FSCAL2,   CC_FSCAL2_VALUE);     // Frequency synthesizer calibration.
 8000f44:	4620      	mov	r0, r4
 8000f46:	2124      	movs	r1, #36	; 0x24
 8000f48:	222a      	movs	r2, #42	; 0x2a
 8000f4a:	f7ff ff09 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:199
    WriteRegister(CC_FSCAL1,   CC_FSCAL1_VALUE);     // Frequency synthesizer calibration.
 8000f4e:	4620      	mov	r0, r4
 8000f50:	2125      	movs	r1, #37	; 0x25
 8000f52:	2200      	movs	r2, #0
 8000f54:	f7ff ff04 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:200
    WriteRegister(CC_FSCAL0,   CC_FSCAL0_VALUE);     // Frequency synthesizer calibration.
 8000f58:	4620      	mov	r0, r4
 8000f5a:	2126      	movs	r1, #38	; 0x26
 8000f5c:	221f      	movs	r2, #31
 8000f5e:	f7ff feff 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:201
    WriteRegister(CC_TEST2,    CC_TEST2_VALUE);      // Various test settings.
 8000f62:	4620      	mov	r0, r4
 8000f64:	212c      	movs	r1, #44	; 0x2c
 8000f66:	2288      	movs	r2, #136	; 0x88
 8000f68:	f7ff fefa 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:202
    WriteRegister(CC_TEST1,    CC_TEST1_VALUE);      // Various test settings.
 8000f6c:	4620      	mov	r0, r4
 8000f6e:	212d      	movs	r1, #45	; 0x2d
 8000f70:	2231      	movs	r2, #49	; 0x31
 8000f72:	f7ff fef5 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:203
    WriteRegister(CC_TEST0,    CC_TEST0_VALUE);      // Various test settings.
 8000f76:	4620      	mov	r0, r4
 8000f78:	212e      	movs	r1, #46	; 0x2e
 8000f7a:	2209      	movs	r2, #9
 8000f7c:	f7ff fef0 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:204
    WriteRegister(CC_FIFOTHR,  CC_FIFOTHR_VALUE);    // fifo threshold
 8000f80:	4620      	mov	r0, r4
 8000f82:	2103      	movs	r1, #3
 8000f84:	2207      	movs	r2, #7
 8000f86:	f7ff feeb 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:205
    WriteRegister(CC_IOCFG2,   CC_IOCFG2_VALUE);     // GDO2 output pin configuration.
 8000f8a:	4620      	mov	r0, r4
 8000f8c:	2100      	movs	r1, #0
 8000f8e:	2207      	movs	r2, #7
 8000f90:	f7ff fee6 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:206
    WriteRegister(CC_IOCFG0,   CC_IOCFG0_VALUE);     // GDO0 output pin configuration.
 8000f94:	4620      	mov	r0, r4
 8000f96:	2102      	movs	r1, #2
 8000f98:	2206      	movs	r2, #6
 8000f9a:	f7ff fee1 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:207
    WriteRegister(CC_PKTCTRL1, CC_PKTCTRL1_VALUE);   // Packet automation control.
 8000f9e:	4620      	mov	r0, r4
 8000fa0:	2107      	movs	r1, #7
 8000fa2:	220c      	movs	r2, #12
 8000fa4:	f7ff fedc 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:208
    WriteRegister(CC_PKTCTRL0, CC_PKTCTRL0_VALUE);   // Packet automation control.
 8000fa8:	4620      	mov	r0, r4
 8000faa:	2108      	movs	r1, #8
 8000fac:	2244      	movs	r2, #68	; 0x44
 8000fae:	f7ff fed7 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:209
    WriteRegister(CC_PKTLEN,   RPKT_LEN);            // Packet length, dummy
 8000fb2:	4620      	mov	r0, r4
 8000fb4:	2106      	movs	r1, #6
 8000fb6:	2201      	movs	r2, #1
 8000fb8:	f7ff fed2 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:211

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);
 8000fbc:	4620      	mov	r0, r4
 8000fbe:	213e      	movs	r1, #62	; 0x3e
 8000fc0:	2250      	movs	r2, #80	; 0x50
 8000fc2:	f7ff fecd 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:213

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
 8000fc6:	4620      	mov	r0, r4
 8000fc8:	2116      	movs	r1, #22
 8000fca:	2207      	movs	r2, #7
 8000fcc:	f7ff fec8 	bl	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:214
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 8000fd0:	4620      	mov	r0, r4
 8000fd2:	2117      	movs	r1, #23
 8000fd4:	2200      	movs	r2, #0
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:215
}
 8000fd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:214
    WriteRegister(CC_PKTLEN,   RPKT_LEN);            // Packet length, dummy

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 8000fda:	f7ff bec1 	b.w	8000d60 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

08000fe0 <cc1101_t::Init()>:
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:13
#include "cc1101.h"
#include "ch.h"

cc1101_t CC;

void cc1101_t::Init() {
 8000fe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000fe2:	4d8d      	ldr	r5, [pc, #564]	; (8001218 <cc1101_t::Init()+0x238>)
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000fe4:	4c8d      	ldr	r4, [pc, #564]	; (800121c <cc1101_t::Init()+0x23c>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000fe6:	69eb      	ldr	r3, [r5, #28]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:471
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
        PSpi->CR2 = 0;
 8000fe8:	2700      	movs	r7, #0
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000fea:	f043 0301 	orr.w	r3, r3, #1
 8000fee:	61eb      	str	r3, [r5, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:198
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000ff0:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:13
 8000ff2:	4606      	mov	r6, r0
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:198
 8000ff4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000ff8:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:199
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 8000ffa:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t6CResetEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:48
    void WriteRegister (const uint8_t Addr, const uint8_t AData);
    uint8_t ReadRegister (const uint8_t Addr);
    void WriteStrobe(uint8_t AStrobe);
    void WriteTX(uint8_t* Ptr, uint8_t Length);
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
 8000ffc:	2130      	movs	r1, #48	; 0x30
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:199
 8000ffe:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001002:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:201
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001004:	88a3      	ldrh	r3, [r4, #4]
 8001006:	f023 0310 	bic.w	r3, r3, #16
 800100a:	041b      	lsls	r3, r3, #16
 800100c:	0c1b      	lsrs	r3, r3, #16
 800100e:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:202
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001010:	88a3      	ldrh	r3, [r4, #4]
 8001012:	b29b      	uxth	r3, r3
 8001014:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:204
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001016:	68e3      	ldr	r3, [r4, #12]
 8001018:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800101c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:205
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800101e:	68e3      	ldr	r3, [r4, #12]
 8001020:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:207
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001022:	68a3      	ldr	r3, [r4, #8]
 8001024:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001028:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:208
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800102a:	68a3      	ldr	r3, [r4, #8]
 800102c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8001030:	60a3      	str	r3, [r4, #8]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001032:	69eb      	ldr	r3, [r5, #28]
 8001034:	f043 0301 	orr.w	r3, r3, #1
 8001038:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800103a:	6823      	ldr	r3, [r4, #0]
 800103c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8001040:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001042:	6823      	ldr	r3, [r4, #0]
 8001044:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001048:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 800104a:	88a3      	ldrh	r3, [r4, #4]
 800104c:	f023 0320 	bic.w	r3, r3, #32
 8001050:	041b      	lsls	r3, r3, #16
 8001052:	0c1b      	lsrs	r3, r3, #16
 8001054:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001056:	88a3      	ldrh	r3, [r4, #4]
 8001058:	b29b      	uxth	r3, r3
 800105a:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 800105c:	68e3      	ldr	r3, [r4, #12]
 800105e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8001062:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001064:	68e3      	ldr	r3, [r4, #12]
 8001066:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001068:	68a3      	ldr	r3, [r4, #8]
 800106a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800106e:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001070:	68a3      	ldr	r3, [r4, #8]
 8001072:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001076:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001078:	6a23      	ldr	r3, [r4, #32]
 800107a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800107e:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001080:	6a23      	ldr	r3, [r4, #32]
 8001082:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 8001086:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001088:	69eb      	ldr	r3, [r5, #28]
 800108a:	f043 0301 	orr.w	r3, r3, #1
 800108e:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001090:	6823      	ldr	r3, [r4, #0]
 8001092:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8001096:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001098:	6823      	ldr	r3, [r4, #0]
 800109a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800109e:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80010a0:	88a3      	ldrh	r3, [r4, #4]
 80010a2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80010a6:	041b      	lsls	r3, r3, #16
 80010a8:	0c1b      	lsrs	r3, r3, #16
 80010aa:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80010ac:	88a3      	ldrh	r3, [r4, #4]
 80010ae:	b29b      	uxth	r3, r3
 80010b0:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80010b2:	68e3      	ldr	r3, [r4, #12]
 80010b4:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80010b8:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80010ba:	68e3      	ldr	r3, [r4, #12]
 80010bc:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80010be:	68a3      	ldr	r3, [r4, #8]
 80010c0:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80010c4:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80010c6:	68a3      	ldr	r3, [r4, #8]
 80010c8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80010cc:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 80010ce:	6a23      	ldr	r3, [r4, #32]
 80010d0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80010d4:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 80010d6:	6a23      	ldr	r3, [r4, #32]
 80010d8:	f043 63a0 	orr.w	r3, r3, #83886080	; 0x5000000
 80010dc:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80010de:	69eb      	ldr	r3, [r5, #28]
 80010e0:	f043 0301 	orr.w	r3, r3, #1
 80010e4:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:244
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80010e6:	6823      	ldr	r3, [r4, #0]
 80010e8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80010ec:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:245
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80010ee:	6823      	ldr	r3, [r4, #0]
 80010f0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80010f4:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:247
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80010f6:	88a3      	ldrh	r3, [r4, #4]
 80010f8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80010fc:	041b      	lsls	r3, r3, #16
 80010fe:	0c1b      	lsrs	r3, r3, #16
 8001100:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:248
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001102:	88a3      	ldrh	r3, [r4, #4]
 8001104:	b29b      	uxth	r3, r3
 8001106:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:250
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001108:	68e3      	ldr	r3, [r4, #12]
 800110a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800110e:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001110:	68e3      	ldr	r3, [r4, #12]
 8001112:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:253
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001114:	68a3      	ldr	r3, [r4, #8]
 8001116:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800111a:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:254
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800111c:	68a3      	ldr	r3, [r4, #8]
 800111e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001122:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001124:	6a23      	ldr	r3, [r4, #32]
 8001126:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800112a:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 800112c:	6a23      	ldr	r3, [r4, #32]
 800112e:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
 8001132:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001134:	69eb      	ldr	r3, [r5, #28]
 8001136:	f043 0301 	orr.w	r3, r3, #1
 800113a:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:219
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 800113c:	6823      	ldr	r3, [r4, #0]
 800113e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8001142:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:221
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001144:	68e3      	ldr	r3, [r4, #12]
 8001146:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800114a:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:222
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 800114c:	68e3      	ldr	r3, [r4, #12]
 800114e:	60e3      	str	r3, [r4, #12]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:182
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001150:	69eb      	ldr	r3, [r5, #28]
 8001152:	f043 0301 	orr.w	r3, r3, #1
 8001156:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:219
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001158:	6823      	ldr	r3, [r4, #0]
 800115a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800115e:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:221
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001160:	68e3      	ldr	r3, [r4, #12]
 8001162:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8001166:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:222
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 8001168:	68e3      	ldr	r3, [r4, #12]
 800116a:	60e3      	str	r3, [r4, #12]
PinSet():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:175
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800116c:	2310      	movs	r3, #16
 800116e:	8323      	strh	r3, [r4, #24]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:461
private:
    SPI_TypeDef *PSpi;
public:
    void Setup(SPI_TypeDef *Spi, BitOrder_t BitOrder,
            CPOL_t CPOL, CPHA_t CPHA, SpiBaudrate_t Baudrate) {
        PSpi = Spi;
 8001170:	4b2b      	ldr	r3, [pc, #172]	; (8001220 <cc1101_t::Init()+0x240>)
 8001172:	6083      	str	r3, [r0, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:463
        // Clocking
        if      (PSpi == SPI1) { rccEnableSPI1(FALSE); }
 8001174:	6a2a      	ldr	r2, [r5, #32]
 8001176:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800117a:	622a      	str	r2, [r5, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:466
        else if (PSpi == SPI2) { rccEnableSPI2(FALSE); }
        // Mode: Master, NSS software controlled and is 1, 8bit, NoCRC, FullDuplex
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
 800117c:	f44f 7241 	mov.w	r2, #772	; 0x304
 8001180:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:470
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
 8001182:	881a      	ldrh	r2, [r3, #0]
 8001184:	b292      	uxth	r2, r2
 8001186:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:471
        PSpi->CR2 = 0;
 8001188:	809f      	strh	r7, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:472
        PSpi->I2SCFGR &= ~((uint16_t)SPI_I2SCFGR_I2SMOD);       // Disable I2S
 800118a:	8b9a      	ldrh	r2, [r3, #28]
 800118c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001190:	0412      	lsls	r2, r2, #16
 8001192:	0c12      	lsrs	r2, r2, #16
 8001194:	839a      	strh	r2, [r3, #28]
_ZN5Spi_t6EnableEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:474
    }
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
 8001196:	881a      	ldrh	r2, [r3, #0]
 8001198:	b292      	uxth	r2, r2
 800119a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800119e:	801a      	strh	r2, [r3, #0]
_ZN8cc1101_t6CResetEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:48
 80011a0:	f7ff fdf6 	bl	8000d90 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11FlushRxFIFOEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.h:53
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 80011a4:	4630      	mov	r0, r6
 80011a6:	213a      	movs	r1, #58	; 0x3a
 80011a8:	f7ff fdf2 	bl	8000d90 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:30
    ISpi.Enable();

    // ==== Init CC ====
    CReset();
    FlushRxFIFO();
    RfConfig();
 80011ac:	4630      	mov	r0, r6
 80011ae:	f7ff fe5f 	bl	8000e70 <cc1101_t::RfConfig()>
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:303
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
        IPinNumber = APinNumber;
 80011b2:	2303      	movs	r3, #3
 80011b4:	7533      	strb	r3, [r6, #20]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:304
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 80011b6:	6a2b      	ldr	r3, [r5, #32]
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:31
    PWaitingThread = nullptr;
 80011b8:	6077      	str	r7, [r6, #4]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:304
 80011ba:	f043 0301 	orr.w	r3, r3, #1
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:32
    State = ccIdle;
 80011be:	7637      	strb	r7, [r6, #24]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:302
                break;
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
 80011c0:	6134      	str	r4, [r6, #16]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:304
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 80011c2:	622b      	str	r3, [r5, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:308
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80011c4:	4b17      	ldr	r3, [pc, #92]	; (8001224 <cc1101_t::Init()+0x244>)
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:284
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 80011c6:	2101      	movs	r1, #1
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:308
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80011c8:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:319
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 80011ca:	2009      	movs	r0, #9
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:308
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80011cc:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 80011d0:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:314
        // GPIOA requires all zeroes => nothing to do in this case
        if     (GPIO == GPIOB) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0001 << Offset;
        else if(GPIO == GPIOC) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0010 << Offset;
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
 80011d2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 80011d6:	f042 0208 	orr.w	r2, r2, #8
 80011da:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:315
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
 80011de:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 80011e2:	f022 0208 	bic.w	r2, r2, #8
 80011e6:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:284
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 80011ea:	7d32      	ldrb	r2, [r6, #20]
 80011ec:	fa01 f202 	lsl.w	r2, r1, r2
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:291
            case ttRising:
                EXTI->RTSR |=  IrqMsk;  // Rising trigger enabled
                EXTI->FTSR &= ~IrqMsk;  // Falling trigger disabled
                break;
            case ttFalling:
                EXTI->RTSR &= ~IrqMsk;  // Rising trigger disabled
 80011f0:	f8d3 1408 	ldr.w	r1, [r3, #1032]	; 0x408
 80011f4:	ea21 0102 	bic.w	r1, r1, r2
 80011f8:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:292
                EXTI->FTSR |=  IrqMsk;  // Falling trigger enabled
 80011fc:	f8d3 140c 	ldr.w	r1, [r3, #1036]	; 0x40c
 8001200:	430a      	orrs	r2, r1
 8001202:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:317
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
 8001206:	2208      	movs	r2, #8
 8001208:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
_ZN8PinIrq_t9EnableIrqEm():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:323
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIrq(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 800120c:	2190      	movs	r1, #144	; 0x90
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:319
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 800120e:	60f0      	str	r0, [r6, #12]
_ZN8cc1101_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:37

    // ==== IRQ ====
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIrq(IRQ_PRIO_MEDIUM);
}
 8001210:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
_ZN8PinIrq_t9EnableIrqEm():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:323
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIrq(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 8001214:	f7ff bb7c 	b.w	8000910 <nvicEnableVector>
 8001218:	40023800 	.word	0x40023800
 800121c:	40020000 	.word	0x40020000
 8001220:	40013000 	.word	0x40013000
 8001224:	40010000 	.word	0x40010000
	...

08001230 <cc1101_t::IHandleAsync()>:
_ZN8cc1101_t12IHandleAsyncEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:223
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcTx);  // FIXME
    }
    else if(State == ccReceiving) {
 8001230:	7e03      	ldrb	r3, [r0, #24]
 8001232:	3b02      	subs	r3, #2
 8001234:	b2db      	uxtb	r3, r3
 8001236:	2b01      	cmp	r3, #1
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:220
}

// ============================= Interrupts ====================================
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
 8001238:	bf9c      	itt	ls
 800123a:	2300      	movls	r3, #0
 800123c:	7603      	strbls	r3, [r0, #24]
 800123e:	4770      	bx	lr

08001240 <cc1101_t::IGdo0IrqHandler()>:
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:229
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcRx);  // FIXME
    }
}

void cc1101_t::IGdo0IrqHandler() {
 8001240:	b510      	push	{r4, lr}
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:325
    void DisableIrq() { nvicDisableVector(IIrqChnl); }
    void CleanIrqFlag() { EXTI->PR = (1 << IPinNumber); }
 8001242:	7d03      	ldrb	r3, [r0, #20]
 8001244:	2201      	movs	r2, #1
 8001246:	409a      	lsls	r2, r3
 8001248:	4b0c      	ldr	r3, [pc, #48]	; (800127c <cc1101_t::IGdo0IrqHandler()+0x3c>)
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:229
 800124a:	4604      	mov	r4, r0
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../kl_lib/kl_lib_L15x.h:325
 800124c:	615a      	str	r2, [r3, #20]
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:232
    IGdo0.CleanIrqFlag();
    // Resume thread if any
    chSysLockFromIsr();
 800124e:	2320      	movs	r3, #32
 8001250:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:233
    if(PWaitingThread != NULL) {
 8001254:	6843      	ldr	r3, [r0, #4]
 8001256:	b153      	cbz	r3, 800126e <cc1101_t::IGdo0IrqHandler()+0x2e>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:234
        if(PWaitingThread->p_state == THD_STATE_SUSPENDED) {
 8001258:	7f1a      	ldrb	r2, [r3, #28]
 800125a:	2a02      	cmp	r2, #2
 800125c:	d104      	bne.n	8001268 <cc1101_t::IGdo0IrqHandler()+0x28>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:235
            PWaitingThread->p_u.rdymsg = RDY_OK;    // Signal that IRQ fired
 800125e:	2200      	movs	r2, #0
 8001260:	621a      	str	r2, [r3, #32]
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:236
            chSchReadyI(PWaitingThread);
 8001262:	6840      	ldr	r0, [r0, #4]
 8001264:	f7fe ffe4 	bl	8000230 <chSchReadyI>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:238 (discriminator 1)
        }
        PWaitingThread = NULL;
 8001268:	2300      	movs	r3, #0
 800126a:	6063      	str	r3, [r4, #4]
 800126c:	e001      	b.n	8001272 <cc1101_t::IGdo0IrqHandler()+0x32>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:240
    }
    else IHandleAsync(); // Async task completed
 800126e:	f7ff ffdf 	bl	8001230 <cc1101_t::IHandleAsync()>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:241
    chSysUnlockFromIsr();
 8001272:	2300      	movs	r3, #0
 8001274:	f383 8811 	msr	BASEPRI, r3
 8001278:	bd10      	pop	{r4, pc}
 800127a:	bf00      	nop
 800127c:	40010400 	.word	0x40010400

08001280 <Vector64>:
Vector64():
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:245
}

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
 8001280:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:247
    CH_IRQ_PROLOGUE();
    CC.IGdo0IrqHandler();
 8001282:	4803      	ldr	r0, [pc, #12]	; (8001290 <Vector64+0x10>)
 8001284:	f7ff ffdc 	bl	8001240 <cc1101_t::IGdo0IrqHandler()>
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:249
    CH_IRQ_EPILOGUE();
}
 8001288:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\cctx\Debug/../Radio/cc1101.cpp:248

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
    CH_IRQ_PROLOGUE();
    CC.IGdo0IrqHandler();
    CH_IRQ_EPILOGUE();
 800128c:	f7ff ba30 	b.w	80006f0 <_port_irq_epilogue>
 8001290:	20000f44 	.word	0x20000f44
	...

080012a0 <memset>:
memset():
 80012a0:	b4f0      	push	{r4, r5, r6, r7}
 80012a2:	0784      	lsls	r4, r0, #30
 80012a4:	d043      	beq.n	800132e <memset+0x8e>
 80012a6:	1e54      	subs	r4, r2, #1
 80012a8:	2a00      	cmp	r2, #0
 80012aa:	d03e      	beq.n	800132a <memset+0x8a>
 80012ac:	b2cd      	uxtb	r5, r1
 80012ae:	4603      	mov	r3, r0
 80012b0:	e003      	b.n	80012ba <memset+0x1a>
 80012b2:	1e62      	subs	r2, r4, #1
 80012b4:	2c00      	cmp	r4, #0
 80012b6:	d038      	beq.n	800132a <memset+0x8a>
 80012b8:	4614      	mov	r4, r2
 80012ba:	f803 5b01 	strb.w	r5, [r3], #1
 80012be:	079a      	lsls	r2, r3, #30
 80012c0:	d1f7      	bne.n	80012b2 <memset+0x12>
 80012c2:	2c03      	cmp	r4, #3
 80012c4:	d92a      	bls.n	800131c <memset+0x7c>
 80012c6:	b2cd      	uxtb	r5, r1
 80012c8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80012cc:	2c0f      	cmp	r4, #15
 80012ce:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80012d2:	d915      	bls.n	8001300 <memset+0x60>
 80012d4:	f1a4 0710 	sub.w	r7, r4, #16
 80012d8:	093f      	lsrs	r7, r7, #4
 80012da:	f103 0610 	add.w	r6, r3, #16
 80012de:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80012e2:	461a      	mov	r2, r3
 80012e4:	6015      	str	r5, [r2, #0]
 80012e6:	6055      	str	r5, [r2, #4]
 80012e8:	6095      	str	r5, [r2, #8]
 80012ea:	60d5      	str	r5, [r2, #12]
 80012ec:	3210      	adds	r2, #16
 80012ee:	42b2      	cmp	r2, r6
 80012f0:	d1f8      	bne.n	80012e4 <memset+0x44>
 80012f2:	f004 040f 	and.w	r4, r4, #15
 80012f6:	3701      	adds	r7, #1
 80012f8:	2c03      	cmp	r4, #3
 80012fa:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80012fe:	d90d      	bls.n	800131c <memset+0x7c>
 8001300:	461e      	mov	r6, r3
 8001302:	4622      	mov	r2, r4
 8001304:	3a04      	subs	r2, #4
 8001306:	2a03      	cmp	r2, #3
 8001308:	f846 5b04 	str.w	r5, [r6], #4
 800130c:	d8fa      	bhi.n	8001304 <memset+0x64>
 800130e:	1f22      	subs	r2, r4, #4
 8001310:	f022 0203 	bic.w	r2, r2, #3
 8001314:	3204      	adds	r2, #4
 8001316:	4413      	add	r3, r2
 8001318:	f004 0403 	and.w	r4, r4, #3
 800131c:	b12c      	cbz	r4, 800132a <memset+0x8a>
 800131e:	b2c9      	uxtb	r1, r1
 8001320:	441c      	add	r4, r3
 8001322:	f803 1b01 	strb.w	r1, [r3], #1
 8001326:	42a3      	cmp	r3, r4
 8001328:	d1fb      	bne.n	8001322 <memset+0x82>
 800132a:	bcf0      	pop	{r4, r5, r6, r7}
 800132c:	4770      	bx	lr
 800132e:	4614      	mov	r4, r2
 8001330:	4603      	mov	r3, r0
 8001332:	e7c6      	b.n	80012c2 <memset+0x22>
	...
$d():
 8001340:	08060403 	.word	0x08060403
 8001344:	2018100c 	.word	0x2018100c
 8001348:	00000030 	.word	0x00000030
 800134c:	00000000 	.word	0x00000000
 8001350:	03020100 	.word	0x03020100
 8001354:	08070604 	.word	0x08070604
 8001358:	00000009 	.word	0x00000009
 800135c:	03020100 	.word	0x03020100
 8001360:	00000004 	.word	0x00000004
	...

08001370 <ch_debug>:
 8001370:	6e69616d 11801600 08280404 1814100c     main......(.....
 8001380:	001d1c00 0000001e 00000000 00000000     ................
 8001390:	63536863 61655268 28497964 23202c29     chSchReadyI(), #
 80013a0:	00000031 00000000 00000000 00000000     1...............
 80013b0:	656c6469 00000000 00000000 00000000     idle............
 80013c0:	54686322 72436468 65746165 29282249     "chThdCreateI"()
 80013d0:	68632200 53646854 72507465 69726f69     ."chThdSetPriori
 80013e0:	28227974 68630029 52646854 6d757365     ty"().chThdResum
 80013f0:	2c292865 00312320 54686322 6c536468     e(), #1."chThdSl
 8001400:	22706565 63002928 64685468 74697845     eep"().chThdExit
 8001410:	2c292853 00312320 00000000 00000000     S(), #1.........
 8001420:	56686322 74655354 29282249 68632200     "chVTSetI"()."ch
 8001430:	65525456 49746573 00292822 54566863     VTResetI"().chVT
 8001440:	65736552 29284974 3123202c 00000000     ResetI(), #1....

08001450 <_stm32_dma_streams>:
 8001450:	40026008 40026004 000b0000 4002601c     .`.@.`.@.....`.@
 8001460:	40026004 000c0104 40026030 40026004     .`.@....0`.@.`.@
 8001470:	000d0208 40026044 40026004 000e030c     ....D`.@.`.@....
 8001480:	40026058 40026004 000f0410 4002606c     X`.@.`.@....l`.@
 8001490:	40026004 00100514 40026080 40026004     .`.@.....`.@.`.@
 80014a0:	00110618 00000000 00000000 00000000     ................
 80014b0:	0d004020 20200d00 30202020 20312020      @....     0  1 
 80014c0:	20203220 34202033 20352020 20203620      2  3  4  5  6  
 80014d0:	38202037 20392020 20204120 43202042     7  8  9  A  B  C
 80014e0:	20442020 20204520 250d0046 3a583230       D  E  F..%02X:
 80014f0:	20200020 30250020 00205832 00202d2d      .   .%02X .-- .
