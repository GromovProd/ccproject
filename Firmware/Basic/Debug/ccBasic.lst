
ccBasic.elf:     file format elf32-littlearm
ccBasic.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000bd1

Program Header:
    LOAD off    0x00008000 vaddr 0x08000000 paddr 0x08000000 align 2**15
         filesz 0x00002b14 memsz 0x00002b18 flags rwx
    LOAD off    0x00010800 vaddr 0x20000800 paddr 0x08002b18 align 2**15
         filesz 0x00000000 memsz 0x00000b40 flags rw-
    LOAD off    0x00010000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000800 flags rw-
private flags = 5000002: [Version5 EABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 startup       000000f4  08000000  08000000  00008000  2**4  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a14  08000100  08000100  00008100  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .textalign    00000004  08002b14  08002b14  0000ab14  2**0  ALLOC
  3 .stacks       00000800  20000000  20000000  00010000  2**0  ALLOC
  4 .bss          00000b40  20000800  08002b18  00010800  2**3  ALLOC
  5 .debug_info   00013f63  00000000  00000000  0000ab14  2**0  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00004337  00000000  00000000  0001ea77  2**0  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00004a0c  00000000  00000000  00022dae  2**0  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000888  00000000  00000000  000277ba  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000fe8  00000000  00000000  00028042  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000043a5  00000000  00000000  0002902a  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003f5c  00000000  00000000  0002d3cf  2**0  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000070  00000000  00000000  0003132b  2**0  CONTENTS, READONLY
 13 .ARM.attributes 00000033  00000000  00000000  0003139b  2**0  CONTENTS, READONLY
 14 .debug_frame  000013f8  00000000  00000000  000313d0  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  startup	00000000 startup
08000100 l    d  .text	00000000 .text
08002b14 l    d  .textalign	00000000 .textalign
20000000 l    d  .stacks	00000000 .stacks
20000800 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 application.cpp
080001f0 l     F .text	00000044 AppThread(void*)
20000800 l     O .bss	00000008 Pill
08002710 l     O .text	00000018 BeepPillBad
20000808 l     O .bss	00000014 ITmrPillCheck
20000820 l     O .bss	00000198 waAppThread
00000000 l    df *ABS*	00000000 radio.cpp
080002f0 l     F .text	0000001c radioThread(void*)
200009c8 l     O .bss	00000198 warradioThread
00000000 l    df *ABS*	00000000 cc1101.cpp
080003b0 l     F .text	00000010 cc1101_t::BusyWait() [clone .isra.6]
00000000 l    df *ABS*	00000000 nvic.c
00000000 l    df *ABS*	00000000 chcore_v7m.c
08000a6c l       .text	00000000 _port_exit_from_isr
00000000 l    df *ABS*	00000000 crt0.c
00000000 l    df *ABS*	00000000 chdebug.c
00000000 l    df *ABS*	00000000 chevents.c
00000000 l    df *ABS*	00000000 chschd.c
08000fa0 l     F .text	0000004c wakeup
00000000 l    df *ABS*	00000000 chsem.c
00000000 l    df *ABS*	00000000 chsys.c
20000b7c l     O .bss	00000034 mainthread.4585
00000000 l    df *ABS*	00000000 chthreads.c
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 hal.c
00000000 l    df *ABS*	00000000 hal_lld.cpp
00000000 l    df *ABS*	00000000 stm32_dma.c
20000bb0 l     O .bss	00000038 dma_isr_redir
20000be8 l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 clocking_L1xx.cpp
00000000 l    df *ABS*	00000000 cmd_uart.cpp
08001a70 l     F .text	0000000c FPutChar(char)
00000000 l    df *ABS*	00000000 kl_lib_L15x.cpp
08001c60 l     F .text	0000005c PinClockEnable(GPIO_TypeDef*)
08001cc0 l     F .text	00000090 PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]
00000000 l    df *ABS*	00000000 kl_sprintf.c
080022a0 l     F .text	00000072 IPutUint.4105
00000000 l    df *ABS*	00000000 peripheral.cpp
00000000 l    df *ABS*	00000000 pill_mgr.cpp
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 
20001340 l       .bss	00000000 __heap_base__
08002b18 l       .textalign	00000000 _etext
20002800 l       *ABS*	00000000 __heap_end__
00002800 l       *ABS*	00000000 __ram_size__
00000000 l       startup	00000000 _text
20000000 l       startup	00000000 __ram_start__
20002800 l       *ABS*	00000000 __ram_end__
20001340 l       .bss	00000000 _end
00000400 l       *ABS*	00000000 __main_stack_size__
00000400 l       *ABS*	00000000 __process_stack_size__
08000a50  w    F .text	00000002 Vector58
08000a50  w    F .text	00000002 VectorE8
08000a50  w    F .text	00000002 Vector9C
080009d0 g     F .text	00000046 nvicEnableVector
08000d10 g     F .text	00000028 dbg_check_lock_from_isr
08001a10 g     F .text	00000034 SetupVCore(VCore_t)
08000a50  w    F .text	00000002 VectorAC
08001520 g     F .text	00000018 chThdExit
08001340 g     F .text	00000068 chSysTimerHandlerI
08001040 g     F .text	00000048 chSchGoSleepTimeoutS
08000cb0 g     F .text	00000028 dbg_check_lock
08000160 g     F .text	0000003c TmrPillCheckCallback(void*)
08000a50  w    F .text	00000002 Vector5C
08000a50  w    F .text	00000002 NMIVector
08001820 g     F .text	00000038 dmaInit
08000a50  w    F .text	00000002 Vector8C
08000a50  w    F .text	00000002 VectorDC
08001ef0 g     F .text	0000002a i2c_t::IBusyWait()
08001f70 g     F .text	0000001a i2c_t::WaitEv8()
080024d0 g     F .text	00000028 BeeperTmrCallback(void*)
08000000 g     O startup	000000f4 _vectors
08000420 g     F .text	00000068 cc1101_t::ReadFIFO(rPkt_t*)
08000ff0 g     F .text	00000050 chSchGoSleepS
080013f0 g     F .text	0000004c chThdCreateI
08000c90 g     F .text	00000020 dbg_check_enable
08000a50  w    F .text	00000002 VectorC8
08001090 g     F .text	00000058 chSchWakeupS
08000f40 g     F .text	00000014 _scheduler_init
08001440 g     F .text	0000005e chThdCreateStatic
08000a50  w    F .text	00000002 Vector94
200009b8 g     O .bss	00000004 App
08000a50  w    F .text	00000002 VectorA8
08000a50  w    F .text	00000002 VectorB4
08000f60 g     F .text	00000040 chSchReadyI
080000f4 g       startup	00000000 __fini_array_end
20000800 g       .stacks	00000000 __main_thread_stack_end__
08001540 g     F .text	00000018 _vt_init
080016e0 g     F .text	00000034 Vector74
08001600 g     F .text	00000004 halInit
200009bc g     O .bss	00000008 Radio
08000a50  w    F .text	00000002 VectorEC
20000800 g       .bss	00000000 _bss_start
080010f0 g     F .text	0000004c chSchDoRescheduleBehind
08000a50  w    F .text	00000002 UsageFaultVector
08000a50  w    F .text	00000002 DebugMonitorVector
08000ce0 g     F .text	00000028 dbg_check_unlock
08000a50  w    F .text	00000002 Vector40
08000bd0 g     F .text	000000c0 ResetHandler
08000a50  w    F .text	00000002 VectorBC
08001d90 g     F .text	0000007c i2c_t::Standby()
08000a90 g     F .text	00000034 _port_init
08001610 g     F .text	00000064 hal_lld_init
08001220 g     F .text	00000024 chSemWait
080014d0 g     F .text	00000048 chThdExitS
08000960 g     F .text	0000004c cc1101_t::IGdo0IrqHandler()
08000290 g     F .text	00000054 radio_t::ITask()
20000e58 g     O .bss	00000408 dbg_trace_buffer
08000a50  w    F .text	00000002 PendSVVector
08000590 g     F .text	0000016e cc1101_t::RfConfig()
08001560 g     F .text	00000050 chVTSetI
080009b0 g     F .text	0000001c Vector64
20001340 g       .bss	00000000 _bss_end
20001260 g     O .bss	00000004 dbg_panic_msg
08000bc0  w    F .text	00000002 _default_exit
08001be0 g     F .text	0000006c CmdUart_t::IRQDmaTxHandler()
08000a50  w    F .text	00000002 VectorCC
08000a50  w    F .text	00000002 Vector54
08000a50  w    F .text	00000002 Vector98
08001f90 g     F .text	00000018 i2c_t::WaitBTF()
08000a50  w    F .text	00000002 VectorD8
08001fb0 g     F .text	00000198 i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)
08000a50  w    F .text	00000002 Vector24
08000df0 g     F .text	00000024 chDbgCheckClassI
080004c0 g     F .text	0000002c cc1101_t::WriteStrobe(unsigned char)
080011a0 g     F .text	00000018 chSchDoReschedule
080012d0 g     F .text	0000006c chSysInit
080014a0 g     F .text	00000030 chThdSleep
08002ac0 g     O .text	00000054 _stm32_dma_streams
080017e0 g     F .text	00000034 Vector84
08000b40 g     F .text	0000002a SysTickVector
20001264 g     O .bss	00000004 dbg_isr_cnt
20000bfc g     O .bss	0000020c Uart
08002150 g     F .text	00000144 i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)
08000a50  w    F .text	00000002 BusFaultVector
08000a50  w    F .text	00000002 VectorD0
080018f0 g     F .text	00000114 Clk_t::UpdateFreqValues()
08000700 g     F .text	00000248 cc1101_t::Init()
20000e08 g     O .bss	00000024 Beeper
08000a50  w    F .text	00000002 VectorE4
08000a50  w    F .text	00000002 VectorC0
08000b70 g     F .text	00000010 _port_switch
080025b0 g     F .text	00000034 PillMgr_t::CheckIfConnected(unsigned char)
08001f20 g     F .text	00000024 i2c_t::WaitEv5()
080011c0 g     F .text	00000060 chSemWaitS
08000a70 g     F .text	00000012 SVCallVector
08000bb0  w    F .text	00000002 __late_init
08001d70 g     F .text	0000001c chDbgPanic
20001330 g     O .bss	00000010 vtlist
08000490 g     F .text	00000030 cc1101_t::WriteRegister(unsigned char, unsigned char)
08000a50  w    F .text	00000002 HardFaultVector
08000ad0 g     F .text	0000006c _port_irq_epilogue
08001b00 g     F .text	000000d4 CmdUart_t::Init(unsigned long)
080001a0 g     F .text	00000050 App_t::IPillHandler()
08000240 g     F .text	00000050 App_t::Init()
08000e20 g     F .text	00000024 chDbgCheckClassS
08000a50  w    F .text	00000002 VectorF0
20000bf0 g     O .bss	0000000c Clk
080003c0  w    F .text	00000010 Spi_t::ReadWriteByte(unsigned char)
08000db0 g     F .text	00000038 dbg_check_leave_isr
08002b18 g       .textalign	00000000 _textdata
08000a50  w    F .text	00000002 VectorE0
08002480 g     F .text	0000004c Beeper_t::BeepI(BeepChunk_t const*)
08000a50  w    F .text	00000002 MemManageVector
080000f4 g       startup	00000000 __fini_array_start
20000b60 g     O .bss	0000001c CC
08002640 g     F .text	00000094 memset
08000100 g     F .text	00000054 main
08001680 g     F .text	00000030 Vector6C
2000126c g     O .bss	0000001c rlist
08000a50  w    F .text	00000002 VectorA0
08000520 g     F .text	00000064 cc1101_t::ReceiveSync(unsigned long, rPkt_t*)
08000d70 g     F .text	00000038 dbg_check_enter_isr
08002540 g     F .text	00000070 PillMgr_t::ResetBus()
08001250 g     F .text	0000005c chSemSignal
080000f4 g       startup	00000000 __init_array_end
08000a50  w    F .text	00000002 VectorC4
08001760 g     F .text	00000034 Vector7C
08002500 g     F .text	00000040 PillMgr_t::Deinit()
080012b0 g     F .text	00000014 _idle_thread
08000a50  w    F .text	00000002 VectorB0
08002830 g     O .text	00000016 ch_debug
20000e2c g     O .bss	0000002c PillMgr
08000500 g     F .text	0000001e cc1101_t::SetChannel(unsigned char)
08000a50  w    F .text	00000002 Vector90
08000eb0 g     F .text	00000048 chEvtSignalI
20001268 g     O .bss	00000004 dbg_lock_cnt
08001a80 g     F .text	00000074 CmdUart_t::Printf(char const*, ...)
08000b80 g     F .text	00000016 _port_thread_start
08000a50  w    F .text	00000002 Vector60
08000a50  w    F .text	00000002 Vector1C
08001140 g     F .text	0000005c chSchDoRescheduleAhead
08001e10 g     F .text	000000d8 i2c_t::Resume()
08000310 g     F .text	00000094 radio_t::Init(unsigned short)
08000a50  w    F .text	00000002 Vector48
20000400 g       .stacks	00000000 __process_stack_base__
080003d0 g     F .text	00000018 cc1101_t::RSSI_dBm(unsigned char)
20000bec g     O .bss	00000001 VCore
080016b0 g     F .text	00000030 Vector70
08000a50  w    F .text	00000002 VectorD4
08000a20 g     F .text	00000026 nvicSetSystemHandlerPriority
08002320 g     F .text	00000160 kl_vsprintf
20001288 g     O .bss	000000a8 _idle_thread_wa
20000800 g       .bss	00000000 _data
08001c50 g     F .text	0000000c CmdUartTxIrq
08000a50  w    F .text	00000002 Vector4C
080017a0 g     F .text	00000034 Vector80
08000a60 g     F .text	0000000e _port_switch_from_isr
08000a50  w    F .text	00000002 Vector68
08000e50 g     F .text	00000014 _trace_init
20000400 g       .stacks	00000000 __main_stack_end__
08001720 g     F .text	00000034 Vector78
20000800 g       .bss	00000000 _edata
08001d50 g     F .text	0000001a PwmPin_t::SetFreqHz(unsigned long)
08000f00 g     F .text	00000040 chEvtWaitAny
080015b0 g     F .text	00000044 chVTResetI
08000a50 g     F .text	00000002 _unhandled_exception
080025f0 g     F .text	00000042 PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)
08000a50  w    F .text	00000002 Vector88
20000400 g       .stacks	00000000 __main_thread_stack_base__
08000950 g     F .text	00000010 cc1101_t::IHandleAsync()
08000e70 g     F .text	00000040 dbg_trace
080000f4 g       startup	00000000 __init_array_start
08001f50 g     F .text	0000001e i2c_t::WaitEv6()
080013b0 g     F .text	00000038 _thread_init
08000a50  w    F .text	00000002 Vector50
08001860 g     F .text	00000088 dmaStreamAllocate
080004f0  w    F .text	00000010 cc1101_t::EnterIdle()
20000000 g       .stacks	00000000 __main_stack_base__
08000a50  w    F .text	00000002 Vector44
08000a50  w    F .text	00000002 Vector28
08000a50  w    F .text	00000002 VectorB8
08001a50 g     F .text	0000001e CmdUart_t::IPutChar(char)
08000d40 g     F .text	0000002c dbg_check_unlock_from_isr
20000800 g       .stacks	00000000 __process_stack_end__
080003f0 g     F .text	0000002c cc1101_t::ReadRegister(unsigned char)
08000a50  w    F .text	00000002 Vector34
08000ba0  w    F .text	00000002 __early_init
08000a50  w    F .text	00000002 VectorA4
08000a50  w    F .text	00000002 Vector20



Disassembly of section .text:

08000100 <main>:
main():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:22
#include "application.h"
#include "radio.h"

static inline void Init();

int main(void) {
 8000100:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:24
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V2);
 8000102:	2003      	movs	r0, #3
 8000104:	f001 fc84 	bl	8001a10 <SetupVCore(VCore_t)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:27
    //Clk.SetupFlashLatency(24);  // Setup Flash Latency for clock in MHz
//    Clk.SetupBusDividers(ahbDiv1, apbDiv1, apbDiv1);
    Clk.UpdateFreqValues();
 8000108:	480d      	ldr	r0, [pc, #52]	; (8000140 <main+0x40>)
 800010a:	f001 fbf1 	bl	80018f0 <Clk_t::UpdateFreqValues()>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:30

    // ==== Init OS ====
    halInit();
 800010e:	f001 fa77 	bl	8001600 <halInit>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:31
    chSysInit();
 8000112:	f001 f8dd 	bl	80012d0 <chSysInit>
Init():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:45
//        Beeper.Beep(BeepShort);
    } // while
}

void Init() {
    Uart.Init(115200);
 8000116:	480b      	ldr	r0, [pc, #44]	; (8000144 <main+0x44>)
 8000118:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 800011c:	f001 fcf0 	bl	8001b00 <CmdUart_t::Init(unsigned long)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:47
    //Uart.Printf("ChibiArmlet AHB=%u; APB1=%u; APB2=%u\r", Clk.AHBFreqHz, Clk.APB1FreqHz, Clk.APB2FreqHz);
    Uart.Printf("cc Started\n");
 8000120:	4808      	ldr	r0, [pc, #32]	; (8000144 <main+0x44>)
 8000122:	4909      	ldr	r1, [pc, #36]	; (8000148 <main+0x48>)
 8000124:	f001 fcac 	bl	8001a80 <CmdUart_t::Printf(char const*, ...)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:48
    Radio.Init(0);
 8000128:	4808      	ldr	r0, [pc, #32]	; (800014c <main+0x4c>)
 800012a:	2100      	movs	r1, #0
 800012c:	f000 f8f0 	bl	8000310 <radio_t::Init(unsigned short)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:49
    App.Init();
 8000130:	4807      	ldr	r0, [pc, #28]	; (8000150 <main+0x50>)
 8000132:	f000 f885 	bl	8000240 <App_t::Init()>
main():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/main.cpp:38 (discriminator 1)
    Init();
//    if(ClkResult) Uart.Printf("Clock failure\r");

    while(1) {
        //chThdSleep(TIME_INFINITE);
        chThdSleepMilliseconds(2007);
 8000136:	f240 70d7 	movw	r0, #2007	; 0x7d7
 800013a:	f001 f9b1 	bl	80014a0 <chThdSleep>
 800013e:	e7fa      	b.n	8000136 <main+0x36>
 8000140:	20000bf0 	.word	0x20000bf0
 8000144:	20000bfc 	.word	0x20000bfc
 8000148:	08002740 	.word	0x08002740
 800014c:	200009bc 	.word	0x200009bc
 8000150:	200009b8 	.word	0x200009b8
	...

08000160 <TmrPillCheckCallback(void*)>:
_Z20TmrPillCheckCallbackPv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:73
    chSysLockFromIsr();
    chEvtSignalI(App.PThd, EVTMSK_DOSE_STORE);
    chVTSetI(&ITmrDoseSave,  MS2ST(TM_DOSE_SAVE_MS),     TmrDoseSaveCallback, nullptr);
    chSysUnlockFromIsr();
}
void TmrPillCheckCallback(void *p) {
 8000160:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:74
    chSysLockFromIsr();
 8000162:	2320      	movs	r3, #32
 8000164:	f383 8811 	msr	BASEPRI, r3
 8000168:	f000 fdd2 	bl	8000d10 <dbg_check_lock_from_isr>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:75
    chEvtSignalI(App.PThd, EVTMSK_PILL_CHECK);
 800016c:	4b08      	ldr	r3, [pc, #32]	; (8000190 <TmrPillCheckCallback(void*)+0x30>)
 800016e:	2104      	movs	r1, #4
 8000170:	6818      	ldr	r0, [r3, #0]
 8000172:	f000 fe9d 	bl	8000eb0 <chEvtSignalI>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:76
    chVTSetI(&ITmrPillCheck, MS2ST(TM_PILL_CHECK_MS),    TmrPillCheckCallback, nullptr);
 8000176:	4807      	ldr	r0, [pc, #28]	; (8000194 <TmrPillCheckCallback(void*)+0x34>)
 8000178:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
 800017c:	4a06      	ldr	r2, [pc, #24]	; (8000198 <TmrPillCheckCallback(void*)+0x38>)
 800017e:	2300      	movs	r3, #0
 8000180:	f001 f9ee 	bl	8001560 <chVTSetI>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:77
    chSysUnlockFromIsr();
 8000184:	f000 fddc 	bl	8000d40 <dbg_check_unlock_from_isr>
 8000188:	2300      	movs	r3, #0
 800018a:	f383 8811 	msr	BASEPRI, r3
 800018e:	bd08      	pop	{r3, pc}
 8000190:	200009b8 	.word	0x200009b8
 8000194:	20000808 	.word	0x20000808
 8000198:	08000161 	.word	0x08000161
$d():
 800019c:	00000000 	.word	0x00000000

080001a0 <App_t::IPillHandler()>:
_ZN5App_t12IPillHandlerEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:29
    uint16_t Charge;
    uint32_t Value;
} __attribute__ ((__packed__));
static Pill_t Pill;

void App_t::IPillHandler() {
 80001a0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:31
    // Read med
    if(PillMgr.Read(PILL_I2C_ADDR, (uint8_t*)&Pill, sizeof(Pill_t)) != OK) return;
 80001a2:	480f      	ldr	r0, [pc, #60]	; (80001e0 <App_t::IPillHandler()+0x40>)
 80001a4:	2150      	movs	r1, #80	; 0x50
 80001a6:	4a0f      	ldr	r2, [pc, #60]	; (80001e4 <App_t::IPillHandler()+0x44>)
 80001a8:	2308      	movs	r3, #8
 80001aa:	f002 fa21 	bl	80025f0 <PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)>
 80001ae:	b9b0      	cbnz	r0, 80001de <App_t::IPillHandler()+0x3e>
_ZN8Beeper_t4BeepEPK11BeepChunk_t():
    VirtualTimer ITmr;
    const BeepChunk_t *IPFirstChunk;
public:
    void BeepI(const BeepChunk_t *PSequence);
    void Beep(const BeepChunk_t *PSequence) {   // Beep with this function
        IPFirstChunk = PSequence;
 80001b0:	4a0d      	ldr	r2, [pc, #52]	; (80001e8 <App_t::IPillHandler()+0x48>)
 80001b2:	4b0e      	ldr	r3, [pc, #56]	; (80001ec <App_t::IPillHandler()+0x4c>)
 80001b4:	615a      	str	r2, [r3, #20]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/peripheral.h:32
        chSysLock();
 80001b6:	2320      	movs	r3, #32
 80001b8:	f383 8811 	msr	BASEPRI, r3
 80001bc:	f000 fd78 	bl	8000cb0 <dbg_check_lock>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/peripheral.h:33
        BeepI(PSequence);
 80001c0:	480a      	ldr	r0, [pc, #40]	; (80001ec <App_t::IPillHandler()+0x4c>)
 80001c2:	4909      	ldr	r1, [pc, #36]	; (80001e8 <App_t::IPillHandler()+0x48>)
 80001c4:	f002 f95c 	bl	8002480 <Beeper_t::BeepI(BeepChunk_t const*)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/peripheral.h:34
        chSysUnlock();
 80001c8:	f000 fd8a 	bl	8000ce0 <dbg_check_unlock>
 80001cc:	2300      	movs	r3, #0
 80001ce:	f383 8811 	msr	BASEPRI, r3
_ZN5App_t12IPillHandlerEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:53
//        }
//    } // if Cure
    // Will be here in case of strange/discharged pill
    Beeper.Beep(BeepPillBad);
//    Led.StartBlink(LedPillBad);
    chThdSleep(2007);    // Let indication to complete
 80001d2:	f240 70d7 	movw	r0, #2007	; 0x7d7
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:55
//    Dose.ChangeIndication();
}
 80001d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:53
//        }
//    } // if Cure
    // Will be here in case of strange/discharged pill
    Beeper.Beep(BeepPillBad);
//    Led.StartBlink(LedPillBad);
    chThdSleep(2007);    // Let indication to complete
 80001da:	f001 b961 	b.w	80014a0 <chThdSleep>
 80001de:	bd08      	pop	{r3, pc}
 80001e0:	20000e2c 	.word	0x20000e2c
 80001e4:	20000800 	.word	0x20000800
 80001e8:	08002710 	.word	0x08002710
 80001ec:	20000e08 	.word	0x20000e08

080001f0 <AppThread(void*)>:
AppThread():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:84
#endif

#if 1 // ========================= Application =================================
static WORKING_AREA(waAppThread, 256);
__attribute__((noreturn))
static void AppThread(void *arg) {
 80001f0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:85
    chRegSetThreadName("App");
 80001f2:	4b0c      	ldr	r3, [pc, #48]	; (8000224 <AppThread(void*)+0x34>)
 80001f4:	4a0c      	ldr	r2, [pc, #48]	; (8000228 <AppThread(void*)+0x38>)
 80001f6:	699b      	ldr	r3, [r3, #24]
 80001f8:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:113
                if(!PillConnected) {
                    PillConnected = true;
                    App.IPillHandler();
                }
            }
            else PillConnected = false;
 80001fa:	2400      	movs	r4, #0
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:89
static void AppThread(void *arg) {
    chRegSetThreadName("App");
    uint32_t EvtMsk;
    bool PillConnected = false;
    while(true) {
        EvtMsk = chEvtWaitAny(ALL_EVENTS);
 80001fc:	f04f 30ff 	mov.w	r0, #4294967295
 8000200:	f000 fe7e 	bl	8000f00 <chEvtWaitAny>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:105
//        if(EvtMsk & EVTMSK_DOSE_STORE) {
//            //if(Dose.Save() != OK) Uart.Printf("EE Fail\r");   // DEBUG
//        }

        // ==== Check pill ====
        if(EvtMsk & EVTMSK_PILL_CHECK) {
 8000204:	0743      	lsls	r3, r0, #29
 8000206:	d5f9      	bpl.n	80001fc <AppThread(void*)+0xc>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:107
            // Check if new connection occured
            if(PillMgr.CheckIfConnected(PILL_I2C_ADDR) == OK) {
 8000208:	4808      	ldr	r0, [pc, #32]	; (800022c <AppThread(void*)+0x3c>)
 800020a:	2150      	movs	r1, #80	; 0x50
 800020c:	f002 f9d0 	bl	80025b0 <PillMgr_t::CheckIfConnected(unsigned char)>
 8000210:	2800      	cmp	r0, #0
 8000212:	d1f2      	bne.n	80001fa <AppThread(void*)+0xa>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:108
                if(!PillConnected) {
 8000214:	2c00      	cmp	r4, #0
 8000216:	d1f1      	bne.n	80001fc <AppThread(void*)+0xc>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:110
                    PillConnected = true;
                    App.IPillHandler();
 8000218:	4805      	ldr	r0, [pc, #20]	; (8000230 <AppThread(void*)+0x40>)
 800021a:	f7ff ffc1 	bl	80001a0 <App_t::IPillHandler()>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:109
        // ==== Check pill ====
        if(EvtMsk & EVTMSK_PILL_CHECK) {
            // Check if new connection occured
            if(PillMgr.CheckIfConnected(PILL_I2C_ADDR) == OK) {
                if(!PillConnected) {
                    PillConnected = true;
 800021e:	2401      	movs	r4, #1
 8000220:	e7ec      	b.n	80001fc <AppThread(void*)+0xc>
 8000222:	bf00      	nop
 8000224:	2000126c 	.word	0x2000126c
 8000228:	08002730 	.word	0x08002730
 800022c:	20000e2c 	.word	0x20000e2c
 8000230:	200009b8 	.word	0x200009b8
	...

08000240 <App_t::Init()>:
_ZN5App_t4InitEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:118
            else PillConnected = false;
        } // if EVTMSK_PILL_CHECK
    } // while 1
}

void App_t::Init() {
 8000240:	b513      	push	{r0, r1, r4, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:121
    //Dose.Load();
//    Uart.Printf("Dose = %u\r", Dose.Get());
    PThd = chThdCreateStatic(waAppThread, sizeof(waAppThread), NORMALPRIO, (tfunc_t)AppThread, NULL);
 8000242:	2300      	movs	r3, #0
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:118
            else PillConnected = false;
        } // if EVTMSK_PILL_CHECK
    } // while 1
}

void App_t::Init() {
 8000244:	4604      	mov	r4, r0
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:121
    //Dose.Load();
//    Uart.Printf("Dose = %u\r", Dose.Get());
    PThd = chThdCreateStatic(waAppThread, sizeof(waAppThread), NORMALPRIO, (tfunc_t)AppThread, NULL);
 8000246:	9300      	str	r3, [sp, #0]
 8000248:	f44f 71cc 	mov.w	r1, #408	; 0x198
 800024c:	2240      	movs	r2, #64	; 0x40
 800024e:	4b0c      	ldr	r3, [pc, #48]	; (8000280 <App_t::Init()+0x40>)
 8000250:	480c      	ldr	r0, [pc, #48]	; (8000284 <App_t::Init()+0x44>)
 8000252:	f001 f8f5 	bl	8001440 <chThdCreateStatic>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:123
    // Timers init
    chSysLock();
 8000256:	2320      	movs	r3, #32
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:121
}

void App_t::Init() {
    //Dose.Load();
//    Uart.Printf("Dose = %u\r", Dose.Get());
    PThd = chThdCreateStatic(waAppThread, sizeof(waAppThread), NORMALPRIO, (tfunc_t)AppThread, NULL);
 8000258:	6020      	str	r0, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:123
    // Timers init
    chSysLock();
 800025a:	f383 8811 	msr	BASEPRI, r3
 800025e:	f000 fd27 	bl	8000cb0 <dbg_check_lock>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:126
//    chVTSetI(&ITmrDose,      MS2ST(TM_DOSE_INCREASE_MS), TmrDoseCallback, nullptr);
//    chVTSetI(&ITmrDoseSave,  MS2ST(TM_DOSE_SAVE_MS),     TmrDoseSaveCallback, nullptr);
    chVTSetI(&ITmrPillCheck, MS2ST(TM_PILL_CHECK_MS),    TmrPillCheckCallback, nullptr);
 8000262:	4809      	ldr	r0, [pc, #36]	; (8000288 <App_t::Init()+0x48>)
 8000264:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
 8000268:	4a08      	ldr	r2, [pc, #32]	; (800028c <App_t::Init()+0x4c>)
 800026a:	2300      	movs	r3, #0
 800026c:	f001 f978 	bl	8001560 <chVTSetI>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:127
    chSysUnlock();
 8000270:	f000 fd36 	bl	8000ce0 <dbg_check_unlock>
 8000274:	2300      	movs	r3, #0
 8000276:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/application.cpp:128
}
 800027a:	b002      	add	sp, #8
 800027c:	bd10      	pop	{r4, pc}
 800027e:	bf00      	nop
 8000280:	080001f1 	.word	0x080001f1
 8000284:	20000820 	.word	0x20000820
 8000288:	20000808 	.word	0x20000808
 800028c:	08000161 	.word	0x08000161

08000290 <radio_t::ITask()>:
_ZN7radio_t5ITaskEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:39
}

//#define TX
#define RX

void radio_t::ITask() {
 8000290:	b538      	push	{r3, r4, r5, lr}
 8000292:	4605      	mov	r5, r0
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:66
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 8000294:	4c0f      	ldr	r4, [pc, #60]	; (80002d4 <radio_t::ITask()+0x44>)
 8000296:	7823      	ldrb	r3, [r4, #0]
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:63
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 8000298:	4620      	mov	r0, r4
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:66
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 800029a:	b12b      	cbz	r3, 80002a8 <radio_t::ITask()+0x18>
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:63
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 800029c:	2136      	movs	r1, #54	; 0x36
 800029e:	f000 f90f 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
 80002a2:	2300      	movs	r3, #0
 80002a4:	7623      	strb	r3, [r4, #24]
 80002a6:	e7f5      	b.n	8000294 <radio_t::ITask()+0x4>
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:67
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
        WriteStrobe(CC_SCAL);
 80002a8:	2133      	movs	r1, #51	; 0x33
 80002aa:	f000 f909 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
PinIsSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:127
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 80002ae:	4b0a      	ldr	r3, [pc, #40]	; (80002d8 <radio_t::ITask()+0x48>)
 80002b0:	8a1b      	ldrh	r3, [r3, #16]
_ZN8cc1101_t8BusyWaitEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:36
    PinIrq_t IGdo0;
    void CsHi() { PinSet(CC_GPIO, CC_CS); }
    void CsLo() { PinClear(CC_GPIO, CC_CS); }
    bool GDO0IsHi() { return PinIsSet(CC_GPIO, CC_GDO0); }
    bool GDO2IsHi() { return PinIsSet(CC_GPIO, CC_GDO2); }
    void BusyWait() { while(PinIsSet(CC_GPIO, CC_MISO)); }
 80002b2:	065b      	lsls	r3, r3, #25
 80002b4:	d4fb      	bmi.n	80002ae <radio_t::ITask()+0x1e>
_ZN7radio_t5ITaskEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:52
        CC.TransmitSync(&PktTx);
        DBG1_CLR();
        chThdSleepMilliseconds(99);

#elif defined RX
        uint8_t RxRslt = CC.ReceiveSync(306, &PktRx);
 80002b6:	4807      	ldr	r0, [pc, #28]	; (80002d4 <radio_t::ITask()+0x44>)
 80002b8:	f44f 7199 	mov.w	r1, #306	; 0x132
 80002bc:	462a      	mov	r2, r5
 80002be:	f000 f92f 	bl	8000520 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:53
        if(RxRslt == OK) {
 80002c2:	2800      	cmp	r0, #0
 80002c4:	d1e6      	bne.n	8000294 <radio_t::ITask()+0x4>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:54
            Uart.Printf("%d\r", PktRx.RSSI);
 80002c6:	4805      	ldr	r0, [pc, #20]	; (80002dc <radio_t::ITask()+0x4c>)
 80002c8:	4905      	ldr	r1, [pc, #20]	; (80002e0 <radio_t::ITask()+0x50>)
 80002ca:	f995 2001 	ldrsb.w	r2, [r5, #1]
 80002ce:	f001 fbd7 	bl	8001a80 <CmdUart_t::Printf(char const*, ...)>
 80002d2:	e7df      	b.n	8000294 <radio_t::ITask()+0x4>
 80002d4:	20000b60 	.word	0x20000b60
 80002d8:	40020000 	.word	0x40020000
 80002dc:	20000bfc 	.word	0x20000bfc
 80002e0:	08002750 	.word	0x08002750
	...

080002f0 <radioThread(void*)>:
radioThread():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:31
radio_t Radio;

#if 1 // ================================ Task =================================
static WORKING_AREA(warradioThread, 256);
__attribute__((noreturn))
static void radioThread(void *arg) {
 80002f0:	b508      	push	{r3, lr}
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:32
    chRegSetThreadName("radio");
 80002f2:	4b03      	ldr	r3, [pc, #12]	; (8000300 <radioThread(void*)+0x10>)
 80002f4:	4a03      	ldr	r2, [pc, #12]	; (8000304 <radioThread(void*)+0x14>)
 80002f6:	699b      	ldr	r3, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:33
    while(true) Radio.ITask();
 80002f8:	4803      	ldr	r0, [pc, #12]	; (8000308 <radioThread(void*)+0x18>)
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:32

#if 1 // ================================ Task =================================
static WORKING_AREA(warradioThread, 256);
__attribute__((noreturn))
static void radioThread(void *arg) {
    chRegSetThreadName("radio");
 80002fa:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:33
    while(true) Radio.ITask();
 80002fc:	f7ff ffc8 	bl	8000290 <radio_t::ITask()>
 8000300:	2000126c 	.word	0x2000126c
 8000304:	08002754 	.word	0x08002754
 8000308:	200009bc 	.word	0x200009bc
$d():
 800030c:	00000000 	.word	0x00000000

08000310 <radio_t::Init(unsigned short)>:
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8000310:	4b20      	ldr	r3, [pc, #128]	; (8000394 <radio_t::Init(unsigned short)+0x84>)
_ZN7radio_t4InitEt():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:67
}

#endif

#if 1 // ============================
void radio_t::Init(uint16_t ASelfID) {
 8000312:	b537      	push	{r0, r1, r2, r4, r5, lr}
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8000314:	69da      	ldr	r2, [r3, #28]
_ZN7radio_t4InitEt():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:72
#ifdef DBG_PINS
    PinSetupOut(DBG_GPIO1, DBG_PIN1, omPushPull);
#endif
    // Init radioIC
    CC.Init();
 8000316:	4c20      	ldr	r4, [pc, #128]	; (8000398 <radio_t::Init(unsigned short)+0x88>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8000318:	f042 0202 	orr.w	r2, r2, #2
 800031c:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800031e:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 8000322:	681a      	ldr	r2, [r3, #0]
_ZN7radio_t4InitEt():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:67
}

#endif

#if 1 // ============================
void radio_t::Init(uint16_t ASelfID) {
 8000324:	4605      	mov	r5, r0
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
 8000326:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800032a:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 800032c:	681a      	ldr	r2, [r3, #0]
_ZN7radio_t4InitEt():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:72
#ifdef DBG_PINS
    PinSetupOut(DBG_GPIO1, DBG_PIN1, omPushPull);
#endif
    // Init radioIC
    CC.Init();
 800032e:	4620      	mov	r0, r4
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
 8000330:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000334:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000336:	889a      	ldrh	r2, [r3, #4]
 8000338:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800033c:	0412      	lsls	r2, r2, #16
 800033e:	0c12      	lsrs	r2, r2, #16
 8000340:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000342:	889a      	ldrh	r2, [r3, #4]
 8000344:	b292      	uxth	r2, r2
 8000346:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000348:	68da      	ldr	r2, [r3, #12]
 800034a:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800034e:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000350:	68da      	ldr	r2, [r3, #12]
 8000352:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000354:	689a      	ldr	r2, [r3, #8]
 8000356:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800035a:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800035c:	689a      	ldr	r2, [r3, #8]
 800035e:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8000362:	609a      	str	r2, [r3, #8]
_ZN7radio_t4InitEt():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:72
 8000364:	f000 f9cc 	bl	8000700 <cc1101_t::Init()>
_ZN8cc1101_t10SetTxPowerEh():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Radio/cc1101.h:57
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
public:
    CCState_t State;
    void Init();
    void SetChannel(uint8_t AChannel);
    void SetTxPower(uint8_t APwr) { WriteRegister(CC_PATABLE, APwr); }
 8000368:	4620      	mov	r0, r4
 800036a:	2250      	movs	r2, #80	; 0x50
 800036c:	213e      	movs	r1, #62	; 0x3e
 800036e:	f000 f88f 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
_ZN7radio_t4InitEt():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:74
    CC.SetTxPower(CC_Pwr0dBm);
    CC.SetChannel(CHANNEL_ZERO);
 8000372:	4620      	mov	r0, r4
 8000374:	2100      	movs	r1, #0
 8000376:	f000 f8c3 	bl	8000500 <cc1101_t::SetChannel(unsigned char)>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:76
    // Thread
    PThread = chThdCreateStatic(warradioThread, sizeof(warradioThread), HIGHPRIO, (tfunc_t)radioThread, NULL);
 800037a:	2300      	movs	r3, #0
 800037c:	9300      	str	r3, [sp, #0]
 800037e:	f44f 71cc 	mov.w	r1, #408	; 0x198
 8000382:	227f      	movs	r2, #127	; 0x7f
 8000384:	4b05      	ldr	r3, [pc, #20]	; (800039c <radio_t::Init(unsigned short)+0x8c>)
 8000386:	4806      	ldr	r0, [pc, #24]	; (80003a0 <radio_t::Init(unsigned short)+0x90>)
 8000388:	f001 f85a 	bl	8001440 <chThdCreateStatic>
 800038c:	6068      	str	r0, [r5, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../src/radio.cpp:77
}
 800038e:	b003      	add	sp, #12
 8000390:	bd30      	pop	{r4, r5, pc}
 8000392:	bf00      	nop
 8000394:	40023800 	.word	0x40023800
 8000398:	20000b60 	.word	0x20000b60
 800039c:	080002f1 	.word	0x080002f1
 80003a0:	200009c8 	.word	0x200009c8
	...

080003b0 <cc1101_t::BusyWait() [clone .isra.6]>:
PinIsSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:127
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 80003b0:	4b02      	ldr	r3, [pc, #8]	; (80003bc <cc1101_t::BusyWait() [clone .isra.6]+0xc>)
 80003b2:	8a1b      	ldrh	r3, [r3, #16]
_ZN8cc1101_t8BusyWaitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:36
    PinIrq_t IGdo0;
    void CsHi() { PinSet(CC_GPIO, CC_CS); }
    void CsLo() { PinClear(CC_GPIO, CC_CS); }
    bool GDO0IsHi() { return PinIsSet(CC_GPIO, CC_GDO0); }
    bool GDO2IsHi() { return PinIsSet(CC_GPIO, CC_GDO2); }
    void BusyWait() { while(PinIsSet(CC_GPIO, CC_MISO)); }
 80003b4:	065b      	lsls	r3, r3, #25
 80003b6:	d4fb      	bmi.n	80003b0 <cc1101_t::BusyWait() [clone .isra.6]>
 80003b8:	4770      	bx	lr
 80003ba:	bf00      	nop
 80003bc:	40020000 	.word	0x40020000

080003c0 <Spi_t::ReadWriteByte(unsigned char)>:
_ZN5Spi_t13ReadWriteByteEh():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:427
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
    void Disable() { PSpi->CR1 &= ~SPI_CR1_SPE; }
    void EnableTxDma() { PSpi->CR2 |= SPI_CR2_TXDMAEN; }
    void WaitBsyHi2Lo() { while(PSpi->SR & SPI_SR_BSY); }
    uint8_t ReadWriteByte(uint8_t AByte) {
        PSpi->DR = AByte;
 80003c0:	6803      	ldr	r3, [r0, #0]
 80003c2:	8199      	strh	r1, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:428 (discriminator 1)
        while(!(PSpi->SR & SPI_SR_RXNE));  // Wait for SPI transmission to complete
 80003c4:	891a      	ldrh	r2, [r3, #8]
 80003c6:	07d2      	lsls	r2, r2, #31
 80003c8:	d5fc      	bpl.n	80003c4 <Spi_t::ReadWriteByte(unsigned char)+0x4>
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:429
        return PSpi->DR;
 80003ca:	8998      	ldrh	r0, [r3, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:430
    }
 80003cc:	b2c0      	uxtb	r0, r0
 80003ce:	4770      	bx	lr

080003d0 <cc1101_t::RSSI_dBm(unsigned char)>:
_ZN8cc1101_t8RSSI_dBmEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:112
}

// Return RSSI in dBm
int8_t cc1101_t::RSSI_dBm(uint8_t ARawRSSI) {
    int16_t RSSI = ARawRSSI;
    if(RSSI >= 128) RSSI -= 256;
 80003d0:	297f      	cmp	r1, #127	; 0x7f
 80003d2:	bfc4      	itt	gt
 80003d4:	f5a1 7180 	subgt.w	r1, r1, #256	; 0x100
 80003d8:	b289      	uxthgt	r1, r1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:113
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
 80003da:	b208      	sxth	r0, r1
 80003dc:	2302      	movs	r3, #2
 80003de:	fb90 f0f3 	sdiv	r0, r0, r3
 80003e2:	384a      	subs	r0, #74	; 0x4a
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:115
    return RSSI;
}
 80003e4:	b240      	sxtb	r0, r0
 80003e6:	4770      	bx	lr
	...

080003f0 <cc1101_t::ReadRegister(unsigned char)>:
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:148
    uint8_t rssi = ReadRegister(CC_RSSI);
    return RSSI_dBm(rssi);
}

// =========================== Registers & Strobes =============================
uint8_t cc1101_t::ReadRegister(uint8_t ARegAddr) {
 80003f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80003f2:	4c09      	ldr	r4, [pc, #36]	; (8000418 <cc1101_t::ReadRegister(unsigned char)+0x28>)
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:148
 80003f4:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 80003f6:	2510      	movs	r5, #16
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:148
 80003f8:	460f      	mov	r7, r1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:151
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
 80003fa:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 80003fc:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:150
}

// =========================== Registers & Strobes =============================
uint8_t cc1101_t::ReadRegister(uint8_t ARegAddr) {
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 80003fe:	f7ff ffd7 	bl	80003b0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:151
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
 8000402:	f047 0180 	orr.w	r1, r7, #128	; 0x80
 8000406:	4630      	mov	r0, r6
 8000408:	f7ff ffda 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:152
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
 800040c:	4630      	mov	r0, r6
 800040e:	2100      	movs	r1, #0
 8000410:	f7ff ffd6 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000414:	8325      	strh	r5, [r4, #24]
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:155
    CsHi();                                 // End transmission
    return FReply;
}
 8000416:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000418:	40020000 	.word	0x40020000
$d():
 800041c:	00000000 	.word	0x00000000

08000420 <cc1101_t::ReadFIFO(rPkt_t*)>:
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:117
    if(RSSI >= 128) RSSI -= 256;
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
    return RSSI;
}

uint8_t cc1101_t::ReadFIFO(rPkt_t *pPkt) {
 8000420:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000424:	460d      	mov	r5, r1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:120
    uint8_t b, *p = (uint8_t*)pPkt;
    // Check if received successfully
    b = ReadRegister(CC_PKTSTATUS);
 8000426:	2178      	movs	r1, #120	; 0x78
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:117
    if(RSSI >= 128) RSSI -= 256;
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
    return RSSI;
}

uint8_t cc1101_t::ReadFIFO(rPkt_t *pPkt) {
 8000428:	4606      	mov	r6, r0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:120
    uint8_t b, *p = (uint8_t*)pPkt;
    // Check if received successfully
    b = ReadRegister(CC_PKTSTATUS);
 800042a:	f7ff ffe1 	bl	80003f0 <cc1101_t::ReadRegister(unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:122
    //    Uart.Printf("St: %X  ", b);
    if(b & 0x80) {  // CRC OK
 800042e:	0603      	lsls	r3, r0, #24
 8000430:	d524      	bpl.n	800047c <cc1101_t::ReadFIFO(rPkt_t*)+0x5c>
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000432:	4f14      	ldr	r7, [pc, #80]	; (8000484 <cc1101_t::ReadFIFO(rPkt_t*)+0x64>)
 8000434:	f04f 0810 	mov.w	r8, #16
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:126
        // Read FIFO
        CsLo();                                            // Start transmission
        BusyWait();                             // Wait for chip to become ready
        ISpi.ReadWriteByte(CC_FIFO | CC_READ_FLAG | CC_BURST_FLAG); // Address with read & burst flags
 8000438:	f106 0408 	add.w	r4, r6, #8
_ZN8cc1101_t4CsLoEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 800043c:	f8a7 801a 	strh.w	r8, [r7, #26]
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:125
    b = ReadRegister(CC_PKTSTATUS);
    //    Uart.Printf("St: %X  ", b);
    if(b & 0x80) {  // CRC OK
        // Read FIFO
        CsLo();                                            // Start transmission
        BusyWait();                             // Wait for chip to become ready
 8000440:	f7ff ffb6 	bl	80003b0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:126
        ISpi.ReadWriteByte(CC_FIFO | CC_READ_FLAG | CC_BURST_FLAG); // Address with read & burst flags
 8000444:	4620      	mov	r0, r4
 8000446:	21ff      	movs	r1, #255	; 0xff
 8000448:	f7ff ffba 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:128
        for(uint8_t i = 0; i < RPKT_LEN; i++) {                // Read bytes
            b = ISpi.ReadWriteByte(0);
 800044c:	4620      	mov	r0, r4
 800044e:	2100      	movs	r1, #0
 8000450:	f7ff ffb6 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:133
            *p++ = b;
            // Uart.Printf(" %X", b);
        }
        // Receive two additional info bytes
        b = ISpi.ReadWriteByte(0); // RSSI
 8000454:	2100      	movs	r1, #0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:129
        CsLo();                                            // Start transmission
        BusyWait();                             // Wait for chip to become ready
        ISpi.ReadWriteByte(CC_FIFO | CC_READ_FLAG | CC_BURST_FLAG); // Address with read & burst flags
        for(uint8_t i = 0; i < RPKT_LEN; i++) {                // Read bytes
            b = ISpi.ReadWriteByte(0);
            *p++ = b;
 8000456:	7028      	strb	r0, [r5, #0]
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:133
            // Uart.Printf(" %X", b);
        }
        // Receive two additional info bytes
        b = ISpi.ReadWriteByte(0); // RSSI
 8000458:	4620      	mov	r0, r4
 800045a:	f7ff ffb1 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:134
        ISpi.ReadWriteByte(0);     // LQI
 800045e:	2100      	movs	r1, #0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:133
            b = ISpi.ReadWriteByte(0);
            *p++ = b;
            // Uart.Printf(" %X", b);
        }
        // Receive two additional info bytes
        b = ISpi.ReadWriteByte(0); // RSSI
 8000460:	4681      	mov	r9, r0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:134
        ISpi.ReadWriteByte(0);     // LQI
 8000462:	4620      	mov	r0, r4
 8000464:	f7ff ffac 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000468:	f8a7 8018 	strh.w	r8, [r7, #24]
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:136
        CsHi();                    // End transmission
        pPkt->RSSI = RSSI_dBm(b);
 800046c:	4630      	mov	r0, r6
 800046e:	4649      	mov	r1, r9
 8000470:	f7ff ffae 	bl	80003d0 <cc1101_t::RSSI_dBm(unsigned char)>
 8000474:	7068      	strb	r0, [r5, #1]
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:137
        return OK;
 8000476:	2000      	movs	r0, #0
 8000478:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:139
    }
    else return FAILURE;
 800047c:	2001      	movs	r0, #1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:140
}
 800047e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000482:	bf00      	nop
 8000484:	40020000 	.word	0x40020000
	...

08000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>:
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:156
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister(uint8_t ARegAddr, uint8_t AData) {
 8000490:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000494:	4c09      	ldr	r4, [pc, #36]	; (80004bc <cc1101_t::WriteRegister(unsigned char, unsigned char)+0x2c>)
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:156
 8000496:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 8000498:	2510      	movs	r5, #16
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:156
 800049a:	4688      	mov	r8, r1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:159
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 800049c:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 800049e:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:156
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister(uint8_t ARegAddr, uint8_t AData) {
 80004a0:	4617      	mov	r7, r2
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:158
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
 80004a2:	f7ff ff85 	bl	80003b0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:159
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 80004a6:	4641      	mov	r1, r8
 80004a8:	4630      	mov	r0, r6
 80004aa:	f7ff ff89 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:160
    ISpi.ReadWriteByte(AData);      // Write data
 80004ae:	4630      	mov	r0, r6
 80004b0:	4639      	mov	r1, r7
 80004b2:	f7ff ff85 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 80004b6:	8325      	strh	r5, [r4, #24]
 80004b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80004bc:	40020000 	.word	0x40020000

080004c0 <cc1101_t::WriteStrobe(unsigned char)>:
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:163
    CsHi();                         // End transmission
}
void cc1101_t::WriteStrobe(uint8_t AStrobe) {
 80004c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80004c2:	4d09      	ldr	r5, [pc, #36]	; (80004e8 <cc1101_t::WriteStrobe(unsigned char)+0x28>)
 80004c4:	2610      	movs	r6, #16
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:163
 80004c6:	4604      	mov	r4, r0
 80004c8:	460f      	mov	r7, r1
_ZN8cc1101_t4CsLoEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 80004ca:	836e      	strh	r6, [r5, #26]
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:165
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 80004cc:	f7ff ff70 	bl	80003b0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:166
    IState = ISpi.ReadWriteByte(AStrobe);   // Write strobe
 80004d0:	f104 0008 	add.w	r0, r4, #8
 80004d4:	4639      	mov	r1, r7
 80004d6:	f7ff ff73 	bl	80003c0 <Spi_t::ReadWriteByte(unsigned char)>
 80004da:	7020      	strb	r0, [r4, #0]
PinSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 80004dc:	832e      	strh	r6, [r5, #24]
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:168
    CsHi();                                 // End transmission
    IState &= 0b01110000;                   // Mask needed bits
 80004de:	7823      	ldrb	r3, [r4, #0]
 80004e0:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80004e4:	7023      	strb	r3, [r4, #0]
 80004e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80004e8:	40020000 	.word	0x40020000
$d():
 80004ec:	00000000 	.word	0x00000000

080004f0 <cc1101_t::EnterIdle()>:
_ZN8cc1101_t9EnterIdleEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:63
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 80004f0:	b510      	push	{r4, lr}
 80004f2:	2136      	movs	r1, #54	; 0x36
 80004f4:	4604      	mov	r4, r0
 80004f6:	f7ff ffe3 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
 80004fa:	2300      	movs	r3, #0
 80004fc:	7623      	strb	r3, [r4, #24]
 80004fe:	bd10      	pop	{r4, pc}

08000500 <cc1101_t::SetChannel(unsigned char)>:
_ZN8cc1101_t10SetChannelEh():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:40
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIRQ(IRQ_PRIO_MEDIUM);
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
 8000500:	b538      	push	{r3, r4, r5, lr}
 8000502:	4604      	mov	r4, r0
 8000504:	460d      	mov	r5, r1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:41 (discriminator 1)
    while(IState != CC_STB_IDLE)
 8000506:	7823      	ldrb	r3, [r4, #0]
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:42 (discriminator 1)
        EnterIdle();   // CC must be in IDLE mode
 8000508:	4620      	mov	r0, r4
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:41 (discriminator 1)
    IGdo0.EnableIRQ(IRQ_PRIO_MEDIUM);
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
    while(IState != CC_STB_IDLE)
 800050a:	b113      	cbz	r3, 8000512 <cc1101_t::SetChannel(unsigned char)+0x12>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:42
        EnterIdle();   // CC must be in IDLE mode
 800050c:	f7ff fff0 	bl	80004f0 <cc1101_t::EnterIdle()>
 8000510:	e7f9      	b.n	8000506 <cc1101_t::SetChannel(unsigned char)+0x6>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:43
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 8000512:	462a      	mov	r2, r5
 8000514:	210a      	movs	r1, #10
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:44
}
 8000516:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:43

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
    while(IState != CC_STB_IDLE)
        EnterIdle();   // CC must be in IDLE mode
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 800051a:	f7ff bfb9 	b.w	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

08000520 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)>:
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:84
}

/*
 * Enter RX mode and wait reception for Timeout_ms.
 */
uint8_t cc1101_t::ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt) {
 8000520:	b570      	push	{r4, r5, r6, lr}
 8000522:	460d      	mov	r5, r1
_ZN8cc1101_t11FlushRxFIFOEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:52
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 8000524:	213a      	movs	r1, #58	; 0x3a
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:84
 8000526:	4604      	mov	r4, r0
 8000528:	4616      	mov	r6, r2
_ZN8cc1101_t11FlushRxFIFOEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:52
 800052a:	f7ff ffc9 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:86
    FlushRxFIFO();
    chSysLock()
 800052e:	2320      	movs	r3, #32
 8000530:	f383 8811 	msr	BASEPRI, r3
 8000534:	f000 fbbc 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:88
    ;
    PWaitingThread = chThdSelf();
 8000538:	4b11      	ldr	r3, [pc, #68]	; (8000580 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)+0x60>)
_ZN8cc1101_t7EnterRXEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:51
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
 800053a:	2134      	movs	r1, #52	; 0x34
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:88
 800053c:	6998      	ldr	r0, [r3, #24]
 800053e:	6060      	str	r0, [r4, #4]
_ZN8cc1101_t7EnterRXEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:51
 8000540:	4620      	mov	r0, r4
 8000542:	f7ff ffbd 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:90
    EnterRX(); // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
 8000546:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800054a:	435d      	muls	r5, r3
 800054c:	f5a5 757a 	sub.w	r5, r5, #1000	; 0x3e8
 8000550:	fbb5 f1f3 	udiv	r1, r5, r3
 8000554:	3101      	adds	r1, #1
 8000556:	2002      	movs	r0, #2
 8000558:	f000 fd72 	bl	8001040 <chSchGoSleepTimeoutS>
 800055c:	4605      	mov	r5, r0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:91
    chSysUnlock()
 800055e:	f000 fbbf 	bl	8000ce0 <dbg_check_unlock>
 8000562:	2300      	movs	r3, #0
 8000564:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:94
    ; // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
 8000568:	3501      	adds	r5, #1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:95
        EnterIdle();            // Get out of RX mode
 800056a:	4620      	mov	r0, r4
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:94
    EnterRX(); // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
    chSysUnlock()
    ; // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
 800056c:	d004      	beq.n	8000578 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)+0x58>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:99
        EnterIdle();            // Get out of RX mode
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
 800056e:	4631      	mov	r1, r6
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:100
}
 8000570:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:99
    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
        EnterIdle();            // Get out of RX mode
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
 8000574:	f7ff bf54 	b.w	8000420 <cc1101_t::ReadFIFO(rPkt_t*)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:95
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
    chSysUnlock()
    ; // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
        EnterIdle();            // Get out of RX mode
 8000578:	f7ff ffba 	bl	80004f0 <cc1101_t::EnterIdle()>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:100
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
}
 800057c:	2002      	movs	r0, #2
 800057e:	bd70      	pop	{r4, r5, r6, pc}
 8000580:	2000126c 	.word	0x2000126c
	...

08000590 <cc1101_t::RfConfig()>:
_ZN8cc1101_t8RfConfigEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:187
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 8000590:	b510      	push	{r4, lr}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:188
    WriteRegister(CC_FSCTRL1, CC_FSCTRL1_VALUE); // Frequency synthesizer control.
 8000592:	210b      	movs	r1, #11
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:187
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 8000594:	4604      	mov	r4, r0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:188
    WriteRegister(CC_FSCTRL1, CC_FSCTRL1_VALUE); // Frequency synthesizer control.
 8000596:	220c      	movs	r2, #12
 8000598:	f7ff ff7a 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:189
    WriteRegister(CC_FSCTRL0, CC_FSCTRL0_VALUE); // Frequency synthesizer control.
 800059c:	4620      	mov	r0, r4
 800059e:	210c      	movs	r1, #12
 80005a0:	2200      	movs	r2, #0
 80005a2:	f7ff ff75 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:190
    WriteRegister(CC_FREQ2, CC_FREQ2_VALUE); // Frequency control word, high byte.
 80005a6:	4620      	mov	r0, r4
 80005a8:	210d      	movs	r1, #13
 80005aa:	2220      	movs	r2, #32
 80005ac:	f7ff ff70 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:191
    WriteRegister(CC_FREQ1, CC_FREQ1_VALUE); // Frequency control word, middle byte.
 80005b0:	4620      	mov	r0, r4
 80005b2:	210e      	movs	r1, #14
 80005b4:	2225      	movs	r2, #37	; 0x25
 80005b6:	f7ff ff6b 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:192
    WriteRegister(CC_FREQ0, CC_FREQ0_VALUE); // Frequency control word, low byte.
 80005ba:	4620      	mov	r0, r4
 80005bc:	210f      	movs	r1, #15
 80005be:	22ed      	movs	r2, #237	; 0xed
 80005c0:	f7ff ff66 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:193
    WriteRegister(CC_MDMCFG4, CC_MDMCFG4_VALUE);    // Modem configuration.
 80005c4:	4620      	mov	r0, r4
 80005c6:	2110      	movs	r1, #16
 80005c8:	222d      	movs	r2, #45	; 0x2d
 80005ca:	f7ff ff61 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:194
    WriteRegister(CC_MDMCFG3, CC_MDMCFG3_VALUE);    // Modem configuration.
 80005ce:	4620      	mov	r0, r4
 80005d0:	2111      	movs	r1, #17
 80005d2:	222f      	movs	r2, #47	; 0x2f
 80005d4:	f7ff ff5c 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:195
    WriteRegister(CC_MDMCFG2, CC_MDMCFG2_VALUE);    // Modem configuration.
 80005d8:	4620      	mov	r0, r4
 80005da:	2112      	movs	r1, #18
 80005dc:	2200      	movs	r2, #0
 80005de:	f7ff ff57 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:196
    WriteRegister(CC_MDMCFG1, CC_MDMCFG1_VALUE);    // Modem configuration.
 80005e2:	4620      	mov	r0, r4
 80005e4:	2113      	movs	r1, #19
 80005e6:	2222      	movs	r2, #34	; 0x22
 80005e8:	f7ff ff52 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:197
    WriteRegister(CC_MDMCFG0, CC_MDMCFG0_VALUE);    // Modem configuration.
 80005ec:	4620      	mov	r0, r4
 80005ee:	2114      	movs	r1, #20
 80005f0:	22e5      	movs	r2, #229	; 0xe5
 80005f2:	f7ff ff4d 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:198
    WriteRegister(CC_CHANNR, CC_CHANNR_VALUE);     // Channel number.
 80005f6:	4620      	mov	r0, r4
 80005f8:	210a      	movs	r1, #10
 80005fa:	2200      	movs	r2, #0
 80005fc:	f7ff ff48 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:199
    WriteRegister(CC_DEVIATN, CC_DEVIATN_VALUE); // Modem deviation setting (when FSK modulation is enabled).
 8000600:	4620      	mov	r0, r4
 8000602:	2115      	movs	r1, #21
 8000604:	2262      	movs	r2, #98	; 0x62
 8000606:	f7ff ff43 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:200
    WriteRegister(CC_FREND1, CC_FREND1_VALUE);    // Front end RX configuration.
 800060a:	4620      	mov	r0, r4
 800060c:	2121      	movs	r1, #33	; 0x21
 800060e:	22b6      	movs	r2, #182	; 0xb6
 8000610:	f7ff ff3e 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:201
    WriteRegister(CC_FREND0, CC_FREND0_VALUE);    // Front end RX configuration.
 8000614:	4620      	mov	r0, r4
 8000616:	2122      	movs	r1, #34	; 0x22
 8000618:	2210      	movs	r2, #16
 800061a:	f7ff ff39 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:202
    WriteRegister(CC_MCSM0, CC_MCSM0_VALUE); // Main Radio Control State Machine configuration.
 800061e:	4620      	mov	r0, r4
 8000620:	2118      	movs	r1, #24
 8000622:	2208      	movs	r2, #8
 8000624:	f7ff ff34 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:203
    WriteRegister(CC_FOCCFG, CC_FOCCFG_VALUE); // Frequency Offset Compensation Configuration.
 8000628:	4620      	mov	r0, r4
 800062a:	2119      	movs	r1, #25
 800062c:	221d      	movs	r2, #29
 800062e:	f7ff ff2f 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:204
    WriteRegister(CC_BSCFG, CC_BSCFG_VALUE); // Bit synchronization Configuration.
 8000632:	4620      	mov	r0, r4
 8000634:	211a      	movs	r1, #26
 8000636:	221c      	movs	r2, #28
 8000638:	f7ff ff2a 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:205
    WriteRegister(CC_AGCCTRL2, CC_AGCCTRL2_VALUE);   // AGC control.
 800063c:	4620      	mov	r0, r4
 800063e:	211b      	movs	r1, #27
 8000640:	22c7      	movs	r2, #199	; 0xc7
 8000642:	f7ff ff25 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:206
    WriteRegister(CC_AGCCTRL1, CC_AGCCTRL1_VALUE);   // AGC control.
 8000646:	4620      	mov	r0, r4
 8000648:	211c      	movs	r1, #28
 800064a:	2200      	movs	r2, #0
 800064c:	f7ff ff20 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:207
    WriteRegister(CC_AGCCTRL0, CC_AGCCTRL0_VALUE);   // AGC control.
 8000650:	4620      	mov	r0, r4
 8000652:	211d      	movs	r1, #29
 8000654:	22b0      	movs	r2, #176	; 0xb0
 8000656:	f7ff ff1b 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:208
    WriteRegister(CC_FSCAL3, CC_FSCAL3_VALUE); // Frequency synthesizer calibration.
 800065a:	4620      	mov	r0, r4
 800065c:	2123      	movs	r1, #35	; 0x23
 800065e:	22ea      	movs	r2, #234	; 0xea
 8000660:	f7ff ff16 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:209
    WriteRegister(CC_FSCAL2, CC_FSCAL2_VALUE); // Frequency synthesizer calibration.
 8000664:	4620      	mov	r0, r4
 8000666:	2124      	movs	r1, #36	; 0x24
 8000668:	222a      	movs	r2, #42	; 0x2a
 800066a:	f7ff ff11 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:210
    WriteRegister(CC_FSCAL1, CC_FSCAL1_VALUE); // Frequency synthesizer calibration.
 800066e:	4620      	mov	r0, r4
 8000670:	2125      	movs	r1, #37	; 0x25
 8000672:	2200      	movs	r2, #0
 8000674:	f7ff ff0c 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:211
    WriteRegister(CC_FSCAL0, CC_FSCAL0_VALUE); // Frequency synthesizer calibration.
 8000678:	4620      	mov	r0, r4
 800067a:	2126      	movs	r1, #38	; 0x26
 800067c:	221f      	movs	r2, #31
 800067e:	f7ff ff07 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:212
    WriteRegister(CC_TEST2, CC_TEST2_VALUE);      // Various test settings.
 8000682:	4620      	mov	r0, r4
 8000684:	212c      	movs	r1, #44	; 0x2c
 8000686:	2288      	movs	r2, #136	; 0x88
 8000688:	f7ff ff02 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:213
    WriteRegister(CC_TEST1, CC_TEST1_VALUE);      // Various test settings.
 800068c:	4620      	mov	r0, r4
 800068e:	212d      	movs	r1, #45	; 0x2d
 8000690:	2231      	movs	r2, #49	; 0x31
 8000692:	f7ff fefd 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:214
    WriteRegister(CC_TEST0, CC_TEST0_VALUE);      // Various test settings.
 8000696:	4620      	mov	r0, r4
 8000698:	212e      	movs	r1, #46	; 0x2e
 800069a:	2209      	movs	r2, #9
 800069c:	f7ff fef8 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:215
    WriteRegister(CC_FIFOTHR, CC_FIFOTHR_VALUE);    // fifo threshold
 80006a0:	4620      	mov	r0, r4
 80006a2:	2103      	movs	r1, #3
 80006a4:	2207      	movs	r2, #7
 80006a6:	f7ff fef3 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:216
    WriteRegister(CC_IOCFG2, CC_IOCFG2_VALUE); // GDO2 output pin configuration.
 80006aa:	4620      	mov	r0, r4
 80006ac:	2100      	movs	r1, #0
 80006ae:	220c      	movs	r2, #12
 80006b0:	f7ff feee 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:217
    WriteRegister(CC_IOCFG0, CC_IOCFG0_VALUE); // GDO0 output pin configuration.
 80006b4:	4620      	mov	r0, r4
 80006b6:	2102      	movs	r1, #2
 80006b8:	220b      	movs	r2, #11
 80006ba:	f7ff fee9 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:218
    WriteRegister(CC_PKTCTRL1, CC_PKTCTRL1_VALUE); // Packet automation control.
 80006be:	4620      	mov	r0, r4
 80006c0:	2107      	movs	r1, #7
 80006c2:	220c      	movs	r2, #12
 80006c4:	f7ff fee4 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:219
    WriteRegister(CC_PKTCTRL0, CC_PKTCTRL0_VALUE); // Packet automation control.
 80006c8:	4620      	mov	r0, r4
 80006ca:	2108      	movs	r1, #8
 80006cc:	2212      	movs	r2, #18
 80006ce:	f7ff fedf 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:220
    WriteRegister(CC_PKTLEN, RPKT_LEN);            // Packet length, dummy
 80006d2:	4620      	mov	r0, r4
 80006d4:	2106      	movs	r1, #6
 80006d6:	2201      	movs	r2, #1
 80006d8:	f7ff feda 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:222

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);
 80006dc:	4620      	mov	r0, r4
 80006de:	213e      	movs	r1, #62	; 0x3e
 80006e0:	2250      	movs	r2, #80	; 0x50
 80006e2:	f7ff fed5 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:224

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
 80006e6:	4620      	mov	r0, r4
 80006e8:	2116      	movs	r1, #22
 80006ea:	2207      	movs	r2, #7
 80006ec:	f7ff fed0 	bl	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:225
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 80006f0:	4620      	mov	r0, r4
 80006f2:	2117      	movs	r1, #23
 80006f4:	2200      	movs	r2, #0
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:226
}
 80006f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:225
    WriteRegister(CC_PKTLEN, RPKT_LEN);            // Packet length, dummy

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 80006fa:	f7ff bec9 	b.w	8000490 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

08000700 <cc1101_t::Init()>:
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:13
#include "cc1101.h"
#include "ch.h"

cc1101_t CC;

void cc1101_t::Init() {
 8000700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000702:	4d8d      	ldr	r5, [pc, #564]	; (8000938 <cc1101_t::Init()+0x238>)
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000704:	4c8d      	ldr	r4, [pc, #564]	; (800093c <cc1101_t::Init()+0x23c>)
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000706:	69eb      	ldr	r3, [r5, #28]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:419
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
        PSpi->CR2 = 0;
 8000708:	2700      	movs	r7, #0
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 800070a:	f043 0301 	orr.w	r3, r3, #1
 800070e:	61eb      	str	r3, [r5, #28]
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000710:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:13
 8000712:	4606      	mov	r6, r0
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
 8000714:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000718:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 800071a:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t6CResetEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:47
    void WriteRegister (const uint8_t Addr, const uint8_t AData);
    uint8_t ReadRegister (const uint8_t Addr);
    void WriteStrobe(uint8_t AStrobe);
    void WriteTX(uint8_t* Ptr, uint8_t Length);
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
 800071c:	2130      	movs	r1, #48	; 0x30
PinSetupOut():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
 800071e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000722:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000724:	88a3      	ldrh	r3, [r4, #4]
 8000726:	f023 0310 	bic.w	r3, r3, #16
 800072a:	041b      	lsls	r3, r3, #16
 800072c:	0c1b      	lsrs	r3, r3, #16
 800072e:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000730:	88a3      	ldrh	r3, [r4, #4]
 8000732:	b29b      	uxth	r3, r3
 8000734:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000736:	68e3      	ldr	r3, [r4, #12]
 8000738:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800073c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800073e:	68e3      	ldr	r3, [r4, #12]
 8000740:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000742:	68a3      	ldr	r3, [r4, #8]
 8000744:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000748:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800074a:	68a3      	ldr	r3, [r4, #8]
 800074c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8000750:	60a3      	str	r3, [r4, #8]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000752:	69eb      	ldr	r3, [r5, #28]
 8000754:	f043 0301 	orr.w	r3, r3, #1
 8000758:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800075a:	6823      	ldr	r3, [r4, #0]
 800075c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8000760:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8000762:	6823      	ldr	r3, [r4, #0]
 8000764:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000768:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 800076a:	88a3      	ldrh	r3, [r4, #4]
 800076c:	f023 0320 	bic.w	r3, r3, #32
 8000770:	041b      	lsls	r3, r3, #16
 8000772:	0c1b      	lsrs	r3, r3, #16
 8000774:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000776:	88a3      	ldrh	r3, [r4, #4]
 8000778:	b29b      	uxth	r3, r3
 800077a:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 800077c:	68e3      	ldr	r3, [r4, #12]
 800077e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8000782:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000784:	68e3      	ldr	r3, [r4, #12]
 8000786:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000788:	68a3      	ldr	r3, [r4, #8]
 800078a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800078e:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8000790:	68a3      	ldr	r3, [r4, #8]
 8000792:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000796:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8000798:	6a23      	ldr	r3, [r4, #32]
 800079a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800079e:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 80007a0:	6a23      	ldr	r3, [r4, #32]
 80007a2:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 80007a6:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80007a8:	69eb      	ldr	r3, [r5, #28]
 80007aa:	f043 0301 	orr.w	r3, r3, #1
 80007ae:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80007b0:	6823      	ldr	r3, [r4, #0]
 80007b2:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80007b6:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80007b8:	6823      	ldr	r3, [r4, #0]
 80007ba:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80007be:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80007c0:	88a3      	ldrh	r3, [r4, #4]
 80007c2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80007c6:	041b      	lsls	r3, r3, #16
 80007c8:	0c1b      	lsrs	r3, r3, #16
 80007ca:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80007cc:	88a3      	ldrh	r3, [r4, #4]
 80007ce:	b29b      	uxth	r3, r3
 80007d0:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80007d2:	68e3      	ldr	r3, [r4, #12]
 80007d4:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80007d8:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80007da:	68e3      	ldr	r3, [r4, #12]
 80007dc:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80007de:	68a3      	ldr	r3, [r4, #8]
 80007e0:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80007e4:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80007e6:	68a3      	ldr	r3, [r4, #8]
 80007e8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80007ec:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 80007ee:	6a23      	ldr	r3, [r4, #32]
 80007f0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80007f4:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 80007f6:	6a23      	ldr	r3, [r4, #32]
 80007f8:	f043 63a0 	orr.w	r3, r3, #83886080	; 0x5000000
 80007fc:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80007fe:	69eb      	ldr	r3, [r5, #28]
 8000800:	f043 0301 	orr.w	r3, r3, #1
 8000804:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000806:	6823      	ldr	r3, [r4, #0]
 8000808:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800080c:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 800080e:	6823      	ldr	r3, [r4, #0]
 8000810:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000814:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000816:	88a3      	ldrh	r3, [r4, #4]
 8000818:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800081c:	041b      	lsls	r3, r3, #16
 800081e:	0c1b      	lsrs	r3, r3, #16
 8000820:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000822:	88a3      	ldrh	r3, [r4, #4]
 8000824:	b29b      	uxth	r3, r3
 8000826:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000828:	68e3      	ldr	r3, [r4, #12]
 800082a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800082e:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000830:	68e3      	ldr	r3, [r4, #12]
 8000832:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000834:	68a3      	ldr	r3, [r4, #8]
 8000836:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800083a:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800083c:	68a3      	ldr	r3, [r4, #8]
 800083e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000842:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8000844:	6a23      	ldr	r3, [r4, #32]
 8000846:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800084a:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 800084c:	6a23      	ldr	r3, [r4, #32]
 800084e:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
 8000852:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000854:	69eb      	ldr	r3, [r5, #28]
 8000856:	f043 0301 	orr.w	r3, r3, #1
 800085a:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:167
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 800085c:	6823      	ldr	r3, [r4, #0]
 800085e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8000862:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:169
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000864:	68e3      	ldr	r3, [r4, #12]
 8000866:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800086a:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:170
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 800086c:	68e3      	ldr	r3, [r4, #12]
 800086e:	60e3      	str	r3, [r4, #12]
PinClockEnable():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000870:	69eb      	ldr	r3, [r5, #28]
 8000872:	f043 0301 	orr.w	r3, r3, #1
 8000876:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:167
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000878:	6823      	ldr	r3, [r4, #0]
 800087a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800087e:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:169
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000880:	68e3      	ldr	r3, [r4, #12]
 8000882:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8000886:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:170
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 8000888:	68e3      	ldr	r3, [r4, #12]
 800088a:	60e3      	str	r3, [r4, #12]
PinSet():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800088c:	2310      	movs	r3, #16
 800088e:	8323      	strh	r3, [r4, #24]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:409
private:
    SPI_TypeDef *PSpi;
public:
    void Setup(SPI_TypeDef *Spi, BitOrder_t BitOrder,
            CPOL_t CPOL, CPHA_t CPHA, SpiBaudrate_t Baudrate) {
        PSpi = Spi;
 8000890:	4b2b      	ldr	r3, [pc, #172]	; (8000940 <cc1101_t::Init()+0x240>)
 8000892:	6083      	str	r3, [r0, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:411
        // Clocking
        if      (PSpi == SPI1) { rccEnableSPI1(FALSE); }
 8000894:	6a2a      	ldr	r2, [r5, #32]
 8000896:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800089a:	622a      	str	r2, [r5, #32]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:414
        else if (PSpi == SPI2) { rccEnableSPI2(FALSE); }
        // Mode: Master, NSS software controlled and is 1, 8bit, NoCRC, FullDuplex
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
 800089c:	f44f 7241 	mov.w	r2, #772	; 0x304
 80008a0:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:418
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
 80008a2:	881a      	ldrh	r2, [r3, #0]
 80008a4:	b292      	uxth	r2, r2
 80008a6:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:419
        PSpi->CR2 = 0;
 80008a8:	809f      	strh	r7, [r3, #4]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:420
        PSpi->I2SCFGR &= ~((uint16_t)SPI_I2SCFGR_I2SMOD);       // Disable I2S
 80008aa:	8b9a      	ldrh	r2, [r3, #28]
 80008ac:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80008b0:	0412      	lsls	r2, r2, #16
 80008b2:	0c12      	lsrs	r2, r2, #16
 80008b4:	839a      	strh	r2, [r3, #28]
_ZN5Spi_t6EnableEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:422
    }
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
 80008b6:	881a      	ldrh	r2, [r3, #0]
 80008b8:	b292      	uxth	r2, r2
 80008ba:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80008be:	801a      	strh	r2, [r3, #0]
_ZN8cc1101_t6CResetEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:47
 80008c0:	f7ff fdfe 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11FlushRxFIFOEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.h:52
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 80008c4:	4630      	mov	r0, r6
 80008c6:	213a      	movs	r1, #58	; 0x3a
 80008c8:	f7ff fdfa 	bl	80004c0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:30
    ISpi.Enable();

    // ==== Init CC ====
    CReset();
    FlushRxFIFO();
    RfConfig();
 80008cc:	4630      	mov	r0, r6
 80008ce:	f7ff fe5f 	bl	8000590 <cc1101_t::RfConfig()>
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:251
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
        IPinNumber = APinNumber;
 80008d2:	2303      	movs	r3, #3
 80008d4:	7533      	strb	r3, [r6, #20]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:252
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 80008d6:	6a2b      	ldr	r3, [r5, #32]
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:31
    PWaitingThread = nullptr;
 80008d8:	6077      	str	r7, [r6, #4]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:252
 80008da:	f043 0301 	orr.w	r3, r3, #1
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:32
    State = ccIdle;
 80008de:	7637      	strb	r7, [r6, #24]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:250
                break;
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
 80008e0:	6134      	str	r4, [r6, #16]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:252
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 80008e2:	622b      	str	r3, [r5, #32]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:256
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80008e4:	4b17      	ldr	r3, [pc, #92]	; (8000944 <cc1101_t::Init()+0x244>)
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:232
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 80008e6:	2101      	movs	r1, #1
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:256
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80008e8:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:267
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 80008ea:	2009      	movs	r0, #9
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:256
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 80008ec:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 80008f0:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:262
        // GPIOA requires all zeroes => nothing to do in this case
        if     (GPIO == GPIOB) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0001 << Offset;
        else if(GPIO == GPIOC) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0010 << Offset;
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
 80008f2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 80008f6:	f042 0208 	orr.w	r2, r2, #8
 80008fa:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:263
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
 80008fe:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 8000902:	f022 0208 	bic.w	r2, r2, #8
 8000906:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:232
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 800090a:	7d32      	ldrb	r2, [r6, #20]
 800090c:	fa01 f202 	lsl.w	r2, r1, r2
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:239
            case ttRising:
                EXTI->RTSR |=  IrqMsk;  // Rising trigger enabled
                EXTI->FTSR &= ~IrqMsk;  // Falling trigger disabled
                break;
            case ttFalling:
                EXTI->RTSR &= ~IrqMsk;  // Rising trigger disabled
 8000910:	f8d3 1408 	ldr.w	r1, [r3, #1032]	; 0x408
 8000914:	ea21 0102 	bic.w	r1, r1, r2
 8000918:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:240
                EXTI->FTSR |=  IrqMsk;  // Falling trigger enabled
 800091c:	f8d3 140c 	ldr.w	r1, [r3, #1036]	; 0x40c
 8000920:	430a      	orrs	r2, r1
 8000922:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:265
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
 8000926:	2208      	movs	r2, #8
 8000928:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
_ZN8PinIrq_t9EnableIRQEm():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:271
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIRQ(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 800092c:	2190      	movs	r1, #144	; 0x90
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:267
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 800092e:	60f0      	str	r0, [r6, #12]
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:37

    // ==== IRQ ====
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIRQ(IRQ_PRIO_MEDIUM);
}
 8000930:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
_ZN8PinIrq_t9EnableIRQEm():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:271
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIRQ(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 8000934:	f000 b84c 	b.w	80009d0 <nvicEnableVector>
 8000938:	40023800 	.word	0x40023800
 800093c:	40020000 	.word	0x40020000
 8000940:	40013000 	.word	0x40013000
 8000944:	40010000 	.word	0x40010000
	...

08000950 <cc1101_t::IHandleAsync()>:
_ZN8cc1101_t12IHandleAsyncEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:234
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcTx);  // FIXME
    }
    else if(State == ccReceiving) {
 8000950:	7e03      	ldrb	r3, [r0, #24]
 8000952:	3b02      	subs	r3, #2
 8000954:	b2db      	uxtb	r3, r3
 8000956:	2b01      	cmp	r3, #1
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:231
}

// ============================= Interrupts ====================================
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
 8000958:	bf9c      	itt	ls
 800095a:	2300      	movls	r3, #0
 800095c:	7603      	strbls	r3, [r0, #24]
 800095e:	4770      	bx	lr

08000960 <cc1101_t::IGdo0IrqHandler()>:
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:240
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcRx);  // FIXME
    }
}

void cc1101_t::IGdo0IrqHandler() {
 8000960:	b510      	push	{r4, lr}
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:273
    void DisableIrq() { nvicDisableVector(IIrqChnl); }
    void CleanIrqFlag() { EXTI->PR = (1 << IPinNumber); }
 8000962:	7d03      	ldrb	r3, [r0, #20]
 8000964:	2201      	movs	r2, #1
 8000966:	409a      	lsls	r2, r3
 8000968:	4b0f      	ldr	r3, [pc, #60]	; (80009a8 <cc1101_t::IGdo0IrqHandler()+0x48>)
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:240
 800096a:	4604      	mov	r4, r0
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\ccproject\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:273
 800096c:	615a      	str	r2, [r3, #20]
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:243
    IGdo0.CleanIrqFlag();
    // Resume thread if any
    chSysLockFromIsr()
 800096e:	2320      	movs	r3, #32
 8000970:	f383 8811 	msr	BASEPRI, r3
 8000974:	f000 f9cc 	bl	8000d10 <dbg_check_lock_from_isr>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:245
    ;
    if(PWaitingThread != NULL) {
 8000978:	6863      	ldr	r3, [r4, #4]
 800097a:	b15b      	cbz	r3, 8000994 <cc1101_t::IGdo0IrqHandler()+0x34>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:246
        if(PWaitingThread->p_state == THD_STATE_SUSPENDED) {
 800097c:	f893 2020 	ldrb.w	r2, [r3, #32]
 8000980:	2a02      	cmp	r2, #2
 8000982:	d104      	bne.n	800098e <cc1101_t::IGdo0IrqHandler()+0x2e>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:247
            PWaitingThread->p_u.rdymsg = RDY_OK;    // Signal that IRQ fired
 8000984:	2200      	movs	r2, #0
 8000986:	629a      	str	r2, [r3, #40]	; 0x28
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:248
            chSchReadyI(PWaitingThread);
 8000988:	6860      	ldr	r0, [r4, #4]
 800098a:	f000 fae9 	bl	8000f60 <chSchReadyI>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:250 (discriminator 1)
        }
        PWaitingThread = NULL;
 800098e:	2300      	movs	r3, #0
 8000990:	6063      	str	r3, [r4, #4]
 8000992:	e002      	b.n	800099a <cc1101_t::IGdo0IrqHandler()+0x3a>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:252
    }
    else IHandleAsync(); // Async task completed
 8000994:	4620      	mov	r0, r4
 8000996:	f7ff ffdb 	bl	8000950 <cc1101_t::IHandleAsync()>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:253
    chSysUnlockFromIsr()
 800099a:	f000 f9d1 	bl	8000d40 <dbg_check_unlock_from_isr>
 800099e:	2300      	movs	r3, #0
 80009a0:	f383 8811 	msr	BASEPRI, r3
 80009a4:	bd10      	pop	{r4, pc}
 80009a6:	bf00      	nop
 80009a8:	40010400 	.word	0x40010400
$d():
 80009ac:	00000000 	.word	0x00000000

080009b0 <Vector64>:
Vector64():
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:258
    ;
}

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
 80009b0:	b508      	push	{r3, lr}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:259
    CH_IRQ_PROLOGUE();
 80009b2:	f000 f9dd 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:260
    CC.IGdo0IrqHandler();
 80009b6:	4804      	ldr	r0, [pc, #16]	; (80009c8 <Vector64+0x18>)
 80009b8:	f7ff ffd2 	bl	8000960 <cc1101_t::IGdo0IrqHandler()>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:261
    CH_IRQ_EPILOGUE()
 80009bc:	f000 f9f8 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:263
    ;
}
 80009c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/ccproject/Firmware/Radio/cc1101.cpp:261

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
    CH_IRQ_PROLOGUE();
    CC.IGdo0IrqHandler();
    CH_IRQ_EPILOGUE()
 80009c4:	f000 b884 	b.w	8000ad0 <_port_irq_epilogue>
 80009c8:	20000b60 	.word	0x20000b60
$d():
 80009cc:	00000000 	.word	0x00000000

080009d0 <nvicEnableVector>:
nvicEnableVector():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:47
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 80009d0:	f000 0203 	and.w	r2, r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:46
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80009d4:	b530      	push	{r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:47
  unsigned sh = (n & 3) << 3;
 80009d6:	00d2      	lsls	r2, r2, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:49

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80009d8:	24ff      	movs	r4, #255	; 0xff
 80009da:	4094      	lsls	r4, r2
 80009dc:	4091      	lsls	r1, r2
 80009de:	f020 0303 	bic.w	r3, r0, #3
 80009e2:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80009e6:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80009ea:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 80009ee:	2201      	movs	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:49
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80009f0:	ea25 0404 	bic.w	r4, r5, r4
 80009f4:	430c      	orrs	r4, r1
 80009f6:	f8c3 4300 	str.w	r4, [r3, #768]	; 0x300
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 80009fa:	f000 031f 	and.w	r3, r0, #31
 80009fe:	fa02 f303 	lsl.w	r3, r2, r3
 8000a02:	0940      	lsrs	r0, r0, #5
 8000a04:	0080      	lsls	r0, r0, #2
 8000a06:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000a0a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000a0e:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:51
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
 8000a12:	6003      	str	r3, [r0, #0]
 8000a14:	bd30      	pop	{r4, r5, pc}
	...

08000a20 <nvicSetSystemHandlerPriority>:
nvicSetSystemHandlerPriority():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000a20:	f020 0303 	bic.w	r3, r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:75
  unsigned sh = (handler & 3) * 8;
 8000a24:	f000 0003 	and.w	r0, r0, #3
 8000a28:	00c0      	lsls	r0, r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:78

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
                           ~(0xFF << sh)) | (prio << sh);
 8000a2a:	22ff      	movs	r2, #255	; 0xff
 8000a2c:	4082      	lsls	r2, r0
 8000a2e:	4081      	lsls	r1, r0
 8000a30:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000a34:	b510      	push	{r4, lr}
 8000a36:	f503 436d 	add.w	r3, r3, #60672	; 0xed00
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:77
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000a3a:	699c      	ldr	r4, [r3, #24]
 8000a3c:	ea24 0202 	bic.w	r2, r4, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:78
                           ~(0xFF << sh)) | (prio << sh);
 8000a40:	430a      	orrs	r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:77
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000a42:	619a      	str	r2, [r3, #24]
 8000a44:	bd10      	pop	{r4, pc}
	...

08000a50 <_unhandled_exception>:
_unhandled_exception():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/STM32L1xx/vectors.c:169
 * @notapi
 */
#if !defined(__DOXYGEN__)
__attribute__ ((naked))
#endif
void _unhandled_exception(void) {
 8000a50:	e7fe      	b.n	8000a50 <_unhandled_exception>
	...

08000a60 <_port_switch_from_isr>:
_port_switch_from_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:209
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
 8000a60:	f000 f926 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:210
  chSchDoReschedule();
 8000a64:	f000 fb9c 	bl	80011a0 <chSchDoReschedule>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:211
  dbg_check_unlock();
 8000a68:	f000 f93a 	bl	8000ce0 <dbg_check_unlock>

08000a6c <_port_exit_from_isr>:
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:214
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
 8000a6c:	df00      	svc	0
	...

08000a70 <SVCallVector>:
SVCallVector():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:69
 */
void SVCallVector(void) {
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000a70:	f3ef 8309 	mrs	r3, PSP
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:73

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000a74:	3320      	adds	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:80
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000a76:	f383 8809 	msr	PSP, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:81
  port_unlock_from_isr();
 8000a7a:	2300      	movs	r3, #0
 8000a7c:	f383 8811 	msr	BASEPRI, r3
 8000a80:	4770      	bx	lr
	...

08000a90 <_port_init>:
_port_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:118
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
 8000a90:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:121

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
 8000a92:	4b0a      	ldr	r3, [pc, #40]	; (8000abc <_port_init+0x2c>)
 8000a94:	2200      	movs	r2, #0
 8000a96:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:122
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 8000a98:	4a09      	ldr	r2, [pc, #36]	; (8000ac0 <_port_init+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 8000a9a:	2007      	movs	r0, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:122
 */
void _port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 8000a9c:	60da      	str	r2, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 8000a9e:	2110      	movs	r1, #16
 8000aa0:	f7ff ffbe 	bl	8000a20 <nvicSetSystemHandlerPriority>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:127
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
 8000aa4:	200a      	movs	r0, #10
 8000aa6:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000aaa:	f7ff ffb9 	bl	8000a20 <nvicSetSystemHandlerPriority>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:131
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
}
 8000aae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:129
  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
 8000ab2:	200b      	movs	r0, #11
 8000ab4:	2180      	movs	r1, #128	; 0x80
 8000ab6:	f7ff bfb3 	b.w	8000a20 <nvicSetSystemHandlerPriority>
 8000aba:	bf00      	nop
 8000abc:	e000ed00 	.word	0xe000ed00
 8000ac0:	05fa0300 	.word	0x05fa0300
	...

08000ad0 <_port_irq_epilogue>:
_port_irq_epilogue():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:150
/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
 8000ad0:	2320      	movs	r3, #32
 8000ad2:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:151
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
 8000ad6:	4b15      	ldr	r3, [pc, #84]	; (8000b2c <_port_irq_epilogue+0x5c>)
 8000ad8:	685b      	ldr	r3, [r3, #4]
 8000ada:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000ade:	d021      	beq.n	8000b24 <_port_irq_epilogue+0x54>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:155
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000ae0:	f3ef 8309 	mrs	r3, PSP
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:159

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000ae4:	f1a3 0220 	sub.w	r2, r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:160
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000ae8:	f382 8809 	msr	PSP, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:161
    ctxp->xpsr = (regarm_t)0x01000000;
 8000aec:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000af0:	f843 2c04 	str.w	r2, [r3, #-4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000af4:	4a0e      	ldr	r2, [pc, #56]	; (8000b30 <_port_irq_epilogue+0x60>)
 8000af6:	6991      	ldr	r1, [r2, #24]
 8000af8:	6812      	ldr	r2, [r2, #0]
 8000afa:	f891 0022 	ldrb.w	r0, [r1, #34]	; 0x22
 8000afe:	6892      	ldr	r2, [r2, #8]
 8000b00:	6889      	ldr	r1, [r1, #8]
 8000b02:	b120      	cbz	r0, 8000b0e <_port_irq_epilogue+0x3e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165 (discriminator 1)
 8000b04:	428a      	cmp	r2, r1
 8000b06:	bf94      	ite	ls
 8000b08:	2200      	movls	r2, #0
 8000b0a:	2201      	movhi	r2, #1
 8000b0c:	e003      	b.n	8000b16 <_port_irq_epilogue+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165 (discriminator 2)
 8000b0e:	428a      	cmp	r2, r1
 8000b10:	bf34      	ite	cc
 8000b12:	2200      	movcc	r2, #0
 8000b14:	2201      	movcs	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165 (discriminator 3)
 8000b16:	b10a      	cbz	r2, 8000b1c <_port_irq_epilogue+0x4c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:167
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
 8000b18:	4a06      	ldr	r2, [pc, #24]	; (8000b34 <_port_irq_epilogue+0x64>)
 8000b1a:	e000      	b.n	8000b1e <_port_irq_epilogue+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:176
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
 8000b1c:	4a06      	ldr	r2, [pc, #24]	; (8000b38 <_port_irq_epilogue+0x68>)
 8000b1e:	f843 2c08 	str.w	r2, [r3, #-8]
 8000b22:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:197

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8000b24:	f383 8811 	msr	BASEPRI, r3
 8000b28:	4770      	bx	lr
 8000b2a:	bf00      	nop
 8000b2c:	e000ed00 	.word	0xe000ed00
 8000b30:	2000126c 	.word	0x2000126c
 8000b34:	08000a61 	.word	0x08000a61
 8000b38:	08000a6c 	.word	0x08000a6c
$d():
 8000b3c:	00000000 	.word	0x00000000

08000b40 <SysTickVector>:
SysTickVector():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:47
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
 8000b40:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:49

  CH_IRQ_PROLOGUE();
 8000b42:	f000 f915 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:51

  chSysLockFromIsr();
 8000b46:	2320      	movs	r3, #32
 8000b48:	f383 8811 	msr	BASEPRI, r3
 8000b4c:	f000 f8e0 	bl	8000d10 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:52
  chSysTimerHandlerI();
 8000b50:	f000 fbf6 	bl	8001340 <chSysTimerHandlerI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:53
  chSysUnlockFromIsr();
 8000b54:	f000 f8f4 	bl	8000d40 <dbg_check_unlock_from_isr>
 8000b58:	2300      	movs	r3, #0
 8000b5a:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:55

  CH_IRQ_EPILOGUE();
 8000b5e:	f000 f927 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:56
}
 8000b62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:55

  chSysLockFromIsr();
  chSysTimerHandlerI();
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
 8000b66:	f7ff bfb3 	b.w	8000ad0 <_port_irq_epilogue>
 8000b6a:	0000      	movs	r0, r0
 8000b6c:	0000      	movs	r0, r0
	...

08000b70 <_port_switch>:
_port_switch():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:238
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
 8000b70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:244
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
 8000b74:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000b78:	f8d0 d00c 	ldr.w	sp, [r0, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:250
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
 8000b7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000b80 <_port_thread_start>:
_port_thread_start():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:259
/**
 * @brief   Start a thread by invoking its work function.
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {
 8000b80:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:261

  chSysUnlock();
 8000b82:	f000 f8ad 	bl	8000ce0 <dbg_check_unlock>
 8000b86:	2300      	movs	r3, #0
 8000b88:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:262
  asm volatile ("mov     r0, r5                                 \n\t"
 8000b8c:	4628      	mov	r0, r5
 8000b8e:	47a0      	blx	r4
 8000b90:	f000 fcc6 	bl	8001520 <chThdExit>
 8000b94:	bd08      	pop	{r3, pc}
	...

08000ba0 <__early_init>:
__early_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:234
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __early_init(void) {}
 8000ba0:	4770      	bx	lr
	...

08000bb0 <__late_init>:
__late_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:246
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 8000bb0:	4770      	bx	lr
	...

08000bc0 <_default_exit>:
_default_exit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:257
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak, naked))
#endif
void _default_exit(void) {
 8000bc0:	e7fe      	b.n	8000bc0 <_default_exit>
	...

08000bd0 <ResetHandler>:
ResetHandler():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:274
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000bd0:	b672      	cpsid	i
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:276
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000bd2:	4b22      	ldr	r3, [pc, #136]	; (8000c5c <ResetHandler+0x8c>)
 8000bd4:	f383 8809 	msr	PSP, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:296
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000bd8:	2302      	movs	r3, #2
 8000bda:	f383 8814 	msr	CONTROL, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:297
  asm volatile ("isb");
 8000bde:	f3bf 8f6f 	isb	sy
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000be2:	4b1f      	ldr	r3, [pc, #124]	; (8000c60 <ResetHandler+0x90>)
 8000be4:	4a1d      	ldr	r2, [pc, #116]	; (8000c5c <ResetHandler+0x8c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301 (discriminator 1)
 8000be6:	491f      	ldr	r1, [pc, #124]	; (8000c64 <ResetHandler+0x94>)
 8000be8:	428b      	cmp	r3, r1
 8000bea:	d204      	bcs.n	8000bf6 <ResetHandler+0x26>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301 (discriminator 2)
 8000bec:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000bf0:	f843 1b04 	str.w	r1, [r3], #4
 8000bf4:	e7f7      	b.n	8000be6 <ResetHandler+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301
 8000bf6:	4b1c      	ldr	r3, [pc, #112]	; (8000c68 <ResetHandler+0x98>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:304 (discriminator 1)
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000bf8:	4293      	cmp	r3, r2
 8000bfa:	d204      	bcs.n	8000c06 <ResetHandler+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:304 (discriminator 2)
 8000bfc:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000c00:	f843 1b04 	str.w	r1, [r3], #4
 8000c04:	e7f8      	b.n	8000bf8 <ResetHandler+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:310
         &__process_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
#endif

  /* Early initialization hook invocation.*/
  __early_init();
 8000c06:	f7ff ffcb 	bl	8000ba0 <__early_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000c0a:	2300      	movs	r3, #0
 8000c0c:	4a17      	ldr	r2, [pc, #92]	; (8000c6c <ResetHandler+0x9c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:319 (discriminator 1)
 8000c0e:	4918      	ldr	r1, [pc, #96]	; (8000c70 <ResetHandler+0xa0>)
 8000c10:	1898      	adds	r0, r3, r2
 8000c12:	4288      	cmp	r0, r1
 8000c14:	d204      	bcs.n	8000c20 <ResetHandler+0x50>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:320
      *dp++ = *tp++;
 8000c16:	4917      	ldr	r1, [pc, #92]	; (8000c74 <ResetHandler+0xa4>)
 8000c18:	5859      	ldr	r1, [r3, r1]
 8000c1a:	5099      	str	r1, [r3, r2]
 8000c1c:	3304      	adds	r3, #4
 8000c1e:	e7f5      	b.n	8000c0c <ResetHandler+0x3c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000c20:	4b15      	ldr	r3, [pc, #84]	; (8000c78 <ResetHandler+0xa8>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:326 (discriminator 1)
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000c22:	4a16      	ldr	r2, [pc, #88]	; (8000c7c <ResetHandler+0xac>)
 8000c24:	4293      	cmp	r3, r2
 8000c26:	d203      	bcs.n	8000c30 <ResetHandler+0x60>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:326 (discriminator 2)
 8000c28:	2200      	movs	r2, #0
 8000c2a:	f843 2b04 	str.w	r2, [r3], #4
 8000c2e:	e7f8      	b.n	8000c22 <ResetHandler+0x52>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:330
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 8000c30:	f7ff ffbe 	bl	8000bb0 <__late_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:335

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
 8000c34:	4c12      	ldr	r4, [pc, #72]	; (8000c80 <ResetHandler+0xb0>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:336 (discriminator 1)
    while (fpp < &__init_array_end) {
 8000c36:	4b13      	ldr	r3, [pc, #76]	; (8000c84 <ResetHandler+0xb4>)
 8000c38:	429c      	cmp	r4, r3
 8000c3a:	d203      	bcs.n	8000c44 <ResetHandler+0x74>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:337
      (*fpp)();
 8000c3c:	f854 3b04 	ldr.w	r3, [r4], #4
 8000c40:	4798      	blx	r3
 8000c42:	e7f8      	b.n	8000c36 <ResetHandler+0x66>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:344
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000c44:	f7ff fa5c 	bl	8000100 <main>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:349

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
 8000c48:	4c0f      	ldr	r4, [pc, #60]	; (8000c88 <ResetHandler+0xb8>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:350 (discriminator 1)
    while (fpp < &__fini_array_end) {
 8000c4a:	4b10      	ldr	r3, [pc, #64]	; (8000c8c <ResetHandler+0xbc>)
 8000c4c:	429c      	cmp	r4, r3
 8000c4e:	d203      	bcs.n	8000c58 <ResetHandler+0x88>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:351
      (*fpp)();
 8000c50:	f854 3b04 	ldr.w	r3, [r4], #4
 8000c54:	4798      	blx	r3
 8000c56:	e7f8      	b.n	8000c4a <ResetHandler+0x7a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:358
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000c58:	f7ff ffb2 	bl	8000bc0 <_default_exit>
 8000c5c:	20000800 	.word	0x20000800
 8000c60:	20000000 	.word	0x20000000
 8000c64:	20000400 	.word	0x20000400
 8000c68:	20000400 	.word	0x20000400
 8000c6c:	20000800 	.word	0x20000800
 8000c70:	20000800 	.word	0x20000800
 8000c74:	08002b18 	.word	0x08002b18
 8000c78:	20000800 	.word	0x20000800
 8000c7c:	20001340 	.word	0x20001340
 8000c80:	080000f4 	.word	0x080000f4
 8000c84:	080000f4 	.word	0x080000f4
 8000c88:	080000f4 	.word	0x080000f4
 8000c8c:	080000f4 	.word	0x080000f4

08000c90 <dbg_check_enable>:
dbg_check_enable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:105
 *
 * @notapi
 */
void dbg_check_enable(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt != 0))
 8000c90:	4b04      	ldr	r3, [pc, #16]	; (8000ca4 <dbg_check_enable+0x14>)
 8000c92:	681b      	ldr	r3, [r3, #0]
 8000c94:	b913      	cbnz	r3, 8000c9c <dbg_check_enable+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:105 (discriminator 1)
 8000c96:	4b04      	ldr	r3, [pc, #16]	; (8000ca8 <dbg_check_enable+0x18>)
 8000c98:	681b      	ldr	r3, [r3, #0]
 8000c9a:	b113      	cbz	r3, 8000ca2 <dbg_check_enable+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:106
    chDbgPanic("SV#3");
 8000c9c:	4803      	ldr	r0, [pc, #12]	; (8000cac <dbg_check_enable+0x1c>)
 8000c9e:	f001 b867 	b.w	8001d70 <chDbgPanic>
 8000ca2:	4770      	bx	lr
 8000ca4:	20001264 	.word	0x20001264
 8000ca8:	20001268 	.word	0x20001268
 8000cac:	0800276a 	.word	0x0800276a

08000cb0 <dbg_check_lock>:
dbg_check_lock():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:116
 *
 * @notapi
 */
void dbg_check_lock(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt != 0))
 8000cb0:	4b06      	ldr	r3, [pc, #24]	; (8000ccc <dbg_check_lock+0x1c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:114
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void dbg_check_lock(void) {
 8000cb2:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:116

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt != 0))
 8000cb4:	681b      	ldr	r3, [r3, #0]
 8000cb6:	4c06      	ldr	r4, [pc, #24]	; (8000cd0 <dbg_check_lock+0x20>)
 8000cb8:	b90b      	cbnz	r3, 8000cbe <dbg_check_lock+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:116 (discriminator 1)
 8000cba:	6823      	ldr	r3, [r4, #0]
 8000cbc:	b113      	cbz	r3, 8000cc4 <dbg_check_lock+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:117
    chDbgPanic("SV#4");
 8000cbe:	4805      	ldr	r0, [pc, #20]	; (8000cd4 <dbg_check_lock+0x24>)
 8000cc0:	f001 f856 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:118
  dbg_enter_lock();
 8000cc4:	2301      	movs	r3, #1
 8000cc6:	6023      	str	r3, [r4, #0]
 8000cc8:	bd10      	pop	{r4, pc}
 8000cca:	bf00      	nop
 8000ccc:	20001264 	.word	0x20001264
 8000cd0:	20001268 	.word	0x20001268
 8000cd4:	0800276f 	.word	0x0800276f
	...

08000ce0 <dbg_check_unlock>:
dbg_check_unlock():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:128
 *
 * @notapi
 */
void dbg_check_unlock(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt <= 0))
 8000ce0:	4b06      	ldr	r3, [pc, #24]	; (8000cfc <dbg_check_unlock+0x1c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:126
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void dbg_check_unlock(void) {
 8000ce2:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:128

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt <= 0))
 8000ce4:	681b      	ldr	r3, [r3, #0]
 8000ce6:	4c06      	ldr	r4, [pc, #24]	; (8000d00 <dbg_check_unlock+0x20>)
 8000ce8:	b913      	cbnz	r3, 8000cf0 <dbg_check_unlock+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:128 (discriminator 1)
 8000cea:	6823      	ldr	r3, [r4, #0]
 8000cec:	2b00      	cmp	r3, #0
 8000cee:	dc02      	bgt.n	8000cf6 <dbg_check_unlock+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:129
    chDbgPanic("SV#5");
 8000cf0:	4804      	ldr	r0, [pc, #16]	; (8000d04 <dbg_check_unlock+0x24>)
 8000cf2:	f001 f83d 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:130
  dbg_leave_lock();
 8000cf6:	2300      	movs	r3, #0
 8000cf8:	6023      	str	r3, [r4, #0]
 8000cfa:	bd10      	pop	{r4, pc}
 8000cfc:	20001264 	.word	0x20001264
 8000d00:	20001268 	.word	0x20001268
 8000d04:	08002774 	.word	0x08002774
	...

08000d10 <dbg_check_lock_from_isr>:
dbg_check_lock_from_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:140
 *
 * @notapi
 */
void dbg_check_lock_from_isr(void) {

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt != 0))
 8000d10:	4b06      	ldr	r3, [pc, #24]	; (8000d2c <dbg_check_lock_from_isr+0x1c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:138
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void dbg_check_lock_from_isr(void) {
 8000d12:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:140

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt != 0))
 8000d14:	681b      	ldr	r3, [r3, #0]
 8000d16:	4c06      	ldr	r4, [pc, #24]	; (8000d30 <dbg_check_lock_from_isr+0x20>)
 8000d18:	2b00      	cmp	r3, #0
 8000d1a:	dd01      	ble.n	8000d20 <dbg_check_lock_from_isr+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:140 (discriminator 1)
 8000d1c:	6823      	ldr	r3, [r4, #0]
 8000d1e:	b113      	cbz	r3, 8000d26 <dbg_check_lock_from_isr+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:141
    chDbgPanic("SV#6");
 8000d20:	4804      	ldr	r0, [pc, #16]	; (8000d34 <dbg_check_lock_from_isr+0x24>)
 8000d22:	f001 f825 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:142
  dbg_enter_lock();
 8000d26:	2301      	movs	r3, #1
 8000d28:	6023      	str	r3, [r4, #0]
 8000d2a:	bd10      	pop	{r4, pc}
 8000d2c:	20001264 	.word	0x20001264
 8000d30:	20001268 	.word	0x20001268
 8000d34:	08002779 	.word	0x08002779
	...

08000d40 <dbg_check_unlock_from_isr>:
dbg_check_unlock_from_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:152
 *
 * @notapi
 */
void dbg_check_unlock_from_isr(void) {

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt <= 0))
 8000d40:	4b07      	ldr	r3, [pc, #28]	; (8000d60 <dbg_check_unlock_from_isr+0x20>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:150
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void dbg_check_unlock_from_isr(void) {
 8000d42:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:152

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt <= 0))
 8000d44:	681b      	ldr	r3, [r3, #0]
 8000d46:	4c07      	ldr	r4, [pc, #28]	; (8000d64 <dbg_check_unlock_from_isr+0x24>)
 8000d48:	2b00      	cmp	r3, #0
 8000d4a:	dd02      	ble.n	8000d52 <dbg_check_unlock_from_isr+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:152 (discriminator 1)
 8000d4c:	6823      	ldr	r3, [r4, #0]
 8000d4e:	2b00      	cmp	r3, #0
 8000d50:	dc02      	bgt.n	8000d58 <dbg_check_unlock_from_isr+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:153
    chDbgPanic("SV#7");
 8000d52:	4805      	ldr	r0, [pc, #20]	; (8000d68 <dbg_check_unlock_from_isr+0x28>)
 8000d54:	f001 f80c 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:154
  dbg_leave_lock();
 8000d58:	2300      	movs	r3, #0
 8000d5a:	6023      	str	r3, [r4, #0]
 8000d5c:	bd10      	pop	{r4, pc}
 8000d5e:	bf00      	nop
 8000d60:	20001264 	.word	0x20001264
 8000d64:	20001268 	.word	0x20001268
 8000d68:	0800277e 	.word	0x0800277e
$d():
 8000d6c:	00000000 	.word	0x00000000

08000d70 <dbg_check_enter_isr>:
dbg_check_enter_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:162
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void dbg_check_enter_isr(void) {
 8000d70:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:164

  port_lock_from_isr();
 8000d72:	2320      	movs	r3, #32
 8000d74:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:165
  if ((dbg_isr_cnt < 0) || (dbg_lock_cnt != 0))
 8000d78:	4c08      	ldr	r4, [pc, #32]	; (8000d9c <dbg_check_enter_isr+0x2c>)
 8000d7a:	6823      	ldr	r3, [r4, #0]
 8000d7c:	2b00      	cmp	r3, #0
 8000d7e:	db02      	blt.n	8000d86 <dbg_check_enter_isr+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:165 (discriminator 1)
 8000d80:	4b07      	ldr	r3, [pc, #28]	; (8000da0 <dbg_check_enter_isr+0x30>)
 8000d82:	681b      	ldr	r3, [r3, #0]
 8000d84:	b113      	cbz	r3, 8000d8c <dbg_check_enter_isr+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:166
    chDbgPanic("SV#8");
 8000d86:	4807      	ldr	r0, [pc, #28]	; (8000da4 <dbg_check_enter_isr+0x34>)
 8000d88:	f000 fff2 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:167
  dbg_isr_cnt++;
 8000d8c:	6823      	ldr	r3, [r4, #0]
 8000d8e:	3301      	adds	r3, #1
 8000d90:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:168
  port_unlock_from_isr();
 8000d92:	2300      	movs	r3, #0
 8000d94:	f383 8811 	msr	BASEPRI, r3
 8000d98:	bd10      	pop	{r4, pc}
 8000d9a:	bf00      	nop
 8000d9c:	20001264 	.word	0x20001264
 8000da0:	20001268 	.word	0x20001268
 8000da4:	08002783 	.word	0x08002783
	...

08000db0 <dbg_check_leave_isr>:
dbg_check_leave_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:176
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void dbg_check_leave_isr(void) {
 8000db0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:178

  port_lock_from_isr();
 8000db2:	2320      	movs	r3, #32
 8000db4:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:179
  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt != 0))
 8000db8:	4c08      	ldr	r4, [pc, #32]	; (8000ddc <dbg_check_leave_isr+0x2c>)
 8000dba:	6823      	ldr	r3, [r4, #0]
 8000dbc:	2b00      	cmp	r3, #0
 8000dbe:	dd02      	ble.n	8000dc6 <dbg_check_leave_isr+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:179 (discriminator 1)
 8000dc0:	4b07      	ldr	r3, [pc, #28]	; (8000de0 <dbg_check_leave_isr+0x30>)
 8000dc2:	681b      	ldr	r3, [r3, #0]
 8000dc4:	b113      	cbz	r3, 8000dcc <dbg_check_leave_isr+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:180
    chDbgPanic("SV#9");
 8000dc6:	4807      	ldr	r0, [pc, #28]	; (8000de4 <dbg_check_leave_isr+0x34>)
 8000dc8:	f000 ffd2 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:181
  dbg_isr_cnt--;
 8000dcc:	6823      	ldr	r3, [r4, #0]
 8000dce:	3b01      	subs	r3, #1
 8000dd0:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:182
  port_unlock_from_isr();
 8000dd2:	2300      	movs	r3, #0
 8000dd4:	f383 8811 	msr	BASEPRI, r3
 8000dd8:	bd10      	pop	{r4, pc}
 8000dda:	bf00      	nop
 8000ddc:	20001264 	.word	0x20001264
 8000de0:	20001268 	.word	0x20001268
 8000de4:	08002788 	.word	0x08002788
	...

08000df0 <chDbgCheckClassI>:
chDbgCheckClassI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:195
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((dbg_isr_cnt < 0) || (dbg_lock_cnt <= 0))
 8000df0:	4b05      	ldr	r3, [pc, #20]	; (8000e08 <chDbgCheckClassI+0x18>)
 8000df2:	681b      	ldr	r3, [r3, #0]
 8000df4:	2b00      	cmp	r3, #0
 8000df6:	db03      	blt.n	8000e00 <chDbgCheckClassI+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:195 (discriminator 1)
 8000df8:	4b04      	ldr	r3, [pc, #16]	; (8000e0c <chDbgCheckClassI+0x1c>)
 8000dfa:	681b      	ldr	r3, [r3, #0]
 8000dfc:	2b00      	cmp	r3, #0
 8000dfe:	dc02      	bgt.n	8000e06 <chDbgCheckClassI+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:196
    chDbgPanic("SV#10");
 8000e00:	4803      	ldr	r0, [pc, #12]	; (8000e10 <chDbgCheckClassI+0x20>)
 8000e02:	f000 bfb5 	b.w	8001d70 <chDbgPanic>
 8000e06:	4770      	bx	lr
 8000e08:	20001264 	.word	0x20001264
 8000e0c:	20001268 	.word	0x20001268
 8000e10:	0800278d 	.word	0x0800278d
	...

08000e20 <chDbgCheckClassS>:
chDbgCheckClassS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:209
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt <= 0))
 8000e20:	4b05      	ldr	r3, [pc, #20]	; (8000e38 <chDbgCheckClassS+0x18>)
 8000e22:	681b      	ldr	r3, [r3, #0]
 8000e24:	b91b      	cbnz	r3, 8000e2e <chDbgCheckClassS+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:209 (discriminator 1)
 8000e26:	4b05      	ldr	r3, [pc, #20]	; (8000e3c <chDbgCheckClassS+0x1c>)
 8000e28:	681b      	ldr	r3, [r3, #0]
 8000e2a:	2b00      	cmp	r3, #0
 8000e2c:	dc02      	bgt.n	8000e34 <chDbgCheckClassS+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:210
    chDbgPanic("SV#11");
 8000e2e:	4804      	ldr	r0, [pc, #16]	; (8000e40 <chDbgCheckClassS+0x20>)
 8000e30:	f000 bf9e 	b.w	8001d70 <chDbgPanic>
 8000e34:	4770      	bx	lr
 8000e36:	bf00      	nop
 8000e38:	20001264 	.word	0x20001264
 8000e3c:	20001268 	.word	0x20001268
 8000e40:	08002793 	.word	0x08002793
	...

08000e50 <_trace_init>:
_trace_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:231
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {

  dbg_trace_buffer.tb_size = CH_TRACE_BUFFER_SIZE;
 8000e50:	4a03      	ldr	r2, [pc, #12]	; (8000e60 <_trace_init+0x10>)
 8000e52:	2140      	movs	r1, #64	; 0x40
 8000e54:	4613      	mov	r3, r2
 8000e56:	f843 1b08 	str.w	r1, [r3], #8
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:232
  dbg_trace_buffer.tb_ptr = &dbg_trace_buffer.tb_buffer[0];
 8000e5a:	6053      	str	r3, [r2, #4]
 8000e5c:	4770      	bx	lr
 8000e5e:	bf00      	nop
 8000e60:	20000e58 	.word	0x20000e58
	...

08000e70 <dbg_trace>:
dbg_trace():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:244
 *
 * @notapi
 */
void dbg_trace(Thread *otp) {

  dbg_trace_buffer.tb_ptr->se_time   = chTimeNow();
 8000e70:	4b0c      	ldr	r3, [pc, #48]	; (8000ea4 <dbg_trace+0x34>)
 8000e72:	490d      	ldr	r1, [pc, #52]	; (8000ea8 <dbg_trace+0x38>)
 8000e74:	685a      	ldr	r2, [r3, #4]
 8000e76:	68c9      	ldr	r1, [r1, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:248
  dbg_trace_buffer.tb_ptr->se_tp     = currp;
  dbg_trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
  dbg_trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
  if (++dbg_trace_buffer.tb_ptr >=
 8000e78:	3210      	adds	r2, #16
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:244
 *
 * @notapi
 */
void dbg_trace(Thread *otp) {

  dbg_trace_buffer.tb_ptr->se_time   = chTimeNow();
 8000e7a:	f842 1c10 	str.w	r1, [r2, #-16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:245
  dbg_trace_buffer.tb_ptr->se_tp     = currp;
 8000e7e:	490b      	ldr	r1, [pc, #44]	; (8000eac <dbg_trace+0x3c>)
 8000e80:	6989      	ldr	r1, [r1, #24]
 8000e82:	f842 1c0c 	str.w	r1, [r2, #-12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:246
  dbg_trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8000e86:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8000e88:	f842 1c08 	str.w	r1, [r2, #-8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:247
  dbg_trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000e8c:	f890 1020 	ldrb.w	r1, [r0, #32]
 8000e90:	f802 1c04 	strb.w	r1, [r2, #-4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:248
  if (++dbg_trace_buffer.tb_ptr >=
 8000e94:	f503 6181 	add.w	r1, r3, #1032	; 0x408
 8000e98:	428a      	cmp	r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:250
      &dbg_trace_buffer.tb_buffer[CH_TRACE_BUFFER_SIZE])
    dbg_trace_buffer.tb_ptr = &dbg_trace_buffer.tb_buffer[0];
 8000e9a:	bf28      	it	cs
 8000e9c:	f103 0208 	addcs.w	r2, r3, #8
 8000ea0:	605a      	str	r2, [r3, #4]
 8000ea2:	4770      	bx	lr
 8000ea4:	20000e58 	.word	0x20000e58
 8000ea8:	20001330 	.word	0x20001330
 8000eac:	2000126c 	.word	0x2000126c

08000eb0 <chEvtSignalI>:
chEvtSignalI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:251
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
 8000eb0:	b538      	push	{r3, r4, r5, lr}
 8000eb2:	4604      	mov	r4, r0
 8000eb4:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:253

  chDbgCheckClassI();
 8000eb6:	f7ff ff9b 	bl	8000df0 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:254
  chDbgCheck(tp != NULL, "chEvtSignalI");
 8000eba:	b914      	cbnz	r4, 8000ec2 <chEvtSignalI+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:254 (discriminator 1)
 8000ebc:	480d      	ldr	r0, [pc, #52]	; (8000ef4 <chEvtSignalI+0x44>)
 8000ebe:	f000 ff57 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:256

  tp->p_epending |= mask;
 8000ec2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000ec4:	ea45 0103 	orr.w	r1, r5, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:258
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8000ec8:	f894 3020 	ldrb.w	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:256
void chEvtSignalI(Thread *tp, eventmask_t mask) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
 8000ecc:	6321      	str	r1, [r4, #48]	; 0x30
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:258
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8000ece:	2b08      	cmp	r3, #8
 8000ed0:	d103      	bne.n	8000eda <chEvtSignalI+0x2a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:259 (discriminator 1)
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000ed2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:258 (discriminator 1)
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8000ed4:	4219      	tst	r1, r3
 8000ed6:	d106      	bne.n	8000ee6 <chEvtSignalI+0x36>
 8000ed8:	bd38      	pop	{r3, r4, r5, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:259
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000eda:	2b09      	cmp	r3, #9
 8000edc:	d108      	bne.n	8000ef0 <chEvtSignalI+0x40>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:261
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
 8000ede:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000ee0:	4019      	ands	r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:260

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
 8000ee2:	4299      	cmp	r1, r3
 8000ee4:	d104      	bne.n	8000ef0 <chEvtSignalI+0x40>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:262
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
 8000ee6:	4620      	mov	r0, r4
 8000ee8:	f000 f83a 	bl	8000f60 <chSchReadyI>
 8000eec:	2300      	movs	r3, #0
 8000eee:	6283      	str	r3, [r0, #40]	; 0x28
 8000ef0:	bd38      	pop	{r3, r4, r5, pc}
 8000ef2:	bf00      	nop
 8000ef4:	080027ca 	.word	0x080027ca
	...

08000f00 <chEvtWaitAny>:
chEvtWaitAny():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:380
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
  Thread *ctp = currp;
 8000f00:	4b0e      	ldr	r3, [pc, #56]	; (8000f3c <chEvtWaitAny+0x3c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:379
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
 8000f02:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:380
  Thread *ctp = currp;
 8000f04:	699c      	ldr	r4, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:379
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
 8000f06:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:383
  Thread *ctp = currp;
  eventmask_t m;

  chSysLock();
 8000f08:	2320      	movs	r3, #32
 8000f0a:	f383 8811 	msr	BASEPRI, r3
 8000f0e:	f7ff fecf 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:385

  if ((m = (ctp->p_epending & mask)) == 0) {
 8000f12:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8000f14:	402e      	ands	r6, r5
 8000f16:	d105      	bne.n	8000f24 <chEvtWaitAny+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:386
    ctp->p_u.ewmask = mask;
 8000f18:	62a5      	str	r5, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:387
    chSchGoSleepS(THD_STATE_WTOREVT);
 8000f1a:	2008      	movs	r0, #8
 8000f1c:	f000 f868 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:388
    m = ctp->p_epending & mask;
 8000f20:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8000f22:	402e      	ands	r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:390
  }
  ctp->p_epending &= ~m;
 8000f24:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000f26:	ea23 0306 	bic.w	r3, r3, r6
 8000f2a:	6323      	str	r3, [r4, #48]	; 0x30
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:392

  chSysUnlock();
 8000f2c:	f7ff fed8 	bl	8000ce0 <dbg_check_unlock>
 8000f30:	2300      	movs	r3, #0
 8000f32:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:394
  return m;
}
 8000f36:	4630      	mov	r0, r6
 8000f38:	bd70      	pop	{r4, r5, r6, pc}
 8000f3a:	bf00      	nop
 8000f3c:	2000126c 	.word	0x2000126c

08000f40 <_scheduler_init>:
_scheduler_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000f40:	4b03      	ldr	r3, [pc, #12]	; (8000f50 <_scheduler_init+0x10>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000f42:	2200      	movs	r2, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000f44:	605b      	str	r3, [r3, #4]
 8000f46:	601b      	str	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000f48:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:60
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 8000f4a:	615b      	str	r3, [r3, #20]
 8000f4c:	611b      	str	r3, [r3, #16]
 8000f4e:	4770      	bx	lr
 8000f50:	2000126c 	.word	0x2000126c
	...

08000f60 <chSchReadyI>:
chSchReadyI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 8000f60:	b510      	push	{r4, lr}
 8000f62:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:84
  Thread *cp;

  chDbgCheckClassI();
 8000f64:	f7ff ff44 	bl	8000df0 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:87

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 8000f68:	f894 3020 	ldrb.w	r3, [r4, #32]
 8000f6c:	b10b      	cbz	r3, 8000f72 <chSchReadyI+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:87 (discriminator 2)
 8000f6e:	2b0e      	cmp	r3, #14
 8000f70:	d102      	bne.n	8000f78 <chSchReadyI+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:87 (discriminator 1)
 8000f72:	4809      	ldr	r0, [pc, #36]	; (8000f98 <chSchReadyI+0x38>)
 8000f74:	f000 fefc 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:92
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 8000f78:	2300      	movs	r3, #0
 8000f7a:	f884 3020 	strb.w	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:96
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 8000f7e:	68a1      	ldr	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:93
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 8000f80:	4b06      	ldr	r3, [pc, #24]	; (8000f9c <chSchReadyI+0x3c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:95 (discriminator 1)
  do {
    cp = cp->p_next;
 8000f82:	681b      	ldr	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:96 (discriminator 1)
  } while (cp->p_prio >= tp->p_prio);
 8000f84:	689a      	ldr	r2, [r3, #8]
 8000f86:	428a      	cmp	r2, r1
 8000f88:	d2fb      	bcs.n	8000f82 <chSchReadyI+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:99
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000f8a:	685a      	ldr	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:98
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000f8c:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:99
  tp->p_prev = cp->p_prev;
 8000f8e:	6062      	str	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:102
  tp->p_prev->p_next = cp->p_prev = tp;
  return tp;
}
 8000f90:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:100
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000f92:	605c      	str	r4, [r3, #4]
 8000f94:	6014      	str	r4, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:102
  return tp;
}
 8000f96:	bd10      	pop	{r4, pc}
 8000f98:	08002850 	.word	0x08002850
 8000f9c:	2000126c 	.word	0x2000126c

08000fa0 <wakeup>:
wakeup():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:136

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000fa0:	b538      	push	{r3, r4, r5, lr}
 8000fa2:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:139
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
 8000fa4:	2320      	movs	r3, #32
 8000fa6:	f383 8811 	msr	BASEPRI, r3
 8000faa:	f7ff feb1 	bl	8000d10 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:140
  switch (tp->p_state) {
 8000fae:	f894 5020 	ldrb.w	r5, [r4, #32]
 8000fb2:	b15d      	cbz	r5, 8000fcc <wakeup+0x2c>
 8000fb4:	2d03      	cmp	r5, #3
 8000fb6:	d10d      	bne.n	8000fd4 <wakeup+0x34>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:150
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 8000fb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000fba:	689a      	ldr	r2, [r3, #8]
 8000fbc:	3201      	adds	r2, #1
 8000fbe:	609a      	str	r2, [r3, #8]
dequeue():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:75
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000fc0:	e894 000c 	ldmia.w	r4, {r2, r3}
 8000fc4:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:76
  tp->p_next->p_prev = tp->p_prev;
 8000fc6:	6822      	ldr	r2, [r4, #0]
 8000fc8:	6053      	str	r3, [r2, #4]
 8000fca:	e003      	b.n	8000fd4 <wakeup+0x34>
wakeup():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:144
  chSysLockFromIsr();
  switch (tp->p_state) {
  case THD_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromIsr();
 8000fcc:	f7ff feb8 	bl	8000d40 <dbg_check_unlock_from_isr>
 8000fd0:	462b      	mov	r3, r5
 8000fd2:	e008      	b.n	8000fe6 <wakeup+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:163
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 8000fd4:	f04f 33ff 	mov.w	r3, #4294967295
 8000fd8:	62a3      	str	r3, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:164
  chSchReadyI(tp);
 8000fda:	4620      	mov	r0, r4
 8000fdc:	f7ff ffc0 	bl	8000f60 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:165
  chSysUnlockFromIsr();
 8000fe0:	f7ff feae 	bl	8000d40 <dbg_check_unlock_from_isr>
 8000fe4:	2300      	movs	r3, #0
 8000fe6:	f383 8811 	msr	BASEPRI, r3
 8000fea:	bd38      	pop	{r3, r4, r5, pc}
 8000fec:	0000      	movs	r0, r0
	...

08000ff0 <chSchGoSleepS>:
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:115
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
 8000ff0:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:120
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000ff2:	4c11      	ldr	r4, [pc, #68]	; (8001038 <chSchGoSleepS+0x48>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:115
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
 8000ff4:	4606      	mov	r6, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:118
  Thread *otp;

  chDbgCheckClassS();
 8000ff6:	f7ff ff13 	bl	8000e20 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:120

  (otp = currp)->p_state = newstate;
 8000ffa:	69a5      	ldr	r5, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 8000ffc:	2314      	movs	r3, #20
 8000ffe:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8001002:	6823      	ldr	r3, [r4, #0]
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8001004:	f885 6020 	strb.w	r6, [r5, #32]
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8001008:	681a      	ldr	r2, [r3, #0]
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800100a:	4628      	mov	r0, r5
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62
 800100c:	6054      	str	r4, [r2, #4]
 800100e:	6022      	str	r2, [r4, #0]
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:127
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8001010:	2201      	movs	r2, #1
 8001012:	f883 2020 	strb.w	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:126
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 8001016:	61a3      	str	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8001018:	f7ff ff2a 	bl	8000e70 <dbg_trace>
 800101c:	69eb      	ldr	r3, [r5, #28]
 800101e:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 8001022:	4293      	cmp	r3, r2
 8001024:	d902      	bls.n	800102c <chSchGoSleepS+0x3c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128 (discriminator 1)
 8001026:	4805      	ldr	r0, [pc, #20]	; (800103c <chSchGoSleepS+0x4c>)
 8001028:	f000 fea2 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128 (discriminator 2)
 800102c:	69a0      	ldr	r0, [r4, #24]
 800102e:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:129 (discriminator 2)
}
 8001030:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128 (discriminator 2)
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8001034:	f7ff bd9c 	b.w	8000b70 <_port_switch>
 8001038:	2000126c 	.word	0x2000126c
 800103c:	08002862 	.word	0x08002862

08001040 <chSchGoSleepTimeoutS>:
chSchGoSleepTimeoutS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001040:	b570      	push	{r4, r5, r6, lr}
 8001042:	460e      	mov	r6, r1
 8001044:	b086      	sub	sp, #24
 8001046:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:191

  chDbgCheckClassS();
 8001048:	f7ff feea 	bl	8000e20 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:193

  if (TIME_INFINITE != time) {
 800104c:	1c73      	adds	r3, r6, #1
 800104e:	4c0c      	ldr	r4, [pc, #48]	; (8001080 <chSchGoSleepTimeoutS+0x40>)
 8001050:	d00e      	beq.n	8001070 <chSchGoSleepTimeoutS+0x30>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:196
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 8001052:	69a3      	ldr	r3, [r4, #24]
 8001054:	a801      	add	r0, sp, #4
 8001056:	4631      	mov	r1, r6
 8001058:	4a0a      	ldr	r2, [pc, #40]	; (8001084 <chSchGoSleepTimeoutS+0x44>)
 800105a:	f000 fa81 	bl	8001560 <chVTSetI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:197
    chSchGoSleepS(newstate);
 800105e:	4628      	mov	r0, r5
 8001060:	f7ff ffc6 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:198
    if (chVTIsArmedI(&vt))
 8001064:	9b04      	ldr	r3, [sp, #16]
 8001066:	b133      	cbz	r3, 8001076 <chSchGoSleepTimeoutS+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:199
      chVTResetI(&vt);
 8001068:	a801      	add	r0, sp, #4
 800106a:	f000 faa1 	bl	80015b0 <chVTResetI>
 800106e:	e002      	b.n	8001076 <chSchGoSleepTimeoutS+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:202
  }
  else
    chSchGoSleepS(newstate);
 8001070:	4628      	mov	r0, r5
 8001072:	f7ff ffbd 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:203
  return currp->p_u.rdymsg;
 8001076:	69a3      	ldr	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:204
}
 8001078:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800107a:	b006      	add	sp, #24
 800107c:	bd70      	pop	{r4, r5, r6, pc}
 800107e:	bf00      	nop
 8001080:	2000126c 	.word	0x2000126c
 8001084:	08000fa1 	.word	0x08000fa1
	...

08001090 <chSchWakeupS>:
chSchWakeupS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 8001090:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8001092:	4e13      	ldr	r6, [pc, #76]	; (80010e0 <chSchWakeupS+0x50>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 8001094:	4604      	mov	r4, r0
 8001096:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:227

  chDbgCheckClassS();
 8001098:	f7ff fec2 	bl	8000e20 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 800109c:	69b0      	ldr	r0, [r6, #24]
 800109e:	68a2      	ldr	r2, [r4, #8]
 80010a0:	6883      	ldr	r3, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:229
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 80010a2:	62a5      	str	r5, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:234
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80010a4:	429a      	cmp	r2, r3
 80010a6:	d804      	bhi.n	80010b2 <chSchWakeupS+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:235
    chSchReadyI(ntp);
 80010a8:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:242
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80010aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:235
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
 80010ae:	f7ff bf57 	b.w	8000f60 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:237
  else {
    Thread *otp = chSchReadyI(currp);
 80010b2:	f7ff ff55 	bl	8000f60 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80010b6:	2301      	movs	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:237
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
 80010b8:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80010ba:	f884 3020 	strb.w	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:238
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80010be:	61b4      	str	r4, [r6, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80010c0:	f7ff fed6 	bl	8000e70 <dbg_trace>
 80010c4:	69eb      	ldr	r3, [r5, #28]
 80010c6:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 80010ca:	4293      	cmp	r3, r2
 80010cc:	d902      	bls.n	80010d4 <chSchWakeupS+0x44>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240 (discriminator 1)
 80010ce:	4805      	ldr	r0, [pc, #20]	; (80010e4 <chSchWakeupS+0x54>)
 80010d0:	f000 fe4e 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240 (discriminator 2)
 80010d4:	4620      	mov	r0, r4
 80010d6:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:242 (discriminator 2)
  }
}
 80010d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240 (discriminator 2)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80010dc:	f7ff bd48 	b.w	8000b70 <_port_switch>
 80010e0:	2000126c 	.word	0x2000126c
 80010e4:	08002862 	.word	0x08002862
	...

080010f0 <chSchDoRescheduleBehind>:
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:304
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
 80010f0:	b538      	push	{r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:307
  Thread *otp;

  otp = currp;
 80010f2:	4c10      	ldr	r4, [pc, #64]	; (8001134 <chSchDoRescheduleBehind+0x44>)
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 80010f4:	6823      	ldr	r3, [r4, #0]
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:307
 80010f6:	69a5      	ldr	r5, [r4, #24]
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80010f8:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:314
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
 80010fa:	4628      	mov	r0, r5
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62
 80010fc:	6054      	str	r4, [r2, #4]
 80010fe:	6022      	str	r2, [r4, #0]
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:310
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8001100:	2201      	movs	r2, #1
 8001102:	f883 2020 	strb.w	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:309
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8001106:	61a3      	str	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:312
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
 8001108:	2314      	movs	r3, #20
 800110a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:314
#endif
  chSchReadyI(otp);
 800110e:	f7ff ff27 	bl	8000f60 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315
  chSysSwitch(currp, otp);
 8001112:	4628      	mov	r0, r5
 8001114:	f7ff feac 	bl	8000e70 <dbg_trace>
 8001118:	69eb      	ldr	r3, [r5, #28]
 800111a:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 800111e:	4293      	cmp	r3, r2
 8001120:	d902      	bls.n	8001128 <chSchDoRescheduleBehind+0x38>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315 (discriminator 1)
 8001122:	4805      	ldr	r0, [pc, #20]	; (8001138 <chSchDoRescheduleBehind+0x48>)
 8001124:	f000 fe24 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315 (discriminator 2)
 8001128:	69a0      	ldr	r0, [r4, #24]
 800112a:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:316 (discriminator 2)
}
 800112c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315 (discriminator 2)
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8001130:	f7ff bd1e 	b.w	8000b70 <_port_switch>
 8001134:	2000126c 	.word	0x2000126c
 8001138:	08002862 	.word	0x08002862
$d():
 800113c:	00000000 	.word	0x00000000

08001140 <chSchDoRescheduleAhead>:
chSchDoRescheduleAhead():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:329
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
 8001140:	b538      	push	{r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:332
  Thread *otp, *cp;

  otp = currp;
 8001142:	4b14      	ldr	r3, [pc, #80]	; (8001194 <chSchDoRescheduleAhead+0x54>)
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8001144:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleAhead():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:332
 8001146:	699c      	ldr	r4, [r3, #24]
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8001148:	6811      	ldr	r1, [r2, #0]
 800114a:	461d      	mov	r5, r3
 800114c:	604b      	str	r3, [r1, #4]
 800114e:	6019      	str	r1, [r3, #0]
chSchDoRescheduleAhead():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:335
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8001150:	2101      	movs	r1, #1
 8001152:	f882 1020 	strb.w	r1, [r2, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:334
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8001156:	619a      	str	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:341

  otp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8001158:	68a1      	ldr	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:337
  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;

  otp->p_state = THD_STATE_READY;
 800115a:	2200      	movs	r2, #0
 800115c:	f884 2020 	strb.w	r2, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:340 (discriminator 1)
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
 8001160:	681b      	ldr	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:341 (discriminator 1)
  } while (cp->p_prio > otp->p_prio);
 8001162:	689a      	ldr	r2, [r3, #8]
 8001164:	428a      	cmp	r2, r1
 8001166:	d8fb      	bhi.n	8001160 <chSchDoRescheduleAhead+0x20>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:344
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001168:	685a      	ldr	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:343
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800116a:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:344
  otp->p_prev = cp->p_prev;
 800116c:	6062      	str	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800116e:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:345
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 8001170:	605c      	str	r4, [r3, #4]
 8001172:	6014      	str	r4, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347

  chSysSwitch(currp, otp);
 8001174:	f7ff fe7c 	bl	8000e70 <dbg_trace>
 8001178:	69e3      	ldr	r3, [r4, #28]
 800117a:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 800117e:	4293      	cmp	r3, r2
 8001180:	d902      	bls.n	8001188 <chSchDoRescheduleAhead+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347 (discriminator 1)
 8001182:	4805      	ldr	r0, [pc, #20]	; (8001198 <chSchDoRescheduleAhead+0x58>)
 8001184:	f000 fdf4 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347 (discriminator 2)
 8001188:	69a8      	ldr	r0, [r5, #24]
 800118a:	4621      	mov	r1, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:348 (discriminator 2)
}
 800118c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347 (discriminator 2)
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8001190:	f7ff bcee 	b.w	8000b70 <_port_switch>
 8001194:	2000126c 	.word	0x2000126c
 8001198:	08002862 	.word	0x08002862
$d():
 800119c:	00000000 	.word	0x00000000

080011a0 <chSchDoReschedule>:
chSchDoReschedule():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:367
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
 80011a0:	4b04      	ldr	r3, [pc, #16]	; (80011b4 <chSchDoReschedule+0x14>)
 80011a2:	699b      	ldr	r3, [r3, #24]
 80011a4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80011a8:	b90b      	cbnz	r3, 80011ae <chSchDoReschedule+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:370
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 80011aa:	f7ff bfa1 	b.w	80010f0 <chSchDoRescheduleBehind>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:375
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 80011ae:	f7ff bfc7 	b.w	8001140 <chSchDoRescheduleAhead>
 80011b2:	bf00      	nop
 80011b4:	2000126c 	.word	0x2000126c
	...

080011c0 <chSemWaitS>:
chSemWaitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:185
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(Semaphore *sp) {
 80011c0:	b538      	push	{r3, r4, r5, lr}
 80011c2:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:187

  chDbgCheckClassS();
 80011c4:	f7ff fe2c 	bl	8000e20 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:188
  chDbgCheck(sp != NULL, "chSemWaitS");
 80011c8:	b914      	cbnz	r4, 80011d0 <chSemWaitS+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:188 (discriminator 1)
 80011ca:	4812      	ldr	r0, [pc, #72]	; (8001214 <chSemWaitS+0x54>)
 80011cc:	f000 fdd0 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:189
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
 80011d0:	68a3      	ldr	r3, [r4, #8]
 80011d2:	2b00      	cmp	r3, #0
 80011d4:	6823      	ldr	r3, [r4, #0]
 80011d6:	db02      	blt.n	80011de <chSemWaitS+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:189 (discriminator 2)
 80011d8:	42a3      	cmp	r3, r4
 80011da:	d102      	bne.n	80011e2 <chSemWaitS+0x22>
 80011dc:	e004      	b.n	80011e8 <chSemWaitS+0x28>
 80011de:	42a3      	cmp	r3, r4
 80011e0:	d102      	bne.n	80011e8 <chSemWaitS+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:189 (discriminator 1)
 80011e2:	480d      	ldr	r0, [pc, #52]	; (8001218 <chSemWaitS+0x58>)
 80011e4:	f000 fdc4 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:194
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
 80011e8:	68a3      	ldr	r3, [r4, #8]
 80011ea:	3b01      	subs	r3, #1
 80011ec:	2b00      	cmp	r3, #0
 80011ee:	60a3      	str	r3, [r4, #8]
 80011f0:	da0d      	bge.n	800120e <chSemWaitS+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:195
    currp->p_u.wtobjp = sp;
 80011f2:	4d0a      	ldr	r5, [pc, #40]	; (800121c <chSemWaitS+0x5c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:197
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
 80011f4:	2003      	movs	r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:195
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
 80011f6:	69ab      	ldr	r3, [r5, #24]
 80011f8:	629c      	str	r4, [r3, #40]	; 0x28
queue_insert():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:55
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
 80011fa:	6862      	ldr	r2, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:54
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
 80011fc:	601c      	str	r4, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:55
  tp->p_prev = tqp->p_prev;
 80011fe:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:56
  tp->p_prev->p_next = tqp->p_prev = tp;
 8001200:	6063      	str	r3, [r4, #4]
 8001202:	6013      	str	r3, [r2, #0]
chSemWaitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:197
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
 8001204:	f7ff fef4 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:198
    return currp->p_u.rdymsg;
 8001208:	69ab      	ldr	r3, [r5, #24]
 800120a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800120c:	bd38      	pop	{r3, r4, r5, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:200
  }
  return RDY_OK;
 800120e:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:201
}
 8001210:	bd38      	pop	{r3, r4, r5, pc}
 8001212:	bf00      	nop
 8001214:	080028b0 	.word	0x080028b0
 8001218:	080028bf 	.word	0x080028bf
 800121c:	2000126c 	.word	0x2000126c

08001220 <chSemWait>:
chSemWait():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:164
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
 8001220:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:167
  msg_t msg;

  chSysLock();
 8001222:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:164
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
 8001224:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:167
  msg_t msg;

  chSysLock();
 8001226:	f383 8811 	msr	BASEPRI, r3
 800122a:	f7ff fd41 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:168
  msg = chSemWaitS(sp);
 800122e:	4620      	mov	r0, r4
 8001230:	f7ff ffc6 	bl	80011c0 <chSemWaitS>
 8001234:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:169
  chSysUnlock();
 8001236:	f7ff fd53 	bl	8000ce0 <dbg_check_unlock>
 800123a:	2300      	movs	r3, #0
 800123c:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:171
  return msg;
}
 8001240:	4620      	mov	r0, r4
 8001242:	bd10      	pop	{r4, pc}
	...

08001250 <chSemSignal>:
chSemSignal():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:278
 *
 * @param[in] sp        pointer to a @p Semaphore structure
 *
 * @api
 */
void chSemSignal(Semaphore *sp) {
 8001250:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:280

  chDbgCheck(sp != NULL, "chSemSignal");
 8001252:	4604      	mov	r4, r0
 8001254:	b910      	cbnz	r0, 800125c <chSemSignal+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:280 (discriminator 1)
 8001256:	4813      	ldr	r0, [pc, #76]	; (80012a4 <chSemSignal+0x54>)
 8001258:	f000 fd8a 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:281
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
 800125c:	68a3      	ldr	r3, [r4, #8]
 800125e:	2b00      	cmp	r3, #0
 8001260:	6823      	ldr	r3, [r4, #0]
 8001262:	db02      	blt.n	800126a <chSemSignal+0x1a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:281 (discriminator 2)
 8001264:	42a3      	cmp	r3, r4
 8001266:	d102      	bne.n	800126e <chSemSignal+0x1e>
 8001268:	e004      	b.n	8001274 <chSemSignal+0x24>
 800126a:	42a3      	cmp	r3, r4
 800126c:	d102      	bne.n	8001274 <chSemSignal+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:281 (discriminator 1)
 800126e:	480e      	ldr	r0, [pc, #56]	; (80012a8 <chSemSignal+0x58>)
 8001270:	f000 fd7e 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:286
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
 8001274:	2320      	movs	r3, #32
 8001276:	f383 8811 	msr	BASEPRI, r3
 800127a:	f7ff fd19 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:287
  if (++sp->s_cnt <= 0)
 800127e:	68a3      	ldr	r3, [r4, #8]
 8001280:	3301      	adds	r3, #1
 8001282:	2b00      	cmp	r3, #0
 8001284:	60a3      	str	r3, [r4, #8]
 8001286:	dc06      	bgt.n	8001296 <chSemSignal+0x46>
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8001288:	6820      	ldr	r0, [r4, #0]
chSemSignal():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:288
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
 800128a:	2100      	movs	r1, #0
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 800128c:	6803      	ldr	r3, [r0, #0]
 800128e:	6023      	str	r3, [r4, #0]
 8001290:	605c      	str	r4, [r3, #4]
chSemSignal():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:288
 8001292:	f7ff fefd 	bl	8001090 <chSchWakeupS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:289
  chSysUnlock();
 8001296:	f7ff fd23 	bl	8000ce0 <dbg_check_unlock>
 800129a:	2300      	movs	r3, #0
 800129c:	f383 8811 	msr	BASEPRI, r3
 80012a0:	bd10      	pop	{r4, pc}
 80012a2:	bf00      	nop
 80012a4:	080028fe 	.word	0x080028fe
 80012a8:	0800290e 	.word	0x0800290e
$d():
 80012ac:	00000000 	.word	0x00000000

080012b0 <_idle_thread>:
_idle_thread():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:64
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 80012b0:	4b02      	ldr	r3, [pc, #8]	; (80012bc <_idle_thread+0xc>)
 80012b2:	4a03      	ldr	r2, [pc, #12]	; (80012c0 <_idle_thread+0x10>)
 80012b4:	699b      	ldr	r3, [r3, #24]
 80012b6:	619a      	str	r2, [r3, #24]
 80012b8:	e7fe      	b.n	80012b8 <_idle_thread+0x8>
 80012ba:	bf00      	nop
 80012bc:	2000126c 	.word	0x2000126c
 80012c0:	080029b0 	.word	0x080029b0
	...

080012d0 <chSysInit>:
chSysInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:84
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 80012d0:	b507      	push	{r0, r1, r2, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:90
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80012d2:	f7ff fbdd 	bl	8000a90 <_port_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:91
  _scheduler_init();
 80012d6:	f7ff fe33 	bl	8000f40 <_scheduler_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:92
  _vt_init();
 80012da:	f000 f931 	bl	8001540 <_vt_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:100
#endif
#if CH_USE_HEAP
  _heap_init();
#endif
#if CH_DBG_ENABLE_TRACE
  _trace_init();
 80012de:	f7ff fdb7 	bl	8000e50 <_trace_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:104
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 80012e2:	2140      	movs	r1, #64	; 0x40
 80012e4:	480f      	ldr	r0, [pc, #60]	; (8001324 <chSysInit+0x54>)
 80012e6:	f000 f863 	bl	80013b0 <_thread_init>
 80012ea:	4b0f      	ldr	r3, [pc, #60]	; (8001328 <chSysInit+0x58>)
 80012ec:	6198      	str	r0, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:105
  currp->p_state = THD_STATE_CURRENT;
 80012ee:	2301      	movs	r3, #1
 80012f0:	f880 3020 	strb.w	r3, [r0, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:109
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 80012f4:	4b0d      	ldr	r3, [pc, #52]	; (800132c <chSysInit+0x5c>)
 80012f6:	61c3      	str	r3, [r0, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:111
#endif
  chSysEnable();
 80012f8:	f7ff fcca 	bl	8000c90 <dbg_check_enable>
 80012fc:	2300      	movs	r3, #0
 80012fe:	f383 8811 	msr	BASEPRI, r3
 8001302:	b662      	cpsie	i
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:115

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8001304:	4b08      	ldr	r3, [pc, #32]	; (8001328 <chSysInit+0x58>)
 8001306:	4a0a      	ldr	r2, [pc, #40]	; (8001330 <chSysInit+0x60>)
 8001308:	699b      	ldr	r3, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800130a:	21a8      	movs	r1, #168	; 0xa8
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:115
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 800130c:	619a      	str	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800130e:	2300      	movs	r3, #0
 8001310:	9300      	str	r3, [sp, #0]
 8001312:	2201      	movs	r2, #1
 8001314:	4b07      	ldr	r3, [pc, #28]	; (8001334 <chSysInit+0x64>)
 8001316:	4808      	ldr	r0, [pc, #32]	; (8001338 <chSysInit+0x68>)
 8001318:	f000 f892 	bl	8001440 <chThdCreateStatic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:124
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 800131c:	b003      	add	sp, #12
 800131e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001322:	bf00      	nop
 8001324:	20000b7c 	.word	0x20000b7c
 8001328:	2000126c 	.word	0x2000126c
 800132c:	20000400 	.word	0x20000400
 8001330:	08002830 	.word	0x08002830
 8001334:	080012b1 	.word	0x080012b1
 8001338:	20001288 	.word	0x20001288
$d():
 800133c:	00000000 	.word	0x00000000

08001340 <chSysTimerHandlerI>:
chSysTimerHandlerI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:137
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:139

  chDbgCheckClassI();
 8001342:	f7ff fd55 	bl	8000df0 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:143

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
 8001346:	4b16      	ldr	r3, [pc, #88]	; (80013a0 <chSysTimerHandlerI+0x60>)
 8001348:	699b      	ldr	r3, [r3, #24]
 800134a:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800134e:	b112      	cbz	r2, 8001356 <chSysTimerHandlerI+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:145
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 8001350:	3a01      	subs	r2, #1
 8001352:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:148
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
 8001356:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001358:	3201      	adds	r2, #1
 800135a:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:150
#endif
  chVTDoTickI();
 800135c:	4b11      	ldr	r3, [pc, #68]	; (80013a4 <chSysTimerHandlerI+0x64>)
 800135e:	68da      	ldr	r2, [r3, #12]
 8001360:	461e      	mov	r6, r3
 8001362:	3201      	adds	r2, #1
 8001364:	60da      	str	r2, [r3, #12]
 8001366:	681a      	ldr	r2, [r3, #0]
 8001368:	429a      	cmp	r2, r3
 800136a:	d018      	beq.n	800139e <chSysTimerHandlerI+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:150 (discriminator 1)
 800136c:	6891      	ldr	r1, [r2, #8]
 800136e:	3901      	subs	r1, #1
 8001370:	6091      	str	r1, [r2, #8]
 8001372:	6834      	ldr	r4, [r6, #0]
 8001374:	4a0b      	ldr	r2, [pc, #44]	; (80013a4 <chSysTimerHandlerI+0x64>)
 8001376:	68a5      	ldr	r5, [r4, #8]
 8001378:	b98d      	cbnz	r5, 800139e <chSysTimerHandlerI+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:150 (discriminator 2)
 800137a:	6821      	ldr	r1, [r4, #0]
 800137c:	68e7      	ldr	r7, [r4, #12]
 800137e:	60e5      	str	r5, [r4, #12]
 8001380:	604a      	str	r2, [r1, #4]
 8001382:	6011      	str	r1, [r2, #0]
 8001384:	f7ff fcdc 	bl	8000d40 <dbg_check_unlock_from_isr>
 8001388:	462b      	mov	r3, r5
 800138a:	f383 8811 	msr	BASEPRI, r3
 800138e:	6920      	ldr	r0, [r4, #16]
 8001390:	47b8      	blx	r7
 8001392:	2320      	movs	r3, #32
 8001394:	f383 8811 	msr	BASEPRI, r3
 8001398:	f7ff fcba 	bl	8000d10 <dbg_check_lock_from_isr>
 800139c:	e7e9      	b.n	8001372 <chSysTimerHandlerI+0x32>
 800139e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80013a0:	2000126c 	.word	0x2000126c
 80013a4:	20001330 	.word	0x20001330
	...

080013b0 <_thread_init>:
_thread_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:79
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 80013b0:	2202      	movs	r2, #2
 80013b2:	f880 2020 	strb.w	r2, [r0, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:80
  tp->p_flags = THD_MEM_MODE_STATIC;
 80013b6:	2200      	movs	r2, #0
 80013b8:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:89
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 80013bc:	6302      	str	r2, [r0, #48]	; 0x30
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:92
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
 80013be:	6242      	str	r2, [r0, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:98
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 80013c0:	6182      	str	r2, [r0, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:99
  REG_INSERT(tp);
 80013c2:	4a08      	ldr	r2, [pc, #32]	; (80013e4 <_thread_init+0x34>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:78
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 80013c4:	6081      	str	r1, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:82
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 80013c6:	2114      	movs	r1, #20
 80013c8:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80013cc:	6951      	ldr	r1, [r2, #20]
 80013ce:	6102      	str	r2, [r0, #16]
 80013d0:	6141      	str	r1, [r0, #20]
 80013d2:	6150      	str	r0, [r2, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:102
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 80013d4:	f100 022c 	add.w	r2, r0, #44	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80013d8:	6108      	str	r0, [r1, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:102
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 80013da:	62c2      	str	r2, [r0, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:108
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 80013dc:	f100 0234 	add.w	r2, r0, #52	; 0x34
 80013e0:	61c2      	str	r2, [r0, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:114
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
 80013e2:	4770      	bx	lr
 80013e4:	2000126c 	.word	0x2000126c
	...

080013f0 <chThdCreateI>:
chThdCreateI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:158
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
 80013f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80013f4:	4604      	mov	r4, r0
 80013f6:	460f      	mov	r7, r1
 80013f8:	4615      	mov	r5, r2
 80013fa:	461e      	mov	r6, r3
 80013fc:	f8dd 8018 	ldr.w	r8, [sp, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:162
  /* Thread structure is laid out in the lower part of the thread workspace.*/
  Thread *tp = wsp;

  chDbgCheckClassI();
 8001400:	f7ff fcf6 	bl	8000df0 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:164

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
 8001404:	b124      	cbz	r4, 8001410 <chThdCreateI+0x20>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:164 (discriminator 2)
 8001406:	2f97      	cmp	r7, #151	; 0x97
 8001408:	d902      	bls.n	8001410 <chThdCreateI+0x20>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:164 (discriminator 1)
 800140a:	2d7f      	cmp	r5, #127	; 0x7f
 800140c:	d800      	bhi.n	8001410 <chThdCreateI+0x20>
 800140e:	b916      	cbnz	r6, 8001416 <chThdCreateI+0x26>
 8001410:	4808      	ldr	r0, [pc, #32]	; (8001434 <chThdCreateI+0x44>)
 8001412:	f000 fcad 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:167
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8001416:	3f24      	subs	r7, #36	; 0x24
 8001418:	4b07      	ldr	r3, [pc, #28]	; (8001438 <chThdCreateI+0x48>)
 800141a:	19e0      	adds	r0, r4, r7
 800141c:	60e0      	str	r0, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 800141e:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:167
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8001420:	51e6      	str	r6, [r4, r7]
 8001422:	f8c0 8004 	str.w	r8, [r0, #4]
 8001426:	6203      	str	r3, [r0, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 8001428:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:169
}
 800142a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:168

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
 800142e:	f7ff bfbf 	b.w	80013b0 <_thread_init>
 8001432:	bf00      	nop
 8001434:	080029c0 	.word	0x080029c0
 8001438:	08000b81 	.word	0x08000b81
$d():
 800143c:	00000000 	.word	0x00000000

08001440 <chThdCreateStatic>:
chThdCreateStatic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 8001440:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001444:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:192
  Thread *tp;
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
 8001446:	f100 0534 	add.w	r5, r0, #52	; 0x34
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 800144a:	460e      	mov	r6, r1
 800144c:	4690      	mov	r8, r2
 800144e:	461f      	mov	r7, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:192
  Thread *tp;
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
 8001450:	2000      	movs	r0, #0
_thread_memfill():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:129
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp)
    *startp++ = v;
 8001452:	23ff      	movs	r3, #255	; 0xff
 8001454:	5423      	strb	r3, [r4, r0]
 8001456:	3001      	adds	r0, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:128
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp)
 8001458:	2834      	cmp	r0, #52	; 0x34
 800145a:	d1fa      	bne.n	8001452 <chThdCreateStatic+0x12>
chThdCreateStatic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:195
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(Thread),
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
 800145c:	19a3      	adds	r3, r4, r6
_thread_memfill():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:128
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp)
 800145e:	429d      	cmp	r5, r3
 8001460:	d203      	bcs.n	800146a <chThdCreateStatic+0x2a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:129
    *startp++ = v;
 8001462:	2255      	movs	r2, #85	; 0x55
 8001464:	f805 2b01 	strb.w	r2, [r5], #1
 8001468:	e7f9      	b.n	800145e <chThdCreateStatic+0x1e>
chThdCreateStatic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:199
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
 800146a:	2320      	movs	r3, #32
 800146c:	f383 8811 	msr	BASEPRI, r3
 8001470:	f7ff fc1e 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:200
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 8001474:	9908      	ldr	r1, [sp, #32]
 8001476:	463b      	mov	r3, r7
 8001478:	4642      	mov	r2, r8
 800147a:	9100      	str	r1, [sp, #0]
 800147c:	4620      	mov	r0, r4
 800147e:	4631      	mov	r1, r6
 8001480:	f7ff ffb6 	bl	80013f0 <chThdCreateI>
 8001484:	2100      	movs	r1, #0
 8001486:	4604      	mov	r4, r0
 8001488:	f7ff fe02 	bl	8001090 <chSchWakeupS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:201
  chSysUnlock();
 800148c:	f7ff fc28 	bl	8000ce0 <dbg_check_unlock>
 8001490:	2300      	movs	r3, #0
 8001492:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:203
  return tp;
}
 8001496:	4620      	mov	r0, r4
 8001498:	b002      	add	sp, #8
 800149a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080014a0 <chThdSleep>:
chThdSleep():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:292
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80014a0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:294

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");
 80014a2:	4604      	mov	r4, r0
 80014a4:	b910      	cbnz	r0, 80014ac <chThdSleep+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:294 (discriminator 1)
 80014a6:	4809      	ldr	r0, [pc, #36]	; (80014cc <chThdSleep+0x2c>)
 80014a8:	f000 fc62 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:296

  chSysLock();
 80014ac:	2320      	movs	r3, #32
 80014ae:	f383 8811 	msr	BASEPRI, r3
 80014b2:	f7ff fbfd 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:297
  chThdSleepS(time);
 80014b6:	4621      	mov	r1, r4
 80014b8:	2006      	movs	r0, #6
 80014ba:	f7ff fdc1 	bl	8001040 <chSchGoSleepTimeoutS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:298
  chSysUnlock();
 80014be:	f7ff fc0f 	bl	8000ce0 <dbg_check_unlock>
 80014c2:	2300      	movs	r3, #0
 80014c4:	f383 8811 	msr	BASEPRI, r3
 80014c8:	bd10      	pop	{r4, pc}
 80014ca:	bf00      	nop
 80014cc:	080029f8 	.word	0x080029f8

080014d0 <chThdExitS>:
chThdExitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:367
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  Thread *tp = currp;
 80014d0:	4b0f      	ldr	r3, [pc, #60]	; (8001510 <chThdExitS+0x40>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:366
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80014d2:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:367
  Thread *tp = currp;
 80014d4:	699c      	ldr	r4, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:369

  tp->p_u.exitcode = msg;
 80014d6:	62a0      	str	r0, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:374 (discriminator 1)
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 80014d8:	4623      	mov	r3, r4
 80014da:	f853 0f2c 	ldr.w	r0, [r3, #44]!
 80014de:	4298      	cmp	r0, r3
 80014e0:	d004      	beq.n	80014ec <chThdExitS+0x1c>
list_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:89
}

static INLINE Thread *list_remove(ThreadsList *tlp) {

  Thread *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 80014e2:	6803      	ldr	r3, [r0, #0]
 80014e4:	62e3      	str	r3, [r4, #44]	; 0x2c
chThdExitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:375
    chSchReadyI(list_remove(&tp->p_waiting));
 80014e6:	f7ff fd3b 	bl	8000f60 <chSchReadyI>
 80014ea:	e7f5      	b.n	80014d8 <chThdExitS+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:380
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 80014ec:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 80014f0:	079b      	lsls	r3, r3, #30
 80014f2:	d104      	bne.n	80014fe <chThdExitS+0x2e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:381
    REG_REMOVE(tp);
 80014f4:	6922      	ldr	r2, [r4, #16]
 80014f6:	6963      	ldr	r3, [r4, #20]
 80014f8:	611a      	str	r2, [r3, #16]
 80014fa:	6922      	ldr	r2, [r4, #16]
 80014fc:	6153      	str	r3, [r2, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:383
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 80014fe:	200e      	movs	r0, #14
 8001500:	f7ff fd76 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:386
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 8001504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:385
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
 8001508:	4802      	ldr	r0, [pc, #8]	; (8001514 <chThdExitS+0x44>)
 800150a:	f000 bc31 	b.w	8001d70 <chDbgPanic>
 800150e:	bf00      	nop
 8001510:	2000126c 	.word	0x2000126c
 8001514:	08002a07 	.word	0x08002a07
	...

08001520 <chThdExit>:
chThdExit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:345
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001520:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:347

  chSysLock();
 8001522:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:345
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001524:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:347

  chSysLock();
 8001526:	f383 8811 	msr	BASEPRI, r3
 800152a:	f7ff fbc1 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:348
  chThdExitS(msg);
 800152e:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:350
  /* The thread never returns here.*/
}
 8001530:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:348
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001534:	f7ff bfcc 	b.w	80014d0 <chThdExitS>
	...

08001540 <_vt_init>:
_vt_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 8001540:	4b04      	ldr	r3, [pc, #16]	; (8001554 <_vt_init+0x14>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:53
  vtlist.vt_time = (systime_t)-1;
 8001542:	f04f 32ff 	mov.w	r2, #4294967295
 8001546:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:54
  vtlist.vt_systime = 0;
 8001548:	2200      	movs	r2, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 800154a:	605b      	str	r3, [r3, #4]
 800154c:	601b      	str	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:54
  vtlist.vt_time = (systime_t)-1;
  vtlist.vt_systime = 0;
 800154e:	60da      	str	r2, [r3, #12]
 8001550:	4770      	bx	lr
 8001552:	bf00      	nop
 8001554:	20001330 	.word	0x20001330
	...

08001560 <chVTSetI>:
chVTSetI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:76
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 8001560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001562:	4604      	mov	r4, r0
 8001564:	460d      	mov	r5, r1
 8001566:	4616      	mov	r6, r2
 8001568:	461f      	mov	r7, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:79
  VirtualTimer *p;

  chDbgCheckClassI();
 800156a:	f7ff fc41 	bl	8000df0 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:80
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
 800156e:	b10c      	cbz	r4, 8001574 <chVTSetI+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:80 (discriminator 2)
 8001570:	b106      	cbz	r6, 8001574 <chVTSetI+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:80 (discriminator 1)
 8001572:	b915      	cbnz	r5, 800157a <chVTSetI+0x1a>
 8001574:	480c      	ldr	r0, [pc, #48]	; (80015a8 <chVTSetI+0x48>)
 8001576:	f000 fbfb 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:85
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 800157a:	4a0c      	ldr	r2, [pc, #48]	; (80015ac <chVTSetI+0x4c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:83

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
 800157c:	6127      	str	r7, [r4, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:85
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 800157e:	6813      	ldr	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:84
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8001580:	60e6      	str	r6, [r4, #12]
 8001582:	4611      	mov	r1, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:86 (discriminator 1)
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 8001584:	689a      	ldr	r2, [r3, #8]
 8001586:	42aa      	cmp	r2, r5
 8001588:	d202      	bcs.n	8001590 <chVTSetI+0x30>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:87
    time -= p->vt_time;
 800158a:	1aad      	subs	r5, r5, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:88
    p = p->vt_next;
 800158c:	681b      	ldr	r3, [r3, #0]
 800158e:	e7f9      	b.n	8001584 <chVTSetI+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:91
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8001590:	685a      	ldr	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:94
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_time = time;
  if (p != (void *)&vtlist)
 8001592:	428b      	cmp	r3, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:91
  while (p->vt_time < time) {
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8001594:	6023      	str	r3, [r4, #0]
 8001596:	6062      	str	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:92
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8001598:	605c      	str	r4, [r3, #4]
 800159a:	6014      	str	r4, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:93
  vtp->vt_time = time;
 800159c:	60a5      	str	r5, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:94
  if (p != (void *)&vtlist)
 800159e:	d002      	beq.n	80015a6 <chVTSetI+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:95
    p->vt_time -= time;
 80015a0:	689a      	ldr	r2, [r3, #8]
 80015a2:	1b55      	subs	r5, r2, r5
 80015a4:	609d      	str	r5, [r3, #8]
 80015a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80015a8:	08002a40 	.word	0x08002a40
 80015ac:	20001330 	.word	0x20001330

080015b0 <chVTResetI>:
chVTResetI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:106
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 80015b0:	b510      	push	{r4, lr}
 80015b2:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:108

  chDbgCheckClassI();
 80015b4:	f7ff fc1c 	bl	8000df0 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:109
  chDbgCheck(vtp != NULL, "chVTResetI");
 80015b8:	b914      	cbnz	r4, 80015c0 <chVTResetI+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:109 (discriminator 1)
 80015ba:	480b      	ldr	r0, [pc, #44]	; (80015e8 <chVTResetI+0x38>)
 80015bc:	f000 fbd8 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:110
  chDbgAssert(vtp->vt_func != NULL,
 80015c0:	68e3      	ldr	r3, [r4, #12]
 80015c2:	b913      	cbnz	r3, 80015ca <chVTResetI+0x1a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:110 (discriminator 1)
 80015c4:	4809      	ldr	r0, [pc, #36]	; (80015ec <chVTResetI+0x3c>)
 80015c6:	f000 fbd3 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:114
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 80015ca:	6823      	ldr	r3, [r4, #0]
 80015cc:	4a08      	ldr	r2, [pc, #32]	; (80015f0 <chVTResetI+0x40>)
 80015ce:	4293      	cmp	r3, r2
 80015d0:	d003      	beq.n	80015da <chVTResetI+0x2a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:115
    vtp->vt_next->vt_time += vtp->vt_time;
 80015d2:	6899      	ldr	r1, [r3, #8]
 80015d4:	68a2      	ldr	r2, [r4, #8]
 80015d6:	440a      	add	r2, r1
 80015d8:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:116
  vtp->vt_prev->vt_next = vtp->vt_next;
 80015da:	6862      	ldr	r2, [r4, #4]
 80015dc:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:117
  vtp->vt_next->vt_prev = vtp->vt_prev;
 80015de:	6823      	ldr	r3, [r4, #0]
 80015e0:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:118
  vtp->vt_func = (vtfunc_t)NULL;
 80015e2:	2300      	movs	r3, #0
 80015e4:	60e3      	str	r3, [r4, #12]
 80015e6:	bd10      	pop	{r4, pc}
 80015e8:	08002a4d 	.word	0x08002a4d
 80015ec:	08002a5c 	.word	0x08002a5c
 80015f0:	20001330 	.word	0x20001330
	...

08001600 <halInit>:
halInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/src/hal.c:70
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
 8001600:	f000 b806 	b.w	8001610 <hal_lld_init>
	...

08001610 <hal_lld_init>:
hal_lld_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:96
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 8001610:	4b15      	ldr	r3, [pc, #84]	; (8001668 <hal_lld_init+0x58>)
 8001612:	691a      	ldr	r2, [r3, #16]
 8001614:	f462 4200 	orn	r2, r2, #32768	; 0x8000
 8001618:	611a      	str	r2, [r3, #16]
 800161a:	2200      	movs	r2, #0
 800161c:	611a      	str	r2, [r3, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:97
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800161e:	6999      	ldr	r1, [r3, #24]
 8001620:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8001624:	6199      	str	r1, [r3, #24]
 8001626:	619a      	str	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:98
  rccResetAPB2(~0);
 8001628:	6959      	ldr	r1, [r3, #20]
 800162a:	f04f 31ff 	mov.w	r1, #4294967295
 800162e:	6159      	str	r1, [r3, #20]
 8001630:	615a      	str	r2, [r3, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:100

  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001632:	6a19      	ldr	r1, [r3, #32]
 8001634:	f041 0101 	orr.w	r1, r1, #1
 8001638:	6219      	str	r1, [r3, #32]
 800163a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800163c:	f041 0101 	orr.w	r1, r1, #1
 8001640:	62d9      	str	r1, [r3, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:103

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = Clk.AHBFreqHz / CH_FREQUENCY - 1;
 8001642:	490a      	ldr	r1, [pc, #40]	; (800166c <hal_lld_init+0x5c>)
 8001644:	6808      	ldr	r0, [r1, #0]
 8001646:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800164a:	fbb0 f0f1 	udiv	r0, r0, r1
 800164e:	4908      	ldr	r1, [pc, #32]	; (8001670 <hal_lld_init+0x60>)
 8001650:	3801      	subs	r0, #1
 8001652:	6048      	str	r0, [r1, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:104
  SysTick->VAL = 0;
 8001654:	608a      	str	r2, [r1, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:107
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;
 8001656:	2207      	movs	r2, #7
 8001658:	600a      	str	r2, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:114
  /* DWT cycle counter enable.*/
//  SCS_DEMCR |= SCS_DEMCR_TRCENA;
//  DWT_CTRL  |= DWT_CTRL_CYCCNTENA;

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800165a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800165c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001660:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:120

  /* Initializes the backup domain.*/
//  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8001662:	f000 b8dd 	b.w	8001820 <dmaInit>
 8001666:	bf00      	nop
 8001668:	40023800 	.word	0x40023800
 800166c:	20000bf0 	.word	0x20000bf0
 8001670:	e000e010 	.word	0xe000e010
	...

08001680 <Vector6C>:
Vector6C():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:114
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
 8001680:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:117
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001682:	f7ff fb75 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:119

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8001686:	4b08      	ldr	r3, [pc, #32]	; (80016a8 <Vector6C+0x28>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8001688:	220f      	movs	r2, #15
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 800168a:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 800168c:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:121
  if (dma_isr_redir[0].dma_func)
 800168e:	4a07      	ldr	r2, [pc, #28]	; (80016ac <Vector6C+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8001690:	f001 010f 	and.w	r1, r1, #15
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:121
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
 8001694:	6813      	ldr	r3, [r2, #0]
 8001696:	b10b      	cbz	r3, 800169c <Vector6C+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:122
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8001698:	6850      	ldr	r0, [r2, #4]
 800169a:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:124

  CH_IRQ_EPILOGUE();
 800169c:	f7ff fb88 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:125
}
 80016a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:124
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80016a4:	f7ff ba14 	b.w	8000ad0 <_port_irq_epilogue>
 80016a8:	40026000 	.word	0x40026000
 80016ac:	20000bb0 	.word	0x20000bb0

080016b0 <Vector70>:
Vector70():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:132
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
 80016b0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:135
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80016b2:	f7ff fb5d 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:137

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 80016b6:	4b08      	ldr	r3, [pc, #32]	; (80016d8 <Vector70+0x28>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 80016b8:	22f0      	movs	r2, #240	; 0xf0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 80016ba:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 80016bc:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:139
  if (dma_isr_redir[1].dma_func)
 80016be:	4a07      	ldr	r2, [pc, #28]	; (80016dc <Vector70+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 80016c0:	f3c1 1103 	ubfx	r1, r1, #4, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:139
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
 80016c4:	6893      	ldr	r3, [r2, #8]
 80016c6:	b10b      	cbz	r3, 80016cc <Vector70+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:140
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 80016c8:	68d0      	ldr	r0, [r2, #12]
 80016ca:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:142

  CH_IRQ_EPILOGUE();
 80016cc:	f7ff fb70 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:143
}
 80016d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:142
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80016d4:	f7ff b9fc 	b.w	8000ad0 <_port_irq_epilogue>
 80016d8:	40026000 	.word	0x40026000
 80016dc:	20000bb0 	.word	0x20000bb0

080016e0 <Vector74>:
Vector74():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:150
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
 80016e0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:153
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80016e2:	f7ff fb45 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:155

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 80016e6:	4b09      	ldr	r3, [pc, #36]	; (800170c <Vector74+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 80016e8:	f44f 6270 	mov.w	r2, #3840	; 0xf00
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 80016ec:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 80016ee:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:157
  if (dma_isr_redir[2].dma_func)
 80016f0:	4a07      	ldr	r2, [pc, #28]	; (8001710 <Vector74+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 80016f2:	f3c1 2103 	ubfx	r1, r1, #8, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:157
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
 80016f6:	6913      	ldr	r3, [r2, #16]
 80016f8:	b10b      	cbz	r3, 80016fe <Vector74+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:158
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 80016fa:	6950      	ldr	r0, [r2, #20]
 80016fc:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:160

  CH_IRQ_EPILOGUE();
 80016fe:	f7ff fb57 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:161
}
 8001702:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:160
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001706:	f7ff b9e3 	b.w	8000ad0 <_port_irq_epilogue>
 800170a:	bf00      	nop
 800170c:	40026000 	.word	0x40026000
 8001710:	20000bb0 	.word	0x20000bb0
	...

08001720 <Vector78>:
Vector78():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:168
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
 8001720:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:171
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001722:	f7ff fb25 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:173

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8001726:	4b09      	ldr	r3, [pc, #36]	; (800174c <Vector78+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8001728:	f44f 4270 	mov.w	r2, #61440	; 0xf000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 800172c:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 800172e:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:175
  if (dma_isr_redir[3].dma_func)
 8001730:	4a07      	ldr	r2, [pc, #28]	; (8001750 <Vector78+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8001732:	f3c1 3103 	ubfx	r1, r1, #12, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:175
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
 8001736:	6993      	ldr	r3, [r2, #24]
 8001738:	b10b      	cbz	r3, 800173e <Vector78+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:176
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800173a:	69d0      	ldr	r0, [r2, #28]
 800173c:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:178

  CH_IRQ_EPILOGUE();
 800173e:	f7ff fb37 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:179
}
 8001742:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:178
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001746:	f7ff b9c3 	b.w	8000ad0 <_port_irq_epilogue>
 800174a:	bf00      	nop
 800174c:	40026000 	.word	0x40026000
 8001750:	20000bb0 	.word	0x20000bb0
	...

08001760 <Vector7C>:
Vector7C():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:186
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
 8001760:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:189
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001762:	f7ff fb05 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:191

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8001766:	4b09      	ldr	r3, [pc, #36]	; (800178c <Vector7C+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8001768:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 800176c:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 800176e:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:193
  if (dma_isr_redir[4].dma_func)
 8001770:	4a07      	ldr	r2, [pc, #28]	; (8001790 <Vector7C+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8001772:	f3c1 4103 	ubfx	r1, r1, #16, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:193
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
 8001776:	6a13      	ldr	r3, [r2, #32]
 8001778:	b10b      	cbz	r3, 800177e <Vector7C+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:194
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800177a:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800177c:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:196

  CH_IRQ_EPILOGUE();
 800177e:	f7ff fb17 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:197
}
 8001782:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:196
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001786:	f7ff b9a3 	b.w	8000ad0 <_port_irq_epilogue>
 800178a:	bf00      	nop
 800178c:	40026000 	.word	0x40026000
 8001790:	20000bb0 	.word	0x20000bb0
	...

080017a0 <Vector80>:
Vector80():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:204
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
 80017a0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:207
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80017a2:	f7ff fae5 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:209

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80017a6:	4b09      	ldr	r3, [pc, #36]	; (80017cc <Vector80+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 80017a8:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80017ac:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 80017ae:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:211
  if (dma_isr_redir[5].dma_func)
 80017b0:	4a07      	ldr	r2, [pc, #28]	; (80017d0 <Vector80+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80017b2:	f3c1 5103 	ubfx	r1, r1, #20, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:211
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
 80017b6:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80017b8:	b10b      	cbz	r3, 80017be <Vector80+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:212
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 80017ba:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80017bc:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:214

  CH_IRQ_EPILOGUE();
 80017be:	f7ff faf7 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:215
}
 80017c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:214
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80017c6:	f7ff b983 	b.w	8000ad0 <_port_irq_epilogue>
 80017ca:	bf00      	nop
 80017cc:	40026000 	.word	0x40026000
 80017d0:	20000bb0 	.word	0x20000bb0
	...

080017e0 <Vector84>:
Vector84():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:222
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
 80017e0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:225
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80017e2:	f7ff fac5 	bl	8000d70 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:227

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 80017e6:	4b09      	ldr	r3, [pc, #36]	; (800180c <Vector84+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 80017e8:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 80017ec:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 80017ee:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:229
  if (dma_isr_redir[6].dma_func)
 80017f0:	4a07      	ldr	r2, [pc, #28]	; (8001810 <Vector84+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 80017f2:	f3c1 6103 	ubfx	r1, r1, #24, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:229
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
 80017f6:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80017f8:	b10b      	cbz	r3, 80017fe <Vector84+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:230
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 80017fa:	6b50      	ldr	r0, [r2, #52]	; 0x34
 80017fc:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:232

  CH_IRQ_EPILOGUE();
 80017fe:	f7ff fad7 	bl	8000db0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:233
}
 8001802:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:232
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001806:	f7ff b963 	b.w	8000ad0 <_port_irq_epilogue>
 800180a:	bf00      	nop
 800180c:	40026000 	.word	0x40026000
 8001810:	20000bb0 	.word	0x20000bb0
	...

08001820 <dmaInit>:
dmaInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:247
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8001820:	4a09      	ldr	r2, [pc, #36]	; (8001848 <dmaInit+0x28>)
 8001822:	2300      	movs	r3, #0
 8001824:	6013      	str	r3, [r2, #0]
 8001826:	210c      	movs	r1, #12
 8001828:	4359      	muls	r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:249 (discriminator 2)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 800182a:	4a08      	ldr	r2, [pc, #32]	; (800184c <dmaInit+0x2c>)
 800182c:	5889      	ldr	r1, [r1, r2]
 800182e:	2200      	movs	r2, #0
 8001830:	600a      	str	r2, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:250 (discriminator 2)
    dma_isr_redir[i].dma_func = NULL;
 8001832:	4907      	ldr	r1, [pc, #28]	; (8001850 <dmaInit+0x30>)
 8001834:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:248 (discriminator 2)
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001838:	3301      	adds	r3, #1
 800183a:	2b07      	cmp	r3, #7
 800183c:	d1f3      	bne.n	8001826 <dmaInit+0x6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:252
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 800183e:	4b05      	ldr	r3, [pc, #20]	; (8001854 <dmaInit+0x34>)
 8001840:	f04f 32ff 	mov.w	r2, #4294967295
 8001844:	605a      	str	r2, [r3, #4]
 8001846:	4770      	bx	lr
 8001848:	20000be8 	.word	0x20000be8
 800184c:	08002ac0 	.word	0x08002ac0
 8001850:	20000bb0 	.word	0x20000bb0
 8001854:	40026000 	.word	0x40026000
	...

08001860 <dmaStreamAllocate>:
dmaStreamAllocate():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:282
 * @special
 */
bool_t dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                         uint32_t priority,
                         stm32_dmaisr_t func,
                         void *param) {
 8001860:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001864:	460f      	mov	r7, r1
 8001866:	4615      	mov	r5, r2
 8001868:	4698      	mov	r8, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:284

  chDbgCheck(dmastp != NULL, "dmaStreamAllocate");
 800186a:	4604      	mov	r4, r0
 800186c:	b910      	cbnz	r0, 8001874 <dmaStreamAllocate+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:284 (discriminator 1)
 800186e:	481a      	ldr	r0, [pc, #104]	; (80018d8 <dmaStreamAllocate+0x78>)
 8001870:	f000 fa7e 	bl	8001d70 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:287

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8001874:	7a62      	ldrb	r2, [r4, #9]
 8001876:	2001      	movs	r0, #1
 8001878:	fa00 fc02 	lsl.w	ip, r0, r2
 800187c:	4e17      	ldr	r6, [pc, #92]	; (80018dc <dmaStreamAllocate+0x7c>)
 800187e:	6831      	ldr	r1, [r6, #0]
 8001880:	ea1c 0f01 	tst.w	ip, r1
 8001884:	d126      	bne.n	80018d4 <dmaStreamAllocate+0x74>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:291
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001886:	4816      	ldr	r0, [pc, #88]	; (80018e0 <dmaStreamAllocate+0x80>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8001888:	ea4c 0301 	orr.w	r3, ip, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:291
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800188c:	f840 5032 	str.w	r5, [r0, r2, lsl #3]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8001890:	6033      	str	r3, [r6, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001892:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8001896:	065b      	lsls	r3, r3, #25
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001898:	f8c2 8004 	str.w	r8, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800189c:	d004      	beq.n	80018a8 <dmaStreamAllocate+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:297
    rccEnableDMA1(FALSE);
 800189e:	4b11      	ldr	r3, [pc, #68]	; (80018e4 <dmaStreamAllocate+0x84>)
 80018a0:	69da      	ldr	r2, [r3, #28]
 80018a2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80018a6:	61da      	str	r2, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:300

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80018a8:	6823      	ldr	r3, [r4, #0]
 80018aa:	200f      	movs	r0, #15
 80018ac:	681a      	ldr	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80018ae:	2600      	movs	r6, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:300
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80018b0:	f022 020f 	bic.w	r2, r2, #15
 80018b4:	601a      	str	r2, [r3, #0]
 80018b6:	7a21      	ldrb	r1, [r4, #8]
 80018b8:	6862      	ldr	r2, [r4, #4]
 80018ba:	fa00 f101 	lsl.w	r1, r0, r1
 80018be:	6011      	str	r1, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80018c0:	601e      	str	r6, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:304

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 80018c2:	b135      	cbz	r5, 80018d2 <dmaStreamAllocate+0x72>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:305
    nvicEnableVector(dmastp->vector, CORTEX_PRIORITY_MASK(priority));
 80018c4:	7aa0      	ldrb	r0, [r4, #10]
 80018c6:	0139      	lsls	r1, r7, #4
 80018c8:	f7ff f882 	bl	80009d0 <nvicEnableVector>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:307

  return FALSE;
 80018cc:	4630      	mov	r0, r6
 80018ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80018d2:	4628      	mov	r0, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:308
}
 80018d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80018d8:	08002a70 	.word	0x08002a70
 80018dc:	20000be8 	.word	0x20000be8
 80018e0:	20000bb0 	.word	0x20000bb0
 80018e4:	40023800 	.word	0x40023800
	...

080018f0 <Clk_t::UpdateFreqValues()>:
_ZN5Clk_t16UpdateFreqValuesEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 80018f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018f2:	b093      	sub	sp, #76	; 0x4c
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 80018f4:	2100      	movs	r1, #0
 80018f6:	2220      	movs	r2, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 80018f8:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 80018fa:	a80a      	add	r0, sp, #40	; 0x28
 80018fc:	f000 fea0 	bl	8002640 <memset>
 8001900:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001904:	930a      	str	r3, [sp, #40]	; 0x28
 8001906:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800190a:	930b      	str	r3, [sp, #44]	; 0x2c
 800190c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001910:	930c      	str	r3, [sp, #48]	; 0x30
 8001912:	4b34      	ldr	r3, [pc, #208]	; (80019e4 <Clk_t::UpdateFreqValues()+0xf4>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8001914:	4a34      	ldr	r2, [pc, #208]	; (80019e8 <Clk_t::UpdateFreqValues()+0xf8>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001916:	930d      	str	r3, [sp, #52]	; 0x34
 8001918:	4b34      	ldr	r3, [pc, #208]	; (80019ec <Clk_t::UpdateFreqValues()+0xfc>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 800191a:	6851      	ldr	r1, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 800191c:	930e      	str	r3, [sp, #56]	; 0x38
 800191e:	4b34      	ldr	r3, [pc, #208]	; (80019f0 <Clk_t::UpdateFreqValues()+0x100>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8001920:	6810      	ldr	r0, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001922:	930f      	str	r3, [sp, #60]	; 0x3c
 8001924:	4b33      	ldr	r3, [pc, #204]	; (80019f4 <Clk_t::UpdateFreqValues()+0x104>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:64
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8001926:	ae06      	add	r6, sp, #24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001928:	9310      	str	r3, [sp, #64]	; 0x40
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 800192a:	ab03      	add	r3, sp, #12
 800192c:	c303      	stmia	r3!, {r0, r1}
 800192e:	7a11      	ldrb	r1, [r2, #8]
 8001930:	7019      	strb	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:64
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8001932:	f102 0309 	add.w	r3, r2, #9
 8001936:	3219      	adds	r2, #25
 8001938:	4617      	mov	r7, r2
 800193a:	6818      	ldr	r0, [r3, #0]
 800193c:	6859      	ldr	r1, [r3, #4]
 800193e:	4634      	mov	r4, r6
 8001940:	c403      	stmia	r4!, {r0, r1}
 8001942:	3308      	adds	r3, #8
 8001944:	4293      	cmp	r3, r2
 8001946:	4626      	mov	r6, r4
 8001948:	d1f7      	bne.n	800193a <Clk_t::UpdateFreqValues()+0x4a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:65
    const uint8_t APBPrescTable[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 800194a:	6838      	ldr	r0, [r7, #0]
 800194c:	6879      	ldr	r1, [r7, #4]
 800194e:	ab01      	add	r3, sp, #4
 8001950:	c303      	stmia	r3!, {r0, r1}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:68

    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
 8001952:	4b29      	ldr	r3, [pc, #164]	; (80019f8 <Clk_t::UpdateFreqValues()+0x108>)
 8001954:	689a      	ldr	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:69
    tmp >>= 2;
 8001956:	f3c2 0281 	ubfx	r2, r2, #2, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:70
    switch(tmp) {
 800195a:	2a02      	cmp	r2, #2
 800195c:	d024      	beq.n	80019a8 <Clk_t::UpdateFreqValues()+0xb8>
 800195e:	2a03      	cmp	r2, #3
 8001960:	d00c      	beq.n	800197c <Clk_t::UpdateFreqValues()+0x8c>
 8001962:	2a01      	cmp	r2, #1
 8001964:	d101      	bne.n	800196a <Clk_t::UpdateFreqValues()+0x7a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:77
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
            SysClkHz = MSIClk[tmp];
            break;

        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
 8001966:	4b25      	ldr	r3, [pc, #148]	; (80019fc <Clk_t::UpdateFreqValues()+0x10c>)
 8001968:	e01f      	b.n	80019aa <Clk_t::UpdateFreqValues()+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 800196a:	685b      	ldr	r3, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 800196c:	a812      	add	r0, sp, #72	; 0x48
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 800196e:	f3c3 3342 	ubfx	r3, r3, #13, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8001972:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001976:	f853 3c20 	ldr.w	r3, [r3, #-32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:74
            break;
 800197a:	e016      	b.n	80019aa <Clk_t::UpdateFreqValues()+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 800197c:	689a      	ldr	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 800197e:	a912      	add	r1, sp, #72	; 0x48
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8001980:	f3c2 4283 	ubfx	r2, r2, #18, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8001984:	440a      	add	r2, r1
 8001986:	f812 1c3c 	ldrb.w	r1, [r2, #-60]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:88
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 800198a:	689a      	ldr	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 800198c:	689b      	ldr	r3, [r3, #8]
 800198e:	481c      	ldr	r0, [pc, #112]	; (8001a00 <Clk_t::UpdateFreqValues()+0x110>)
 8001990:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8001994:	4b19      	ldr	r3, [pc, #100]	; (80019fc <Clk_t::UpdateFreqValues()+0x10c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8001996:	f3c2 5281 	ubfx	r2, r2, #22, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 800199a:	bf18      	it	ne
 800199c:	4603      	movne	r3, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:91
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 800199e:	434b      	muls	r3, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 80019a0:	3201      	adds	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:91
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 80019a2:	fbb3 f3f2 	udiv	r3, r3, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:92
            break;
 80019a6:	e000      	b.n	80019aa <Clk_t::UpdateFreqValues()+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:81
        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
            break;

        case 0b10: // HSE
            SysClkHz = CRYSTAL_FREQ_HZ;
 80019a8:	4b15      	ldr	r3, [pc, #84]	; (8001a00 <Clk_t::UpdateFreqValues()+0x110>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:96
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
            break;
    } // switch

    // AHB freq
    tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80019aa:	4a13      	ldr	r2, [pc, #76]	; (80019f8 <Clk_t::UpdateFreqValues()+0x108>)
 80019ac:	a812      	add	r0, sp, #72	; 0x48
 80019ae:	6891      	ldr	r1, [r2, #8]
 80019b0:	f3c1 1103 	ubfx	r1, r1, #4, #4
 80019b4:	4401      	add	r1, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:97
    AHBFreqHz = SysClkHz >> tmp;
 80019b6:	f811 1c30 	ldrb.w	r1, [r1, #-48]
 80019ba:	40cb      	lsrs	r3, r1
 80019bc:	602b      	str	r3, [r5, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:99
    // APB freq
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> 8];
 80019be:	6891      	ldr	r1, [r2, #8]
 80019c0:	f3c1 2102 	ubfx	r1, r1, #8, #3
 80019c4:	4401      	add	r1, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:100
    APB1FreqHz = AHBFreqHz >> tmp;
 80019c6:	f811 1c44 	ldrb.w	r1, [r1, #-68]
 80019ca:	fa23 f101 	lsr.w	r1, r3, r1
 80019ce:	6069      	str	r1, [r5, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:101
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> 11];
 80019d0:	6892      	ldr	r2, [r2, #8]
 80019d2:	f3c2 22c2 	ubfx	r2, r2, #11, #3
 80019d6:	4402      	add	r2, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:102
    APB2FreqHz = AHBFreqHz >> tmp;
 80019d8:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 80019dc:	40d3      	lsrs	r3, r2
 80019de:	60ab      	str	r3, [r5, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:103
}
 80019e0:	b013      	add	sp, #76	; 0x4c
 80019e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80019e4:	0007ff9c 	.word	0x0007ff9c
 80019e8:	080026e0 	.word	0x080026e0
 80019ec:	000ffdc0 	.word	0x000ffdc0
 80019f0:	001fff68 	.word	0x001fff68
 80019f4:	003ffed0 	.word	0x003ffed0
 80019f8:	40023800 	.word	0x40023800
 80019fc:	00f42400 	.word	0x00f42400
 8001a00:	007a1200 	.word	0x007a1200
	...

08001a10 <SetupVCore(VCore_t)>:
_Z10SetupVCore7VCore_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:198

// =============================== V Core ======================================
VCore_t VCore;
void SetupVCore(VCore_t AVCore) {
    // PWR clock enable
    RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001a10:	4b09      	ldr	r3, [pc, #36]	; (8001a38 <SetupVCore(VCore_t)+0x28>)
 8001a12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001a16:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:200 (discriminator 1)
    // Core voltage setup
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8001a18:	4b08      	ldr	r3, [pc, #32]	; (8001a3c <SetupVCore(VCore_t)+0x2c>)
 8001a1a:	685a      	ldr	r2, [r3, #4]
 8001a1c:	06d1      	lsls	r1, r2, #27
 8001a1e:	d4fb      	bmi.n	8001a18 <SetupVCore(VCore_t)+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:201
    uint32_t tmp = PWR->CR;
 8001a20:	681a      	ldr	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:202
    tmp &= ~PWR_CR_VOS;
 8001a22:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:203
    tmp |= ((uint32_t)AVCore) << 11;
 8001a26:	ea42 22c0 	orr.w	r2, r2, r0, lsl #11
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:204
    PWR->CR = tmp;
 8001a2a:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:205 (discriminator 1)
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8001a2c:	685a      	ldr	r2, [r3, #4]
 8001a2e:	06d2      	lsls	r2, r2, #27
 8001a30:	d4fc      	bmi.n	8001a2c <SetupVCore(VCore_t)+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:206
    VCore = AVCore;
 8001a32:	4b03      	ldr	r3, [pc, #12]	; (8001a40 <SetupVCore(VCore_t)+0x30>)
 8001a34:	7018      	strb	r0, [r3, #0]
 8001a36:	4770      	bx	lr
 8001a38:	40023800 	.word	0x40023800
 8001a3c:	40007000 	.word	0x40007000
 8001a40:	20000bec 	.word	0x20000bec
	...

08001a50 <CmdUart_t::IPutChar(char)>:
_ZN9CmdUart_t8IPutCharEc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:16
CmdUart_t Uart;

static inline void FPutChar(char c) { Uart.IPutChar(c); }

void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
 8001a50:	f8d0 31fc 	ldr.w	r3, [r0, #508]	; 0x1fc
 8001a54:	1c5a      	adds	r2, r3, #1
 8001a56:	f8c0 21fc 	str.w	r2, [r0, #508]	; 0x1fc
 8001a5a:	7019      	strb	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:17
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
 8001a5c:	f8d0 31fc 	ldr.w	r3, [r0, #508]	; 0x1fc
 8001a60:	f500 72fc 	add.w	r2, r0, #504	; 0x1f8
 8001a64:	4293      	cmp	r3, r2
 8001a66:	bf28      	it	cs
 8001a68:	f8c0 01fc 	strcs.w	r0, [r0, #508]	; 0x1fc
 8001a6c:	4770      	bx	lr
	...

08001a70 <FPutChar(char)>:
FPutChar():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:13
#include "cmd_uart.h"
#include <string.h>

CmdUart_t Uart;

static inline void FPutChar(char c) { Uart.IPutChar(c); }
 8001a70:	4601      	mov	r1, r0
 8001a72:	4801      	ldr	r0, [pc, #4]	; (8001a78 <FPutChar(char)+0x8>)
 8001a74:	f7ff bfec 	b.w	8001a50 <CmdUart_t::IPutChar(char)>
 8001a78:	20000bfc 	.word	0x20000bfc
$d():
 8001a7c:	00000000 	.word	0x00000000

08001a80 <CmdUart_t::Printf(char const*, ...)>:
_ZN9CmdUart_t6PrintfEPKcz():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:20
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::Printf(const char *format, ...) {
 8001a80:	b40e      	push	{r1, r2, r3}
 8001a82:	b517      	push	{r0, r1, r2, r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:21
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
 8001a84:	f8d0 31fc 	ldr.w	r3, [r0, #508]	; 0x1fc
 8001a88:	f8d0 11f8 	ldr.w	r1, [r0, #504]	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:20
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::Printf(const char *format, ...) {
 8001a8c:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:21
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
 8001a8e:	428b      	cmp	r3, r1
 8001a90:	bf28      	it	cs
 8001a92:	f501 71fc 	addcs.w	r1, r1, #504	; 0x1f8
 8001a96:	1ac9      	subs	r1, r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24
    va_list args;
    va_start(args, format);
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001a98:	4814      	ldr	r0, [pc, #80]	; (8001aec <CmdUart_t::Printf(char const*, ...)+0x6c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:23
}

void CmdUart_t::Printf(const char *format, ...) {
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
    va_list args;
    va_start(args, format);
 8001a9a:	ab06      	add	r3, sp, #24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001a9c:	9a05      	ldr	r2, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:23
}

void CmdUart_t::Printf(const char *format, ...) {
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
    va_list args;
    va_start(args, format);
 8001a9e:	9301      	str	r3, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001aa0:	f000 fc3e 	bl	8002320 <kl_vsprintf>
 8001aa4:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8001aa8:	4418      	add	r0, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:28
    va_end(args);

    // Start transmission if Idle
    if(IDmaIsIdle) {
 8001aaa:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24

void CmdUart_t::Printf(const char *format, ...) {
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
    va_list args;
    va_start(args, format);
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001aae:	f8c4 0204 	str.w	r0, [r4, #516]	; 0x204
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:28
    va_end(args);

    // Start transmission if Idle
    if(IDmaIsIdle) {
 8001ab2:	b1b3      	cbz	r3, 8001ae2 <CmdUart_t::Printf(char const*, ...)+0x62>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:29
        IDmaIsIdle = false;
 8001ab4:	2300      	movs	r3, #0
 8001ab6:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:30
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001aba:	4b0d      	ldr	r3, [pc, #52]	; (8001af0 <CmdUart_t::Printf(char const*, ...)+0x70>)
 8001abc:	f8d4 21f8 	ldr.w	r2, [r4, #504]	; 0x1f8
 8001ac0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:31
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;    // Char count from PRead to buffer end
 8001ac2:	f504 71fc 	add.w	r1, r4, #504	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:30
    va_end(args);

    // Start transmission if Idle
    if(IDmaIsIdle) {
        IDmaIsIdle = false;
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001ac6:	60da      	str	r2, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:31
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;    // Char count from PRead to buffer end
 8001ac8:	1a8a      	subs	r2, r1, r2
 8001aca:	4290      	cmp	r0, r2
 8001acc:	bf28      	it	cs
 8001ace:	4610      	movcs	r0, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:34
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;  // How many to transmit now
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001ad0:	2292      	movs	r2, #146	; 0x92
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:32
    // Start transmission if Idle
    if(IDmaIsIdle) {
        IDmaIsIdle = false;
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;    // Char count from PRead to buffer end
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;  // How many to transmit now
 8001ad2:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:33
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8001ad6:	6058      	str	r0, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:34
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001ad8:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:35
        dmaStreamEnable(UART_DMA_TX);
 8001ada:	681a      	ldr	r2, [r3, #0]
 8001adc:	f042 0201 	orr.w	r2, r2, #1
 8001ae0:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:37
    }
}
 8001ae2:	b003      	add	sp, #12
 8001ae4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001ae8:	b003      	add	sp, #12
 8001aea:	4770      	bx	lr
 8001aec:	08001a71 	.word	0x08001a71
 8001af0:	08002ac0 	.word	0x08002ac0
	...

08001b00 <CmdUart_t::Init(unsigned long)>:
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:128
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
 8001b00:	b538      	push	{r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:131
    PWrite = TXBuf;
    PRead = TXBuf;
    IDmaIsIdle = true;
 8001b02:	2301      	movs	r3, #1
 8001b04:	f880 3200 	strb.w	r3, [r0, #512]	; 0x200
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001b08:	4c2c      	ldr	r4, [pc, #176]	; (8001bbc <CmdUart_t::Init(unsigned long)+0xbc>)
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:132
    IFullSlotsCount = 0;
 8001b0a:	2300      	movs	r3, #0
 8001b0c:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
 8001b10:	69e2      	ldr	r2, [r4, #28]
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:129
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
    PWrite = TXBuf;
 8001b12:	f8c0 01fc 	str.w	r0, [r0, #508]	; 0x1fc
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
 8001b16:	f042 0201 	orr.w	r2, r2, #1
_ZN9CmdUart_t4InitEm():
    PRead = TXBuf;
 8001b1a:	f8c0 01f8 	str.w	r0, [r0, #504]	; 0x1f8
PinClockEnable():
 8001b1e:	61e2      	str	r2, [r4, #28]
PinSetupAlterFunc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001b20:	4a27      	ldr	r2, [pc, #156]	; (8001bc0 <CmdUart_t::Init(unsigned long)+0xc0>)
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001b22:	4d28      	ldr	r5, [pc, #160]	; (8001bc4 <CmdUart_t::Init(unsigned long)+0xc4>)
PinSetupAlterFunc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:192
 8001b24:	6810      	ldr	r0, [r2, #0]
 8001b26:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001b2a:	6010      	str	r0, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001b2c:	6810      	ldr	r0, [r2, #0]
 8001b2e:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001b32:	6010      	str	r0, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001b34:	8890      	ldrh	r0, [r2, #4]
 8001b36:	f420 7000 	bic.w	r0, r0, #512	; 0x200
 8001b3a:	0400      	lsls	r0, r0, #16
 8001b3c:	0c00      	lsrs	r0, r0, #16
 8001b3e:	8090      	strh	r0, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001b40:	8890      	ldrh	r0, [r2, #4]
 8001b42:	b280      	uxth	r0, r0
 8001b44:	8090      	strh	r0, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001b46:	68d0      	ldr	r0, [r2, #12]
 8001b48:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001b4c:	60d0      	str	r0, [r2, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001b4e:	68d0      	ldr	r0, [r2, #12]
 8001b50:	60d0      	str	r0, [r2, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001b52:	6890      	ldr	r0, [r2, #8]
 8001b54:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001b58:	6090      	str	r0, [r2, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001b5a:	6890      	ldr	r0, [r2, #8]
 8001b5c:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001b60:	6090      	str	r0, [r2, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001b62:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001b64:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8001b68:	6250      	str	r0, [r2, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001b6a:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001b6c:	f040 0070 	orr.w	r0, r0, #112	; 0x70
 8001b70:	6250      	str	r0, [r2, #36]	; 0x24
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:136
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8001b72:	6a22      	ldr	r2, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001b74:	4628      	mov	r0, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:136
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8001b76:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b7a:	6222      	str	r2, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:137
    UART->CR1 = USART_CR1_UE;     // Enable USART
 8001b7c:	f5a4 3480 	sub.w	r4, r4, #65536	; 0x10000
 8001b80:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001b84:	81a2      	strh	r2, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:138
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
 8001b86:	4a10      	ldr	r2, [pc, #64]	; (8001bc8 <CmdUart_t::Init(unsigned long)+0xc8>)
 8001b88:	6892      	ldr	r2, [r2, #8]
 8001b8a:	fbb2 f1f1 	udiv	r1, r2, r1
 8001b8e:	b28a      	uxth	r2, r1
 8001b90:	8122      	strh	r2, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001b92:	2107      	movs	r1, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:140
    // ==== USART configuration ====
    UART_RCC_ENABLE();
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
 8001b94:	8223      	strh	r3, [r4, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001b96:	4a0d      	ldr	r2, [pc, #52]	; (8001bcc <CmdUart_t::Init(unsigned long)+0xcc>)
 8001b98:	f7ff fe62 	bl	8001860 <dmaStreamAllocate>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:143
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 8001b9c:	682b      	ldr	r3, [r5, #0]
 8001b9e:	4a0c      	ldr	r2, [pc, #48]	; (8001bd0 <CmdUart_t::Init(unsigned long)+0xd0>)
 8001ba0:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:144
    dmaStreamSetMode      (UART_DMA_TX, UART_DMA_TX_MODE);
 8001ba2:	2292      	movs	r2, #146	; 0x92
 8001ba4:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:162
    dmaStreamSetMode      (UART_DMA_RX, UART_DMA_RX_MODE);
    dmaStreamEnable       (UART_DMA_RX);
    // Create and start thread
    chThdCreateStatic(waUartRxThread, sizeof(waUartRxThread), NORMALPRIO, (tfunc_t)UartRxThread, NULL);
#else
    UART->CR1 = USART_CR1_TE;     // Transmitter enabled
 8001ba6:	2308      	movs	r3, #8
 8001ba8:	81a3      	strh	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:163
    UART->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
 8001baa:	2380      	movs	r3, #128	; 0x80
 8001bac:	82a3      	strh	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:165
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
 8001bae:	89a3      	ldrh	r3, [r4, #12]
 8001bb0:	b29b      	uxth	r3, r3
 8001bb2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001bb6:	81a3      	strh	r3, [r4, #12]
 8001bb8:	bd38      	pop	{r3, r4, r5, pc}
 8001bba:	bf00      	nop
 8001bbc:	40023800 	.word	0x40023800
 8001bc0:	40020000 	.word	0x40020000
 8001bc4:	08002ae4 	.word	0x08002ae4
 8001bc8:	20000bf0 	.word	0x20000bf0
 8001bcc:	08001c51 	.word	0x08001c51
 8001bd0:	40013804 	.word	0x40013804
	...

08001be0 <CmdUart_t::IRQDmaTxHandler()>:
_ZN9CmdUart_t15IRQDmaTxHandlerEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:170
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8001be0:	4a19      	ldr	r2, [pc, #100]	; (8001c48 <CmdUart_t::IRQDmaTxHandler()+0x68>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:169
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
 8001be2:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:170
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8001be4:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8001be6:	240f      	movs	r4, #15
 8001be8:	6819      	ldr	r1, [r3, #0]
 8001bea:	f021 010f 	bic.w	r1, r1, #15
 8001bee:	6019      	str	r1, [r3, #0]
 8001bf0:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8001bf2:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8001bf6:	fa04 f202 	lsl.w	r2, r4, r2
 8001bfa:	600a      	str	r2, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8001bfc:	f8d0 41f8 	ldr.w	r4, [r0, #504]	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:171
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8001c00:	f8d0 1208 	ldr.w	r1, [r0, #520]	; 0x208
 8001c04:	f8d0 2204 	ldr.w	r2, [r0, #516]	; 0x204
 8001c08:	1a52      	subs	r2, r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172
    PRead += ITransSize;
 8001c0a:	4421      	add	r1, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:173
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer
 8001c0c:	f500 74fc 	add.w	r4, r0, #504	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8001c10:	42a1      	cmp	r1, r4
 8001c12:	bf28      	it	cs
 8001c14:	4601      	movcs	r1, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:171
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8001c16:	f8c0 2204 	str.w	r2, [r0, #516]	; 0x204
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172
    PRead += ITransSize;
 8001c1a:	f8c0 11f8 	str.w	r1, [r0, #504]	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:175
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer

    if(IFullSlotsCount == 0) IDmaIsIdle = true; // Nothing left to send
 8001c1e:	b91a      	cbnz	r2, 8001c28 <CmdUart_t::IRQDmaTxHandler()+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:175 (discriminator 1)
 8001c20:	2301      	movs	r3, #1
 8001c22:	f880 3200 	strb.w	r3, [r0, #512]	; 0x200
 8001c26:	bd10      	pop	{r4, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:177
    else {  // There is something to transmit more
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001c28:	60d9      	str	r1, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:178
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;
 8001c2a:	1a61      	subs	r1, r4, r1
 8001c2c:	4291      	cmp	r1, r2
 8001c2e:	bf38      	it	cc
 8001c30:	460a      	movcc	r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:179
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;
 8001c32:	f8c0 2208 	str.w	r2, [r0, #520]	; 0x208
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:180
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8001c36:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:181
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001c38:	2292      	movs	r2, #146	; 0x92
 8001c3a:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:182
        dmaStreamEnable(UART_DMA_TX);    // Restart DMA
 8001c3c:	681a      	ldr	r2, [r3, #0]
 8001c3e:	f042 0201 	orr.w	r2, r2, #1
 8001c42:	601a      	str	r2, [r3, #0]
 8001c44:	bd10      	pop	{r4, pc}
 8001c46:	bf00      	nop
 8001c48:	08002ac0 	.word	0x08002ac0
$d():
 8001c4c:	00000000 	.word	0x00000000

08001c50 <CmdUartTxIrq>:
CmdUartTxIrq():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:125
#endif

// ==== Init & DMA ====
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
 8001c50:	4801      	ldr	r0, [pc, #4]	; (8001c58 <CmdUartTxIrq+0x8>)
 8001c52:	f7ff bfc5 	b.w	8001be0 <CmdUart_t::IRQDmaTxHandler()>
 8001c56:	bf00      	nop
 8001c58:	20000bfc 	.word	0x20000bfc
$d():
 8001c5c:	00000000 	.word	0x00000000

08001c60 <PinClockEnable(GPIO_TypeDef*)>:
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001c60:	4b12      	ldr	r3, [pc, #72]	; (8001cac <PinClockEnable(GPIO_TypeDef*)+0x4c>)
 8001c62:	4298      	cmp	r0, r3
 8001c64:	d105      	bne.n	8001c72 <PinClockEnable(GPIO_TypeDef*)+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130 (discriminator 1)
 8001c66:	f503 5360 	add.w	r3, r3, #14336	; 0x3800
 8001c6a:	69da      	ldr	r2, [r3, #28]
 8001c6c:	f042 0201 	orr.w	r2, r2, #1
 8001c70:	e019      	b.n	8001ca6 <PinClockEnable(GPIO_TypeDef*)+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:131
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001c72:	4b0f      	ldr	r3, [pc, #60]	; (8001cb0 <PinClockEnable(GPIO_TypeDef*)+0x50>)
 8001c74:	4298      	cmp	r0, r3
 8001c76:	d105      	bne.n	8001c84 <PinClockEnable(GPIO_TypeDef*)+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:131 (discriminator 1)
 8001c78:	f503 5350 	add.w	r3, r3, #13312	; 0x3400
 8001c7c:	69da      	ldr	r2, [r3, #28]
 8001c7e:	f042 0202 	orr.w	r2, r2, #2
 8001c82:	e010      	b.n	8001ca6 <PinClockEnable(GPIO_TypeDef*)+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:132
    else if(PGpioPort == GPIOC) RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
 8001c84:	4b0b      	ldr	r3, [pc, #44]	; (8001cb4 <PinClockEnable(GPIO_TypeDef*)+0x54>)
 8001c86:	4298      	cmp	r0, r3
 8001c88:	d105      	bne.n	8001c96 <PinClockEnable(GPIO_TypeDef*)+0x36>
 8001c8a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8001c8e:	69da      	ldr	r2, [r3, #28]
 8001c90:	f042 0204 	orr.w	r2, r2, #4
 8001c94:	e007      	b.n	8001ca6 <PinClockEnable(GPIO_TypeDef*)+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:133
    else if(PGpioPort == GPIOD) RCC->AHBENR |= RCC_AHBENR_GPIODEN;
 8001c96:	4b08      	ldr	r3, [pc, #32]	; (8001cb8 <PinClockEnable(GPIO_TypeDef*)+0x58>)
 8001c98:	4298      	cmp	r0, r3
 8001c9a:	d105      	bne.n	8001ca8 <PinClockEnable(GPIO_TypeDef*)+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:133 (discriminator 1)
 8001c9c:	f503 5330 	add.w	r3, r3, #11264	; 0x2c00
 8001ca0:	69da      	ldr	r2, [r3, #28]
 8001ca2:	f042 0208 	orr.w	r2, r2, #8
 8001ca6:	61da      	str	r2, [r3, #28]
 8001ca8:	4770      	bx	lr
 8001caa:	bf00      	nop
 8001cac:	40020000 	.word	0x40020000
 8001cb0:	40020400 	.word	0x40020400
 8001cb4:	40020800 	.word	0x40020800
 8001cb8:	40020c00 	.word	0x40020c00
$d():
 8001cbc:	00000000 	.word	0x00000000

08001cc0 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>:
PinSetupAlterFunc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:181
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
}

static inline void PinSetupAlterFunc(
 8001cc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001cc2:	460d      	mov	r5, r1
 8001cc4:	4604      	mov	r4, r0
 8001cc6:	4616      	mov	r6, r2
 8001cc8:	461f      	mov	r7, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:189
        const PinOutMode_t PinOutMode,
        const PinPullUpDown_t APullUpDown,
        const PinAF_t AAlterFunc,
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
 8001cca:	f7ff ffc9 	bl	8001c60 <PinClockEnable(GPIO_TypeDef*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:190
    uint32_t Offset = APinNumber*2;
 8001cce:	0069      	lsls	r1, r5, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:192
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001cd0:	2003      	movs	r0, #3
 8001cd2:	4088      	lsls	r0, r1
 8001cd4:	6823      	ldr	r3, [r4, #0]
 8001cd6:	43c0      	mvns	r0, r0
 8001cd8:	4003      	ands	r3, r0
 8001cda:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001cdc:	2302      	movs	r3, #2
 8001cde:	408b      	lsls	r3, r1
 8001ce0:	6822      	ldr	r2, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001ce2:	40ae      	lsls	r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:193
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001ce4:	4313      	orrs	r3, r2
 8001ce6:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001ce8:	2301      	movs	r3, #1
 8001cea:	40ab      	lsls	r3, r5
 8001cec:	88a2      	ldrh	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:204
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
 8001cee:	2d07      	cmp	r5, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001cf0:	b292      	uxth	r2, r2
 8001cf2:	ea22 0303 	bic.w	r3, r2, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001cf6:	f89d 2018 	ldrb.w	r2, [sp, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001cfa:	80a3      	strh	r3, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001cfc:	fa02 f101 	lsl.w	r1, r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001d00:	88a3      	ldrh	r3, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:205
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
 8001d02:	bf88      	it	hi
 8001d04:	3d08      	subhi	r5, #8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001d06:	ea46 0603 	orr.w	r6, r6, r3
 8001d0a:	b2b6      	uxth	r6, r6
 8001d0c:	80a6      	strh	r6, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001d0e:	68e3      	ldr	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:205
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
 8001d10:	ea4f 0585 	mov.w	r5, r5, lsl #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:198
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001d14:	ea00 0303 	and.w	r3, r0, r3
 8001d18:	60e3      	str	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001d1a:	68e3      	ldr	r3, [r4, #12]
 8001d1c:	60e3      	str	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001d1e:	68a3      	ldr	r3, [r4, #8]
 8001d20:	ea00 0003 	and.w	r0, r0, r3
 8001d24:	60a0      	str	r0, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001d26:	68a3      	ldr	r3, [r4, #8]
 8001d28:	ea41 0103 	orr.w	r1, r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:204
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
 8001d2c:	bf94      	ite	ls
 8001d2e:	2300      	movls	r3, #0
 8001d30:	2301      	movhi	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001d32:	60a1      	str	r1, [r4, #8]
 8001d34:	eb04 0483 	add.w	r4, r4, r3, lsl #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001d38:	230f      	movs	r3, #15
 8001d3a:	40ab      	lsls	r3, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001d3c:	fa07 f505 	lsl.w	r5, r7, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:206
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001d40:	6a22      	ldr	r2, [r4, #32]
 8001d42:	ea22 0303 	bic.w	r3, r2, r3
 8001d46:	6223      	str	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001d48:	6a23      	ldr	r3, [r4, #32]
 8001d4a:	431d      	orrs	r5, r3
 8001d4c:	6225      	str	r5, [r4, #32]
 8001d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001d50 <PwmPin_t::SetFreqHz(unsigned long)>:
_ZN8PwmPin_t9SetFreqHzEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:135
    }
    *PCCR = 0;
}

void PwmPin_t::SetFreqHz(uint32_t FreqHz) {
    uint32_t divider = Tim->ARR * FreqHz;
 8001d50:	6843      	ldr	r3, [r0, #4]
 8001d52:	6ada      	ldr	r2, [r3, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:136
    if(divider == 0) return;
 8001d54:	4351      	muls	r1, r2
 8001d56:	d007      	beq.n	8001d68 <PwmPin_t::SetFreqHz(unsigned long)+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:137
    uint32_t FPrescaler = *PClk / divider;
 8001d58:	6802      	ldr	r2, [r0, #0]
 8001d5a:	6812      	ldr	r2, [r2, #0]
 8001d5c:	fbb2 f1f1 	udiv	r1, r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:138
    if(FPrescaler != 0) FPrescaler--;   // do not decrease in case of high freq
 8001d60:	b101      	cbz	r1, 8001d64 <PwmPin_t::SetFreqHz(unsigned long)+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:138 (discriminator 1)
 8001d62:	3901      	subs	r1, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:139
    Tim->PSC = (uint16_t)FPrescaler;
 8001d64:	b289      	uxth	r1, r1
 8001d66:	8519      	strh	r1, [r3, #40]	; 0x28
 8001d68:	4770      	bx	lr
 8001d6a:	0000      	movs	r0, r0
 8001d6c:	0000      	movs	r0, r0
	...

08001d70 <chDbgPanic>:
chDbgPanic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:144
}
#endif

#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
 8001d70:	3801      	subs	r0, #1
_ZN9CmdUart_t8PrintNowEPKc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.h:72
#endif
public:
    void Printf(const char *S, ...);
    void FlushTx() { while(!IDmaIsIdle); }  // wait DMA
    void PrintNow(const char *S) {
        while(*S != 0) {
 8001d72:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8001d76:	b12b      	cbz	r3, 8001d84 <chDbgPanic+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.h:73
            while(!(UART->SR & USART_SR_TXE));
 8001d78:	4a03      	ldr	r2, [pc, #12]	; (8001d88 <chDbgPanic+0x18>)
 8001d7a:	8811      	ldrh	r1, [r2, #0]
 8001d7c:	0609      	lsls	r1, r1, #24
 8001d7e:	d5fb      	bpl.n	8001d78 <chDbgPanic+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.h:74
            UART->DR = *S++;
 8001d80:	8093      	strh	r3, [r2, #4]
 8001d82:	e7f6      	b.n	8001d72 <chDbgPanic+0x2>
chDbgPanic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:146
    Uart.PrintNow(msg1);
}
 8001d84:	4770      	bx	lr
 8001d86:	bf00      	nop
 8001d88:	40013800 	.word	0x40013800
$d():
 8001d8c:	00000000 	.word	0x00000000

08001d90 <i2c_t::Standby()>:
_ZN5i2c_t7StandbyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
 8001d90:	6803      	ldr	r3, [r0, #0]
 8001d92:	4a1c      	ldr	r2, [pc, #112]	; (8001e04 <i2c_t::Standby()+0x74>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:190
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
 8001d94:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
 8001d96:	4293      	cmp	r3, r2
 8001d98:	4b1b      	ldr	r3, [pc, #108]	; (8001e08 <i2c_t::Standby()+0x78>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:190
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
 8001d9a:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
 8001d9c:	699a      	ldr	r2, [r3, #24]
 8001d9e:	d108      	bne.n	8001db2 <i2c_t::Standby()+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191 (discriminator 1)
 8001da0:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001da4:	619a      	str	r2, [r3, #24]
 8001da6:	2200      	movs	r2, #0
 8001da8:	619a      	str	r2, [r3, #24]
 8001daa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001dac:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8001db0:	e007      	b.n	8001dc2 <i2c_t::Standby()+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:192
    else             { rccResetI2C2(); rccDisableI2C2(FALSE); }
 8001db2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8001db6:	619a      	str	r2, [r3, #24]
 8001db8:	2200      	movs	r2, #0
 8001dba:	619a      	str	r2, [r3, #24]
 8001dbc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001dbe:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:194
    // Disable GPIOs
    PinSetupAnalog(IPGpio, ISclPin);
 8001dc2:	686c      	ldr	r4, [r5, #4]
 8001dc4:	892e      	ldrh	r6, [r5, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:192
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
    else             { rccResetI2C2(); rccDisableI2C2(FALSE); }
 8001dc6:	625a      	str	r2, [r3, #36]	; 0x24
PinSetupAnalog():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:174
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
 8001dc8:	4620      	mov	r0, r4
 8001dca:	f7ff ff49 	bl	8001c60 <PinClockEnable(GPIO_TypeDef*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:176
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 8001dce:	0073      	lsls	r3, r6, #1
 8001dd0:	2603      	movs	r6, #3
 8001dd2:	fa06 f303 	lsl.w	r3, r6, r3
 8001dd6:	6822      	ldr	r2, [r4, #0]
 8001dd8:	431a      	orrs	r2, r3
 8001dda:	6022      	str	r2, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:178
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001ddc:	68e2      	ldr	r2, [r4, #12]
 8001dde:	ea22 0303 	bic.w	r3, r2, r3
 8001de2:	60e3      	str	r3, [r4, #12]
_ZN5i2c_t7StandbyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:195
    // Disable GPIOs
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
 8001de4:	686c      	ldr	r4, [r5, #4]
 8001de6:	896d      	ldrh	r5, [r5, #10]
PinSetupAnalog():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:174
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
 8001de8:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:176
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 8001dea:	006d      	lsls	r5, r5, #1
 8001dec:	40ae      	lsls	r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:174
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
 8001dee:	f7ff ff37 	bl	8001c60 <PinClockEnable(GPIO_TypeDef*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:176
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 8001df2:	6823      	ldr	r3, [r4, #0]
 8001df4:	4333      	orrs	r3, r6
 8001df6:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:178
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8001df8:	68e3      	ldr	r3, [r4, #12]
 8001dfa:	ea23 0606 	bic.w	r6, r3, r6
 8001dfe:	60e6      	str	r6, [r4, #12]
 8001e00:	bd70      	pop	{r4, r5, r6, pc}
 8001e02:	bf00      	nop
 8001e04:	40005400 	.word	0x40005400
 8001e08:	40023800 	.word	0x40023800
$d():
 8001e0c:	00000000 	.word	0x00000000

08001e10 <i2c_t::Resume()>:
_ZN5i2c_t6ResumeEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:198
}

void i2c_t::Resume() {
 8001e10:	b573      	push	{r0, r1, r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    Error = false;
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 8001e12:	2602      	movs	r6, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:199
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
}

void i2c_t::Resume() {
    Error = false;
 8001e14:	2500      	movs	r5, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 8001e16:	8901      	ldrh	r1, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:199
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
}

void i2c_t::Resume() {
    Error = false;
 8001e18:	7405      	strb	r5, [r0, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 8001e1a:	9600      	str	r6, [sp, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:198
    // Disable GPIOs
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
}

void i2c_t::Resume() {
 8001e1c:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    Error = false;
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 8001e1e:	2201      	movs	r2, #1
 8001e20:	6840      	ldr	r0, [r0, #4]
 8001e22:	2304      	movs	r3, #4
 8001e24:	f7ff ff4c 	bl	8001cc0 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:202
    PinSetupAlterFunc(IPGpio, ISdaPin, omOpenDrain, pudNone, AF4);
 8001e28:	8961      	ldrh	r1, [r4, #10]
 8001e2a:	2201      	movs	r2, #1
 8001e2c:	2304      	movs	r3, #4
 8001e2e:	9600      	str	r6, [sp, #0]
 8001e30:	6860      	ldr	r0, [r4, #4]
 8001e32:	f7ff ff45 	bl	8001cc0 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:204
    // ==== Clock and reset ====
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
 8001e36:	4a29      	ldr	r2, [pc, #164]	; (8001edc <i2c_t::Resume()+0xcc>)
 8001e38:	6823      	ldr	r3, [r4, #0]
 8001e3a:	4293      	cmp	r3, r2
 8001e3c:	f502 32f2 	add.w	r2, r2, #123904	; 0x1e400
 8001e40:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8001e42:	d106      	bne.n	8001e52 <i2c_t::Resume()+0x42>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:204 (discriminator 1)
 8001e44:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8001e48:	6251      	str	r1, [r2, #36]	; 0x24
 8001e4a:	6991      	ldr	r1, [r2, #24]
 8001e4c:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8001e50:	e005      	b.n	8001e5e <i2c_t::Resume()+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:205
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
 8001e52:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 8001e56:	6251      	str	r1, [r2, #36]	; 0x24
 8001e58:	6991      	ldr	r1, [r2, #24]
 8001e5a:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 8001e5e:	6191      	str	r1, [r2, #24]
 8001e60:	6195      	str	r5, [r2, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:207
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
 8001e62:	4a1f      	ldr	r2, [pc, #124]	; (8001ee0 <i2c_t::Resume()+0xd0>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:208
    uint16_t tmpreg = ii2c->CR2;
 8001e64:	8899      	ldrh	r1, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:207
    PinSetupAlterFunc(IPGpio, ISdaPin, omOpenDrain, pudNone, AF4);
    // ==== Clock and reset ====
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
 8001e66:	6850      	ldr	r0, [r2, #4]
 8001e68:	4a1e      	ldr	r2, [pc, #120]	; (8001ee4 <i2c_t::Resume()+0xd4>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:209
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
 8001e6a:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:207
    PinSetupAlterFunc(IPGpio, ISdaPin, omOpenDrain, pudNone, AF4);
    // ==== Clock and reset ====
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
 8001e6e:	fbb0 f2f2 	udiv	r2, r0, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:209
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
 8001e72:	0409      	lsls	r1, r1, #16
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:210
    if(ClkMhz < 2)  ClkMhz = 2;
 8001e74:	2a01      	cmp	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:209
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
 8001e76:	ea4f 4111 	mov.w	r1, r1, lsr #16
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:210
    if(ClkMhz < 2)  ClkMhz = 2;
 8001e7a:	d903      	bls.n	8001e84 <i2c_t::Resume()+0x74>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:211
    if(ClkMhz > 32) ClkMhz = 32;
 8001e7c:	2a21      	cmp	r2, #33	; 0x21
 8001e7e:	bf28      	it	cs
 8001e80:	2220      	movcs	r2, #32
 8001e82:	e000      	b.n	8001e86 <i2c_t::Resume()+0x76>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:210
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
    if(ClkMhz < 2)  ClkMhz = 2;
 8001e84:	2202      	movs	r2, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:212
    if(ClkMhz > 32) ClkMhz = 32;
    tmpreg |= ClkMhz;
 8001e86:	4311      	orrs	r1, r2
 8001e88:	b289      	uxth	r1, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:213
    ii2c->CR2 = tmpreg;
 8001e8a:	8099      	strh	r1, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:214
    ii2c->CR1 &= (uint16_t)~I2C_CR1_PE; // Disable i2c to setup TRise & CCR
 8001e8c:	8819      	ldrh	r1, [r3, #0]
 8001e8e:	f021 0101 	bic.w	r1, r1, #1
 8001e92:	0409      	lsls	r1, r1, #16
 8001e94:	0c09      	lsrs	r1, r1, #16
 8001e96:	8019      	strh	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:215
    ii2c->TRISE = (uint16_t)(((ClkMhz * 300) / 1000) + 1);
 8001e98:	f44f 7196 	mov.w	r1, #300	; 0x12c
 8001e9c:	434a      	muls	r2, r1
 8001e9e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001ea2:	fbb2 f2f1 	udiv	r2, r2, r1
 8001ea6:	3201      	adds	r2, #1
 8001ea8:	b292      	uxth	r2, r2
 8001eaa:	841a      	strh	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:217
    // 16/9
    tmpreg = (uint16_t)(Clk.APB1FreqHz / (IBitrateHz * 25));
 8001eac:	68e2      	ldr	r2, [r4, #12]
 8001eae:	2119      	movs	r1, #25
 8001eb0:	434a      	muls	r2, r1
 8001eb2:	fbb0 f2f2 	udiv	r2, r0, r2
 8001eb6:	b292      	uxth	r2, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:218
    if(tmpreg == 0) tmpreg = 1; // minimum allowed value
 8001eb8:	2a00      	cmp	r2, #0
 8001eba:	bf08      	it	eq
 8001ebc:	2201      	moveq	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:219
    tmpreg |= I2C_CCR_FS | I2C_CCR_DUTY;
 8001ebe:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:220
    ii2c->CCR = tmpreg;
 8001ec2:	839a      	strh	r2, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:221
    ii2c->CR1 |= I2C_CR1_PE;    // Enable i2c back
 8001ec4:	881a      	ldrh	r2, [r3, #0]
 8001ec6:	b292      	uxth	r2, r2
 8001ec8:	f042 0201 	orr.w	r2, r2, #1
 8001ecc:	801a      	strh	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:223
    // ==== DMA ====
    ii2c->CR2 |= I2C_CR2_DMAEN;
 8001ece:	889a      	ldrh	r2, [r3, #4]
 8001ed0:	b292      	uxth	r2, r2
 8001ed2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001ed6:	809a      	strh	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:224
}
 8001ed8:	b002      	add	sp, #8
 8001eda:	bd70      	pop	{r4, r5, r6, pc}
 8001edc:	40005400 	.word	0x40005400
 8001ee0:	20000bf0 	.word	0x20000bf0
 8001ee4:	000f4240 	.word	0x000f4240
	...

08001ef0 <i2c_t::IBusyWait()>:
_ZN5i2c_t9IBusyWaitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:332
    return OK;
}

// ==== Flag operations ====
// Busy flag
uint8_t i2c_t::IBusyWait() {
 8001ef0:	b538      	push	{r3, r4, r5, lr}
 8001ef2:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:334
    uint8_t RetryCnt = 4;
    while(RetryCnt--) {
 8001ef4:	2505      	movs	r5, #5
 8001ef6:	3d01      	subs	r5, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:334 (discriminator 1)
 8001ef8:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 8001efc:	d009      	beq.n	8001f12 <i2c_t::IBusyWait()+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:335
        if(!(ii2c->SR2 & I2C_SR2_BUSY)) return OK;
 8001efe:	6823      	ldr	r3, [r4, #0]
 8001f00:	8b18      	ldrh	r0, [r3, #24]
 8001f02:	f000 0002 	and.w	r0, r0, #2
 8001f06:	b280      	uxth	r0, r0
 8001f08:	b130      	cbz	r0, 8001f18 <i2c_t::IBusyWait()+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:336
        chThdSleepMilliseconds(1);
 8001f0a:	2001      	movs	r0, #1
 8001f0c:	f7ff fac8 	bl	80014a0 <chThdSleep>
 8001f10:	e7f1      	b.n	8001ef6 <i2c_t::IBusyWait()+0x6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:338
    }
    Error = true;
 8001f12:	2301      	movs	r3, #1
 8001f14:	7423      	strb	r3, [r4, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:339
    return TIMEOUT;
 8001f16:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:340
}
 8001f18:	bd38      	pop	{r3, r4, r5, pc}
 8001f1a:	0000      	movs	r0, r0
 8001f1c:	0000      	movs	r0, r0
	...

08001f20 <i2c_t::WaitEv5()>:
_ZN5i2c_t7WaitEv5Ev():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:345

// BUSY, MSL & SB flags
uint8_t i2c_t::WaitEv5() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--) {
 8001f20:	f240 13c3 	movw	r3, #451	; 0x1c3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:345 (discriminator 1)
 8001f24:	3b01      	subs	r3, #1
 8001f26:	d009      	beq.n	8001f3c <i2c_t::WaitEv5()+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:346
        uint16_t Flag1 = ii2c->SR1;
 8001f28:	6802      	ldr	r2, [r0, #0]
 8001f2a:	8a91      	ldrh	r1, [r2, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:347
        uint16_t Flag2 = ii2c->SR2;
 8001f2c:	8b12      	ldrh	r2, [r2, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348
        if((Flag1 & I2C_SR1_SB) and (Flag2 & (I2C_SR2_MSL | I2C_SR2_BUSY))) return OK;
 8001f2e:	07c9      	lsls	r1, r1, #31
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:347
// BUSY, MSL & SB flags
uint8_t i2c_t::WaitEv5() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--) {
        uint16_t Flag1 = ii2c->SR1;
        uint16_t Flag2 = ii2c->SR2;
 8001f30:	b292      	uxth	r2, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348
        if((Flag1 & I2C_SR1_SB) and (Flag2 & (I2C_SR2_MSL | I2C_SR2_BUSY))) return OK;
 8001f32:	d5f7      	bpl.n	8001f24 <i2c_t::WaitEv5()+0x4>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348 (discriminator 1)
 8001f34:	0792      	lsls	r2, r2, #30
 8001f36:	d0f5      	beq.n	8001f24 <i2c_t::WaitEv5()+0x4>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348
 8001f38:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:352
    }
    Error = true;
    return FAILURE;
}
 8001f3a:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:350
    while(RetryCnt--) {
        uint16_t Flag1 = ii2c->SR1;
        uint16_t Flag2 = ii2c->SR2;
        if((Flag1 & I2C_SR1_SB) and (Flag2 & (I2C_SR2_MSL | I2C_SR2_BUSY))) return OK;
    }
    Error = true;
 8001f3c:	2301      	movs	r3, #1
 8001f3e:	7403      	strb	r3, [r0, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:351
    return FAILURE;
 8001f40:	4618      	mov	r0, r3
 8001f42:	4770      	bx	lr
	...

08001f50 <i2c_t::WaitEv6()>:
_ZN5i2c_t7WaitEv6Ev():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:358

uint8_t i2c_t::WaitEv6() {
    uint32_t RetryCnt = 45;
    uint16_t Flag1;
    do {
        Flag1 = ii2c->SR1;
 8001f50:	6801      	ldr	r1, [r0, #0]
 8001f52:	232e      	movs	r3, #46	; 0x2e
 8001f54:	8a8a      	ldrh	r2, [r1, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359
        if((RetryCnt-- == 0) or (Flag1 & I2C_SR1_AF)) return FAILURE;   // Fail if timeout or NACK
 8001f56:	3b01      	subs	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:358

uint8_t i2c_t::WaitEv6() {
    uint32_t RetryCnt = 45;
    uint16_t Flag1;
    do {
        Flag1 = ii2c->SR1;
 8001f58:	b292      	uxth	r2, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359
        if((RetryCnt-- == 0) or (Flag1 & I2C_SR1_AF)) return FAILURE;   // Fail if timeout or NACK
 8001f5a:	d003      	beq.n	8001f64 <i2c_t::WaitEv6()+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359 (discriminator 2)
 8001f5c:	f402 6080 	and.w	r0, r2, #1024	; 0x400
 8001f60:	b280      	uxth	r0, r0
 8001f62:	b108      	cbz	r0, 8001f68 <i2c_t::WaitEv6()+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359
 8001f64:	2001      	movs	r0, #1
 8001f66:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:357
}

uint8_t i2c_t::WaitEv6() {
    uint32_t RetryCnt = 45;
    uint16_t Flag1;
    do {
 8001f68:	0792      	lsls	r2, r2, #30
 8001f6a:	d5f3      	bpl.n	8001f54 <i2c_t::WaitEv6()+0x4>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:362
        Flag1 = ii2c->SR1;
        if((RetryCnt-- == 0) or (Flag1 & I2C_SR1_AF)) return FAILURE;   // Fail if timeout or NACK
    } while(!(Flag1 & I2C_SR1_ADDR)); // ADDR set when Address is sent and ACK received
    return OK;
}
 8001f6c:	4770      	bx	lr
	...

08001f70 <i2c_t::WaitEv8()>:
_ZN5i2c_t7WaitEv8Ev():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:366

uint8_t i2c_t::WaitEv8() {
    uint32_t RetryCnt = 45;
    while(RetryCnt--)
 8001f70:	232e      	movs	r3, #46	; 0x2e
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:366 (discriminator 1)
 8001f72:	3b01      	subs	r3, #1
 8001f74:	d005      	beq.n	8001f82 <i2c_t::WaitEv8()+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:367
        if(ii2c->SR1 & I2C_SR1_TXE) return OK;
 8001f76:	6802      	ldr	r2, [r0, #0]
 8001f78:	8a92      	ldrh	r2, [r2, #20]
 8001f7a:	0612      	lsls	r2, r2, #24
 8001f7c:	d5f9      	bpl.n	8001f72 <i2c_t::WaitEv8()+0x2>
 8001f7e:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:370
    Error = true;
    return TIMEOUT;
}
 8001f80:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:368

uint8_t i2c_t::WaitEv8() {
    uint32_t RetryCnt = 45;
    while(RetryCnt--)
        if(ii2c->SR1 & I2C_SR1_TXE) return OK;
    Error = true;
 8001f82:	2301      	movs	r3, #1
 8001f84:	7403      	strb	r3, [r0, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:369
    return TIMEOUT;
 8001f86:	2002      	movs	r0, #2
 8001f88:	4770      	bx	lr
 8001f8a:	0000      	movs	r0, r0
 8001f8c:	0000      	movs	r0, r0
	...

08001f90 <i2c_t::WaitBTF()>:
_ZN5i2c_t7WaitBTFEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:388
    return TIMEOUT;
}

uint8_t i2c_t::WaitBTF() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--)
 8001f90:	f240 13c3 	movw	r3, #451	; 0x1c3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:388 (discriminator 1)
 8001f94:	3b01      	subs	r3, #1
 8001f96:	d005      	beq.n	8001fa4 <i2c_t::WaitBTF()+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:389
        if(ii2c->SR1 & I2C_SR1_BTF) return OK;
 8001f98:	6802      	ldr	r2, [r0, #0]
 8001f9a:	8a92      	ldrh	r2, [r2, #20]
 8001f9c:	0752      	lsls	r2, r2, #29
 8001f9e:	d5f9      	bpl.n	8001f94 <i2c_t::WaitBTF()+0x4>
 8001fa0:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:391
    return TIMEOUT;
}
 8001fa2:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:390

uint8_t i2c_t::WaitBTF() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--)
        if(ii2c->SR1 & I2C_SR1_BTF) return OK;
    return TIMEOUT;
 8001fa4:	2002      	movs	r0, #2
 8001fa6:	4770      	bx	lr
	...

08001fb0 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>:
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8001fb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001fb4:	4604      	mov	r4, r0
 8001fb6:	460f      	mov	r7, r1
 8001fb8:	4691      	mov	r9, r2
 8001fba:	4698      	mov	r8, r3
 8001fbc:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:234
    if(IBusyWait() != OK) return FAILURE;
 8001fc0:	f7ff ff96 	bl	8001ef0 <i2c_t::IBusyWait()>
 8001fc4:	2800      	cmp	r0, #0
 8001fc6:	d174      	bne.n	80020b2 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:236
    // Clear flags
    ii2c->SR1 = 0;
 8001fc8:	6825      	ldr	r5, [r4, #0]
 8001fca:	82a8      	strh	r0, [r5, #20]
_ZN5i2c_t12RxIsNotEmptyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:459 (discriminator 1)
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
 8001fcc:	8aab      	ldrh	r3, [r5, #20]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:237 (discriminator 1)
    while(RxIsNotEmpty()) (void)ii2c->DR;   // Read DR until it empty
 8001fce:	065b      	lsls	r3, r3, #25
 8001fd0:	d501      	bpl.n	8001fd6 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x26>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:237 (discriminator 2)
 8001fd2:	8a2b      	ldrh	r3, [r5, #16]
 8001fd4:	e7fa      	b.n	8001fcc <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x1c>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 8001fd6:	8aab      	ldrh	r3, [r5, #20]
 8001fd8:	8b2b      	ldrh	r3, [r5, #24]
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
private:
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
 8001fda:	882b      	ldrh	r3, [r5, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:241
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
 8001fdc:	4620      	mov	r0, r4
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
 8001fde:	b29b      	uxth	r3, r3
 8001fe0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001fe4:	802b      	strh	r3, [r5, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:241
 8001fe6:	f7ff ff9b 	bl	8001f20 <i2c_t::WaitEv5()>
 8001fea:	2800      	cmp	r0, #0
 8001fec:	d161      	bne.n	80020b2 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8001fee:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t17SendAddrWithWriteEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:463
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
    // Address and data
    void SendAddrWithWrite(uint8_t Addr) { ii2c->DR = (uint8_t)(Addr<<1); }
 8001ff0:	007f      	lsls	r7, r7, #1
 8001ff2:	b2ff      	uxtb	r7, r7
 8001ff4:	821f      	strh	r7, [r3, #16]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:243
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
    SendAddrWithWrite(Addr);
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
 8001ff6:	4620      	mov	r0, r4
 8001ff8:	f7ff ffaa 	bl	8001f50 <i2c_t::WaitEv6()>
 8001ffc:	4605      	mov	r5, r0
 8001ffe:	6820      	ldr	r0, [r4, #0]
 8002000:	b12d      	cbz	r5, 800200e <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456 (discriminator 1)
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 8002002:	8803      	ldrh	r3, [r0, #0]
 8002004:	b29b      	uxth	r3, r3
 8002006:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800200a:	8003      	strh	r3, [r0, #0]
 800200c:	e051      	b.n	80020b2 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 800200e:	8a83      	ldrh	r3, [r0, #20]
 8002010:	8b03      	ldrh	r3, [r0, #24]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:246
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength != 0) {
 8002012:	f1b8 0f00 	cmp.w	r8, #0
 8002016:	d02e      	beq.n	8002076 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0xc6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:247
        if(WaitEv8() != OK) return FAILURE;
 8002018:	4620      	mov	r0, r4
 800201a:	f7ff ffa9 	bl	8001f70 <i2c_t::WaitEv8()>
 800201e:	2800      	cmp	r0, #0
 8002020:	d147      	bne.n	80020b2 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:248
        dmaStreamSetMemory0(PDmaTx, WPtr);
 8002022:	69a3      	ldr	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:249
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 8002024:	2292      	movs	r2, #146	; 0x92
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:248
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength != 0) {
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr);
 8002026:	681b      	ldr	r3, [r3, #0]
 8002028:	f8c3 900c 	str.w	r9, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:249
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 800202c:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:250
        dmaStreamSetTransactionSize(PDmaTx, WLength);
 800202e:	f8c3 8004 	str.w	r8, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:251
        chSysLock();
 8002032:	2320      	movs	r3, #32
 8002034:	f383 8811 	msr	BASEPRI, r3
 8002038:	f7fe fe3a 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:252
        PRequestingThread = chThdSelf();
 800203c:	4b41      	ldr	r3, [pc, #260]	; (8002144 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x194>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:254
        dmaStreamEnable(PDmaTx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 800203e:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:252
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr);
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
        dmaStreamSetTransactionSize(PDmaTx, WLength);
        chSysLock();
        PRequestingThread = chThdSelf();
 8002040:	699b      	ldr	r3, [r3, #24]
 8002042:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:253
        dmaStreamEnable(PDmaTx);
 8002044:	69a3      	ldr	r3, [r4, #24]
 8002046:	681b      	ldr	r3, [r3, #0]
 8002048:	681a      	ldr	r2, [r3, #0]
 800204a:	f042 0201 	orr.w	r2, r2, #1
 800204e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:254
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 8002050:	f7fe ffce 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:255
        chSysUnlock();
 8002054:	f7fe fe44 	bl	8000ce0 <dbg_check_unlock>
 8002058:	2300      	movs	r3, #0
 800205a:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:256
        dmaStreamDisable(PDmaTx);
 800205e:	69a3      	ldr	r3, [r4, #24]
 8002060:	681a      	ldr	r2, [r3, #0]
 8002062:	6811      	ldr	r1, [r2, #0]
 8002064:	f021 010f 	bic.w	r1, r1, #15
 8002068:	6011      	str	r1, [r2, #0]
 800206a:	685a      	ldr	r2, [r3, #4]
 800206c:	7a1b      	ldrb	r3, [r3, #8]
 800206e:	210f      	movs	r1, #15
 8002070:	fa01 f303 	lsl.w	r3, r1, r3
 8002074:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:260
    }
    // Read if needed
    if(RLength != 0) {
        if(WaitEv8() != OK) return FAILURE;
 8002076:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:259
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
        chSysUnlock();
        dmaStreamDisable(PDmaTx);
    }
    // Read if needed
    if(RLength != 0) {
 8002078:	2e00      	cmp	r6, #0
 800207a:	d058      	beq.n	800212e <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x17e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:260
        if(WaitEv8() != OK) return FAILURE;
 800207c:	f7ff ff78 	bl	8001f70 <i2c_t::WaitEv8()>
 8002080:	b9b8      	cbnz	r0, 80020b2 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8002082:	6823      	ldr	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:263
    // Read if needed
    if(RLength != 0) {
        if(WaitEv8() != OK) return FAILURE;
        // Send repeated start
        SendStart();
        if(WaitEv5() != OK) return FAILURE;
 8002084:	4620      	mov	r0, r4
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
private:
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
 8002086:	881a      	ldrh	r2, [r3, #0]
 8002088:	b292      	uxth	r2, r2
 800208a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800208e:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:263
 8002090:	f7ff ff46 	bl	8001f20 <i2c_t::WaitEv5()>
 8002094:	b968      	cbnz	r0, 80020b2 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8002096:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t16SendAddrWithReadEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:464
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
    // Address and data
    void SendAddrWithWrite(uint8_t Addr) { ii2c->DR = (uint8_t)(Addr<<1); }
    void SendAddrWithRead (uint8_t Addr) { ii2c->DR = ((uint8_t)(Addr<<1)) | 0x01; }
 8002098:	f047 0701 	orr.w	r7, r7, #1
 800209c:	821f      	strh	r7, [r3, #16]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:265
        if(WaitEv8() != OK) return FAILURE;
        // Send repeated start
        SendStart();
        if(WaitEv5() != OK) return FAILURE;
        SendAddrWithRead(Addr);
        if(WaitEv6() != OK) { SendStop(); return FAILURE; }
 800209e:	4620      	mov	r0, r4
 80020a0:	f7ff ff56 	bl	8001f50 <i2c_t::WaitEv6()>
 80020a4:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 80020a6:	881a      	ldrh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:265
 80020a8:	b128      	cbz	r0, 80020b6 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x106>
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456 (discriminator 1)
 80020aa:	b292      	uxth	r2, r2
 80020ac:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80020b0:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:265 (discriminator 1)
 80020b2:	2501      	movs	r5, #1
 80020b4:	e043      	b.n	800213e <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x18e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:267
        // If single byte is to be received, disable ACK before clearing ADDR flag
        if(RLength == 1) AckDisable();
 80020b6:	2e01      	cmp	r6, #1
 80020b8:	d104      	bne.n	80020c4 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x114>
_ZN5i2c_t10AckDisableEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:458 (discriminator 1)
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
 80020ba:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80020be:	0412      	lsls	r2, r2, #16
 80020c0:	0c12      	lsrs	r2, r2, #16
 80020c2:	e002      	b.n	80020ca <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x11a>
_ZN5i2c_t9AckEnableEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:457
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
 80020c4:	b292      	uxth	r2, r2
 80020c6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80020ca:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 80020cc:	8a9a      	ldrh	r2, [r3, #20]
 80020ce:	8b1a      	ldrh	r2, [r3, #24]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:270
        else AckEnable();
        ClearAddrFlag();
        dmaStreamSetMemory0(PDmaRx, RPtr);
 80020d0:	69e2      	ldr	r2, [r4, #28]
 80020d2:	9908      	ldr	r1, [sp, #32]
 80020d4:	6812      	ldr	r2, [r2, #0]
 80020d6:	60d1      	str	r1, [r2, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:271
        dmaStreamSetMode   (PDmaRx, I2C_DMARX_MODE);
 80020d8:	2182      	movs	r1, #130	; 0x82
 80020da:	6011      	str	r1, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:272
        dmaStreamSetTransactionSize(PDmaRx, RLength);
 80020dc:	6056      	str	r6, [r2, #4]
_ZN5i2c_t18DmaLastTransferSetEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:461
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
 80020de:	889a      	ldrh	r2, [r3, #4]
 80020e0:	b292      	uxth	r2, r2
 80020e2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80020e6:	809a      	strh	r2, [r3, #4]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:274
        DmaLastTransferSet(); // Inform DMA that this is last transfer => do not ACK last byte
        chSysLock();
 80020e8:	2320      	movs	r3, #32
 80020ea:	f383 8811 	msr	BASEPRI, r3
 80020ee:	f7fe fddf 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:275
        PRequestingThread = chThdSelf();
 80020f2:	4b14      	ldr	r3, [pc, #80]	; (8002144 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x194>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:277
        dmaStreamEnable(PDmaRx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 80020f4:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:275
        dmaStreamSetMemory0(PDmaRx, RPtr);
        dmaStreamSetMode   (PDmaRx, I2C_DMARX_MODE);
        dmaStreamSetTransactionSize(PDmaRx, RLength);
        DmaLastTransferSet(); // Inform DMA that this is last transfer => do not ACK last byte
        chSysLock();
        PRequestingThread = chThdSelf();
 80020f6:	699b      	ldr	r3, [r3, #24]
 80020f8:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:276
        dmaStreamEnable(PDmaRx);
 80020fa:	69e3      	ldr	r3, [r4, #28]
 80020fc:	681b      	ldr	r3, [r3, #0]
 80020fe:	681a      	ldr	r2, [r3, #0]
 8002100:	f042 0201 	orr.w	r2, r2, #1
 8002104:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:277
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 8002106:	f7fe ff73 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:278
        chSysUnlock();
 800210a:	f7fe fde9 	bl	8000ce0 <dbg_check_unlock>
 800210e:	2300      	movs	r3, #0
 8002110:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:279
        dmaStreamDisable(PDmaRx);
 8002114:	69e3      	ldr	r3, [r4, #28]
 8002116:	681a      	ldr	r2, [r3, #0]
 8002118:	6811      	ldr	r1, [r2, #0]
 800211a:	f021 010f 	bic.w	r1, r1, #15
 800211e:	6011      	str	r1, [r2, #0]
 8002120:	685a      	ldr	r2, [r3, #4]
 8002122:	7a1b      	ldrb	r3, [r3, #8]
 8002124:	210f      	movs	r1, #15
 8002126:	fa01 f303 	lsl.w	r3, r1, r3
 800212a:	6013      	str	r3, [r2, #0]
 800212c:	e001      	b.n	8002132 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x182>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:281
    } // if != 0
    else WaitBTF(); // if nothing to read, just stop
 800212e:	f7ff ff2f 	bl	8001f90 <i2c_t::WaitBTF()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8002132:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 8002134:	881a      	ldrh	r2, [r3, #0]
 8002136:	b292      	uxth	r2, r2
 8002138:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800213c:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:284
        dmaStreamDisable(PDmaRx);
    } // if != 0
    else WaitBTF(); // if nothing to read, just stop
    SendStop();
    return OK;
}
 800213e:	4628      	mov	r0, r5
 8002140:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002144:	2000126c 	.word	0x2000126c
	...

08002150 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>:
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:288

uint8_t i2c_t::CmdWriteWrite(uint8_t Addr,
        uint8_t *WPtr1, uint8_t WLength1,
        uint8_t *WPtr2, uint8_t WLength2) {
 8002150:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002154:	4604      	mov	r4, r0
 8002156:	4689      	mov	r9, r1
 8002158:	4690      	mov	r8, r2
 800215a:	461f      	mov	r7, r3
 800215c:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:289
    if(IBusyWait() != OK) return FAILURE;
 8002160:	f7ff fec6 	bl	8001ef0 <i2c_t::IBusyWait()>
 8002164:	bb18      	cbnz	r0, 80021ae <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:291
    // Clear flags
    ii2c->SR1 = 0;
 8002166:	6825      	ldr	r5, [r4, #0]
 8002168:	82a8      	strh	r0, [r5, #20]
_ZN5i2c_t12RxIsNotEmptyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:459 (discriminator 1)
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
 800216a:	8aab      	ldrh	r3, [r5, #20]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:292 (discriminator 1)
    while(RxIsNotEmpty()) (void)ii2c->DR;   // Read DR until it empty
 800216c:	065b      	lsls	r3, r3, #25
 800216e:	d501      	bpl.n	8002174 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:292 (discriminator 2)
 8002170:	8a2b      	ldrh	r3, [r5, #16]
 8002172:	e7fa      	b.n	800216a <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x1a>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 8002174:	8aab      	ldrh	r3, [r5, #20]
 8002176:	8b2b      	ldrh	r3, [r5, #24]
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
private:
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
 8002178:	882b      	ldrh	r3, [r5, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:296
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
 800217a:	4620      	mov	r0, r4
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
 800217c:	b29b      	uxth	r3, r3
 800217e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002182:	802b      	strh	r3, [r5, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:296
 8002184:	f7ff fecc 	bl	8001f20 <i2c_t::WaitEv5()>
 8002188:	b988      	cbnz	r0, 80021ae <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:288
    return OK;
}

uint8_t i2c_t::CmdWriteWrite(uint8_t Addr,
        uint8_t *WPtr1, uint8_t WLength1,
        uint8_t *WPtr2, uint8_t WLength2) {
 800218a:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t17SendAddrWithWriteEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:463
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
    // Address and data
    void SendAddrWithWrite(uint8_t Addr) { ii2c->DR = (uint8_t)(Addr<<1); }
 800218c:	ea4f 0949 	mov.w	r9, r9, lsl #1
 8002190:	f009 09fe 	and.w	r9, r9, #254	; 0xfe
 8002194:	f8a3 9010 	strh.w	r9, [r3, #16]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:298
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
    SendAddrWithWrite(Addr);
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
 8002198:	4620      	mov	r0, r4
 800219a:	f7ff fed9 	bl	8001f50 <i2c_t::WaitEv6()>
 800219e:	6821      	ldr	r1, [r4, #0]
 80021a0:	4605      	mov	r5, r0
 80021a2:	b130      	cbz	r0, 80021b2 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x62>
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456 (discriminator 1)
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 80021a4:	880b      	ldrh	r3, [r1, #0]
 80021a6:	b29b      	uxth	r3, r3
 80021a8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80021ac:	800b      	strh	r3, [r1, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:298 (discriminator 1)
 80021ae:	2501      	movs	r5, #1
 80021b0:	e06a      	b.n	8002288 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x138>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 80021b2:	8a8b      	ldrh	r3, [r1, #20]
 80021b4:	8b0b      	ldrh	r3, [r1, #24]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:301
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength1 != 0) {
 80021b6:	2f00      	cmp	r7, #0
 80021b8:	d02d      	beq.n	8002216 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0xc6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:302
        if(WaitEv8() != OK) return FAILURE;
 80021ba:	4620      	mov	r0, r4
 80021bc:	f7ff fed8 	bl	8001f70 <i2c_t::WaitEv8()>
 80021c0:	2800      	cmp	r0, #0
 80021c2:	d1f4      	bne.n	80021ae <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:303
        dmaStreamSetMemory0(PDmaTx, WPtr1);
 80021c4:	69a3      	ldr	r3, [r4, #24]
 80021c6:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:304
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 80021c8:	2392      	movs	r3, #146	; 0x92
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:303
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength1 != 0) {
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr1);
 80021ca:	f8c1 800c 	str.w	r8, [r1, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:304
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 80021ce:	600b      	str	r3, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:305
        dmaStreamSetTransactionSize(PDmaTx, WLength1);
 80021d0:	604f      	str	r7, [r1, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:306
        chSysLock();
 80021d2:	2320      	movs	r3, #32
 80021d4:	f383 8811 	msr	BASEPRI, r3
 80021d8:	f7fe fd6a 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:307
        PRequestingThread = chThdSelf();
 80021dc:	4b2c      	ldr	r3, [pc, #176]	; (8002290 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x140>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:309
        dmaStreamEnable(PDmaTx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 80021de:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:307
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr1);
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
        dmaStreamSetTransactionSize(PDmaTx, WLength1);
        chSysLock();
        PRequestingThread = chThdSelf();
 80021e0:	699b      	ldr	r3, [r3, #24]
 80021e2:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:308
        dmaStreamEnable(PDmaTx);
 80021e4:	69a3      	ldr	r3, [r4, #24]
 80021e6:	681b      	ldr	r3, [r3, #0]
 80021e8:	681a      	ldr	r2, [r3, #0]
 80021ea:	f042 0201 	orr.w	r2, r2, #1
 80021ee:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:309
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 80021f0:	f7fe fefe 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:310
        chSysUnlock();
 80021f4:	f7fe fd74 	bl	8000ce0 <dbg_check_unlock>
 80021f8:	2300      	movs	r3, #0
 80021fa:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:311
        dmaStreamDisable(PDmaTx);
 80021fe:	69a3      	ldr	r3, [r4, #24]
 8002200:	681a      	ldr	r2, [r3, #0]
 8002202:	6811      	ldr	r1, [r2, #0]
 8002204:	f021 010f 	bic.w	r1, r1, #15
 8002208:	6011      	str	r1, [r2, #0]
 800220a:	685a      	ldr	r2, [r3, #4]
 800220c:	7a1b      	ldrb	r3, [r3, #8]
 800220e:	210f      	movs	r1, #15
 8002210:	fa01 f303 	lsl.w	r3, r1, r3
 8002214:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:313
    }
    if(WLength2 != 0) {
 8002216:	2e00      	cmp	r6, #0
 8002218:	d02d      	beq.n	8002276 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x126>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:314
        if(WaitEv8() != OK) return FAILURE;
 800221a:	4620      	mov	r0, r4
 800221c:	f7ff fea8 	bl	8001f70 <i2c_t::WaitEv8()>
 8002220:	2800      	cmp	r0, #0
 8002222:	d1c4      	bne.n	80021ae <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:315
        dmaStreamSetMemory0(PDmaTx, WPtr2);
 8002224:	69a3      	ldr	r3, [r4, #24]
 8002226:	9a08      	ldr	r2, [sp, #32]
 8002228:	681b      	ldr	r3, [r3, #0]
 800222a:	60da      	str	r2, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:316
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 800222c:	2292      	movs	r2, #146	; 0x92
 800222e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:317
        dmaStreamSetTransactionSize(PDmaTx, WLength2);
 8002230:	605e      	str	r6, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:318
        chSysLock();
 8002232:	2320      	movs	r3, #32
 8002234:	f383 8811 	msr	BASEPRI, r3
 8002238:	f7fe fd3a 	bl	8000cb0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:319
        PRequestingThread = chThdSelf();
 800223c:	4b14      	ldr	r3, [pc, #80]	; (8002290 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x140>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:321
        dmaStreamEnable(PDmaTx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 800223e:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:319
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr2);
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
        dmaStreamSetTransactionSize(PDmaTx, WLength2);
        chSysLock();
        PRequestingThread = chThdSelf();
 8002240:	699b      	ldr	r3, [r3, #24]
 8002242:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:320
        dmaStreamEnable(PDmaTx);
 8002244:	69a3      	ldr	r3, [r4, #24]
 8002246:	681b      	ldr	r3, [r3, #0]
 8002248:	681a      	ldr	r2, [r3, #0]
 800224a:	f042 0201 	orr.w	r2, r2, #1
 800224e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:321
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 8002250:	f7fe fece 	bl	8000ff0 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:322
        chSysUnlock();
 8002254:	f7fe fd44 	bl	8000ce0 <dbg_check_unlock>
 8002258:	2300      	movs	r3, #0
 800225a:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:323
        dmaStreamDisable(PDmaTx);
 800225e:	69a3      	ldr	r3, [r4, #24]
 8002260:	681a      	ldr	r2, [r3, #0]
 8002262:	6811      	ldr	r1, [r2, #0]
 8002264:	f021 010f 	bic.w	r1, r1, #15
 8002268:	6011      	str	r1, [r2, #0]
 800226a:	685a      	ldr	r2, [r3, #4]
 800226c:	7a1b      	ldrb	r3, [r3, #8]
 800226e:	210f      	movs	r1, #15
 8002270:	fa01 f303 	lsl.w	r3, r1, r3
 8002274:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:325
    }
    WaitBTF();
 8002276:	4620      	mov	r0, r4
 8002278:	f7ff fe8a 	bl	8001f90 <i2c_t::WaitBTF()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:288
    return OK;
}

uint8_t i2c_t::CmdWriteWrite(uint8_t Addr,
        uint8_t *WPtr1, uint8_t WLength1,
        uint8_t *WPtr2, uint8_t WLength2) {
 800227c:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 800227e:	881a      	ldrh	r2, [r3, #0]
 8002280:	b292      	uxth	r2, r2
 8002282:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002286:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:328
        dmaStreamDisable(PDmaTx);
    }
    WaitBTF();
    SendStop();
    return OK;
}
 8002288:	4628      	mov	r0, r5
 800228a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800228e:	bf00      	nop
 8002290:	2000126c 	.word	0x2000126c
	...

080022a0 <IPutUint.4105>:
IPutUint():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:11
    uint32_t CharCnt = 0, width = 0;
    bool zero_padded = false;
    // Print number n to buffer p in base base. If number is shorter
    // than width, it's prepended with spaces or zeros (if zero_padded
    // is set) from the left.
    void IPutUint(uint32_t n, uint32_t base) {
 80022a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80022a2:	4664      	mov	r4, ip
 80022a4:	b085      	sub	sp, #20
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:13
        char digits[10];
        uint32_t len = 0;
 80022a6:	2500      	movs	r5, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:16
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
 80022a8:	fbb0 f3f1 	udiv	r3, r0, r1
 80022ac:	fb01 0213 	mls	r2, r1, r3, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:18
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 80022b0:	2a09      	cmp	r2, #9
 80022b2:	f105 0501 	add.w	r5, r5, #1
 80022b6:	bf94      	ite	ls
 80022b8:	3230      	addls	r2, #48	; 0x30
 80022ba:	3237      	addhi	r2, #55	; 0x37
 80022bc:	ae01      	add	r6, sp, #4
 80022be:	b2d2      	uxtb	r2, r2
 80022c0:	1977      	adds	r7, r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:17
        char digits[10];
        uint32_t len = 0;
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
            n /= base;
 80022c2:	4618      	mov	r0, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:18
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 80022c4:	f807 2c01 	strb.w	r2, [r7, #-1]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:19
        } while(n > 0);
 80022c8:	2b00      	cmp	r3, #0
 80022ca:	d1ed      	bne.n	80022a8 <IPutUint.4105+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:18
        uint32_t len = 0;
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 80022cc:	462f      	mov	r7, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:21 (discriminator 1)
        } while(n > 0);
        // Add padding
        for(uint32_t i = len; i < width; i++) {
 80022ce:	6823      	ldr	r3, [r4, #0]
 80022d0:	429d      	cmp	r5, r3
 80022d2:	d20e      	bcs.n	80022f2 <IPutUint.4105+0x52>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:22
            if(zero_padded) PPutChar('0');
 80022d4:	7c22      	ldrb	r2, [r4, #16]
 80022d6:	68e3      	ldr	r3, [r4, #12]
 80022d8:	b10a      	cbz	r2, 80022de <IPutUint.4105+0x3e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:22 (discriminator 1)
 80022da:	2030      	movs	r0, #48	; 0x30
 80022dc:	e000      	b.n	80022e0 <IPutUint.4105+0x40>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:23
            else            PPutChar(' ');
 80022de:	2020      	movs	r0, #32
 80022e0:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:24
            if(++CharCnt >= MaxLength) return;
 80022e2:	68a3      	ldr	r3, [r4, #8]
 80022e4:	6862      	ldr	r2, [r4, #4]
 80022e6:	3301      	adds	r3, #1
 80022e8:	4293      	cmp	r3, r2
 80022ea:	60a3      	str	r3, [r4, #8]
 80022ec:	d20f      	bcs.n	800230e <IPutUint.4105+0x6e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:21
            uint32_t digit = n % base;
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
        } while(n > 0);
        // Add padding
        for(uint32_t i = len; i < width; i++) {
 80022ee:	3501      	adds	r5, #1
 80022f0:	e7ed      	b.n	80022ce <IPutUint.4105+0x2e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:27
            if(zero_padded) PPutChar('0');
            else            PPutChar(' ');
            if(++CharCnt >= MaxLength) return;
        }
        // Print digits
        len = (len < (MaxLength - CharCnt))? len : (MaxLength - CharCnt);
 80022f2:	68a3      	ldr	r3, [r4, #8]
 80022f4:	6865      	ldr	r5, [r4, #4]
 80022f6:	1aed      	subs	r5, r5, r3
 80022f8:	42af      	cmp	r7, r5
 80022fa:	bf38      	it	cc
 80022fc:	463d      	movcc	r5, r7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:28
        CharCnt += len;
 80022fe:	442b      	add	r3, r5
 8002300:	60a3      	str	r3, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:29 (discriminator 1)
        while(len > 0) PPutChar(digits[--len]);
 8002302:	b125      	cbz	r5, 800230e <IPutUint.4105+0x6e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:29 (discriminator 2)
 8002304:	3d01      	subs	r5, #1
 8002306:	68e3      	ldr	r3, [r4, #12]
 8002308:	5d70      	ldrb	r0, [r6, r5]
 800230a:	4798      	blx	r3
 800230c:	e7f9      	b.n	8002302 <IPutUint.4105+0x62>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:30
    } // IPutUint
 800230e:	b005      	add	sp, #20
 8002310:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08002320 <kl_vsprintf>:
kl_vsprintf():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:5
#include "kl_sprintf.h"
#include <stdint.h>
#include <stdbool.h>

uint32_t kl_vsprintf(ftVoidChar PPutChar, uint32_t MaxLength, const char *format, va_list args) {
 8002320:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002324:	461c      	mov	r4, r3
 8002326:	b087      	sub	sp, #28
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:6
    uint32_t CharCnt = 0, width = 0;
 8002328:	2300      	movs	r3, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:5
#include "kl_sprintf.h"
#include <stdint.h>
#include <stdbool.h>

uint32_t kl_vsprintf(ftVoidChar PPutChar, uint32_t MaxLength, const char *format, va_list args) {
 800232a:	9004      	str	r0, [sp, #16]
 800232c:	9102      	str	r1, [sp, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:6
    uint32_t CharCnt = 0, width = 0;
 800232e:	9303      	str	r3, [sp, #12]
 8002330:	9301      	str	r3, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:7
    bool zero_padded = false;
 8002332:	f88d 3014 	strb.w	r3, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:34 (discriminator 1)
        while(len > 0) PPutChar(digits[--len]);
    } // IPutUint

    const char *f = format;
    char c;
    while((c = *f++) != 0) {
 8002336:	7810      	ldrb	r0, [r2, #0]
 8002338:	1c56      	adds	r6, r2, #1
 800233a:	b150      	cbz	r0, 8002352 <kl_vsprintf+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:35
        if(c != '%') {
 800233c:	2825      	cmp	r0, #37	; 0x25
 800233e:	d00c      	beq.n	800235a <kl_vsprintf+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:36
            PPutChar(c);
 8002340:	9b04      	ldr	r3, [sp, #16]
 8002342:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:37
            if(++CharCnt >= MaxLength) break;
 8002344:	9b03      	ldr	r3, [sp, #12]
 8002346:	9a02      	ldr	r2, [sp, #8]
 8002348:	3301      	adds	r3, #1
 800234a:	4293      	cmp	r3, r2
 800234c:	9303      	str	r3, [sp, #12]
 800234e:	f0c0 8095 	bcc.w	800247c <kl_vsprintf+0x15c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:89
                if(CharCnt >= MaxLength) break;
            }
        }
        if(CharCnt >= MaxLength) break;
    }
    return CharCnt;
 8002352:	9803      	ldr	r0, [sp, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:90
}
 8002354:	b007      	add	sp, #28
 8002356:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:43
            else continue;
        }

        // Here goes optional width specification.
        // If it starts with zero (zero_padded is true), it means we use '0' instead of ' ' as a filler.
        width = 0;
 800235a:	2200      	movs	r2, #0
 800235c:	9201      	str	r2, [sp, #4]
 800235e:	4611      	mov	r1, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:46
        zero_padded = false;
        while(true) {
            c = *f++;
 8002360:	f816 3b01 	ldrb.w	r3, [r6], #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:47
            if(c < '0' || c > '9') break;
 8002364:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8002368:	b2c5      	uxtb	r5, r0
 800236a:	2d09      	cmp	r5, #9
 800236c:	d807      	bhi.n	800237e <kl_vsprintf+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:48
            if((width == 0) && (c == '0')) zero_padded = true;
 800236e:	b912      	cbnz	r2, 8002376 <kl_vsprintf+0x56>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:48 (discriminator 1)
 8002370:	2b30      	cmp	r3, #48	; 0x30
 8002372:	bf08      	it	eq
 8002374:	2101      	moveq	r1, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:50
            width *= 10;
            width += c-'0';
 8002376:	230a      	movs	r3, #10
 8002378:	fb03 0202 	mla	r2, r3, r2, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:51
        }
 800237c:	e7f0      	b.n	8002360 <kl_vsprintf+0x40>
 800237e:	9201      	str	r2, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:53

        if((c == 's') || (c == 'S')) {
 8002380:	f003 02df 	and.w	r2, r3, #223	; 0xdf
 8002384:	2a53      	cmp	r2, #83	; 0x53
 8002386:	f88d 1014 	strb.w	r1, [sp, #20]
 800238a:	d110      	bne.n	80023ae <kl_vsprintf+0x8e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:54
            char *s = va_arg(args, char*);
 800238c:	1d25      	adds	r5, r4, #4
 800238e:	6824      	ldr	r4, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:55 (discriminator 1)
            while((*s != 0) && (CharCnt++ < MaxLength)) PPutChar(*s++);
 8002390:	f814 3b01 	ldrb.w	r3, [r4], #1
 8002394:	2b00      	cmp	r3, #0
 8002396:	d06b      	beq.n	8002470 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:55 (discriminator 2)
 8002398:	9b03      	ldr	r3, [sp, #12]
 800239a:	1c5a      	adds	r2, r3, #1
 800239c:	9203      	str	r2, [sp, #12]
 800239e:	9a02      	ldr	r2, [sp, #8]
 80023a0:	4293      	cmp	r3, r2
 80023a2:	d265      	bcs.n	8002470 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:55 (discriminator 1)
 80023a4:	f814 0c01 	ldrb.w	r0, [r4, #-1]
 80023a8:	9b04      	ldr	r3, [sp, #16]
 80023aa:	4798      	blx	r3
 80023ac:	e7f0      	b.n	8002390 <kl_vsprintf+0x70>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:57
        }
        else if(c == 'c') {
 80023ae:	2b63      	cmp	r3, #99	; 0x63
 80023b0:	d10b      	bne.n	80023ca <kl_vsprintf+0xaa>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:58
            PPutChar(va_arg(args, int));
 80023b2:	9b04      	ldr	r3, [sp, #16]
 80023b4:	7820      	ldrb	r0, [r4, #0]
 80023b6:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:59
            if(++CharCnt >= MaxLength) break;
 80023b8:	9b03      	ldr	r3, [sp, #12]
 80023ba:	9a02      	ldr	r2, [sp, #8]
 80023bc:	3301      	adds	r3, #1
 80023be:	4293      	cmp	r3, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:58
        if((c == 's') || (c == 'S')) {
            char *s = va_arg(args, char*);
            while((*s != 0) && (CharCnt++ < MaxLength)) PPutChar(*s++);
        }
        else if(c == 'c') {
            PPutChar(va_arg(args, int));
 80023c0:	f104 0504 	add.w	r5, r4, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:59
            if(++CharCnt >= MaxLength) break;
 80023c4:	9303      	str	r3, [sp, #12]
 80023c6:	d353      	bcc.n	8002470 <kl_vsprintf+0x150>
 80023c8:	e7c3      	b.n	8002352 <kl_vsprintf+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:61
        }
        else if(c == 'X') IPutUint(va_arg(args, uint32_t), 16);
 80023ca:	2b58      	cmp	r3, #88	; 0x58
 80023cc:	d105      	bne.n	80023da <kl_vsprintf+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:61 (discriminator 1)
 80023ce:	1d25      	adds	r5, r4, #4
 80023d0:	f10d 0c04 	add.w	ip, sp, #4
 80023d4:	6820      	ldr	r0, [r4, #0]
 80023d6:	2110      	movs	r1, #16
 80023d8:	e006      	b.n	80023e8 <kl_vsprintf+0xc8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:62
        else if(c == 'u') IPutUint(va_arg(args, uint32_t), 10);
 80023da:	2b75      	cmp	r3, #117	; 0x75
 80023dc:	d107      	bne.n	80023ee <kl_vsprintf+0xce>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:62 (discriminator 1)
 80023de:	6820      	ldr	r0, [r4, #0]
 80023e0:	1d25      	adds	r5, r4, #4
 80023e2:	f10d 0c04 	add.w	ip, sp, #4
 80023e6:	210a      	movs	r1, #10
 80023e8:	f7ff ff5a 	bl	80022a0 <IPutUint.4105>
 80023ec:	e040      	b.n	8002470 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:63
        else if(c == 'd') {
 80023ee:	2b64      	cmp	r3, #100	; 0x64
 80023f0:	d111      	bne.n	8002416 <kl_vsprintf+0xf6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:64
            int32_t n = va_arg(args, int32_t);
 80023f2:	1d25      	adds	r5, r4, #4
 80023f4:	6824      	ldr	r4, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:65
            if(n < 0) {
 80023f6:	2c00      	cmp	r4, #0
 80023f8:	da09      	bge.n	800240e <kl_vsprintf+0xee>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:66
                PPutChar('-');
 80023fa:	9b04      	ldr	r3, [sp, #16]
 80023fc:	202d      	movs	r0, #45	; 0x2d
 80023fe:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:67
                if(++CharCnt >= MaxLength) break;
 8002400:	9b03      	ldr	r3, [sp, #12]
 8002402:	9a02      	ldr	r2, [sp, #8]
 8002404:	3301      	adds	r3, #1
 8002406:	4293      	cmp	r3, r2
 8002408:	9303      	str	r3, [sp, #12]
 800240a:	d2a2      	bcs.n	8002352 <kl_vsprintf+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:68
                n = -n;
 800240c:	4264      	negs	r4, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:70
            }
            IPutUint(n, 10);
 800240e:	f10d 0c04 	add.w	ip, sp, #4
 8002412:	4620      	mov	r0, r4
 8002414:	e7e7      	b.n	80023e6 <kl_vsprintf+0xc6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:72
        }
        else if(c == 'A') {
 8002416:	2b41      	cmp	r3, #65	; 0x41
 8002418:	d129      	bne.n	800246e <kl_vsprintf+0x14e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:76
            uint8_t *arr = va_arg(args, uint8_t*);
            int32_t n = va_arg(args, int32_t);
            int32_t Delimiter = va_arg(args, int32_t);
            zero_padded = true; // Every byte consists of two characters.
 800241a:	2301      	movs	r3, #1
 800241c:	f88d 3014 	strb.w	r3, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:77
            width = 2;          // ...01 02 0A etc.; not 1 2 A
 8002420:	2302      	movs	r3, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:73
                n = -n;
            }
            IPutUint(n, 10);
        }
        else if(c == 'A') {
            uint8_t *arr = va_arg(args, uint8_t*);
 8002422:	f8d4 9000 	ldr.w	r9, [r4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:74
            int32_t n = va_arg(args, int32_t);
 8002426:	f8d4 8004 	ldr.w	r8, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:75
            int32_t Delimiter = va_arg(args, int32_t);
 800242a:	f104 050c 	add.w	r5, r4, #12
 800242e:	68a7      	ldr	r7, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:77
            zero_padded = true; // Every byte consists of two characters.
            width = 2;          // ...01 02 0A etc.; not 1 2 A
 8002430:	9301      	str	r3, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:78
            for(int32_t i = 0; i < n; i++) {
 8002432:	2400      	movs	r4, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:78 (discriminator 1)
 8002434:	4544      	cmp	r4, r8
 8002436:	da1b      	bge.n	8002470 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:79
                if((i > 0) && (Delimiter != 0)) {
 8002438:	2c00      	cmp	r4, #0
 800243a:	dc0c      	bgt.n	8002456 <kl_vsprintf+0x136>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:83
                    PPutChar((char)Delimiter); // do not place delimiter before or after array
                    if(++CharCnt >= MaxLength) break;
                }
                IPutUint(arr[i], 16);
 800243c:	f10d 0c04 	add.w	ip, sp, #4
 8002440:	f819 0004 	ldrb.w	r0, [r9, r4]
 8002444:	2110      	movs	r1, #16
 8002446:	f7ff ff2b 	bl	80022a0 <IPutUint.4105>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:84
                if(CharCnt >= MaxLength) break;
 800244a:	9b02      	ldr	r3, [sp, #8]
 800244c:	9a03      	ldr	r2, [sp, #12]
 800244e:	429a      	cmp	r2, r3
 8002450:	d20e      	bcs.n	8002470 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:78
            uint8_t *arr = va_arg(args, uint8_t*);
            int32_t n = va_arg(args, int32_t);
            int32_t Delimiter = va_arg(args, int32_t);
            zero_padded = true; // Every byte consists of two characters.
            width = 2;          // ...01 02 0A etc.; not 1 2 A
            for(int32_t i = 0; i < n; i++) {
 8002452:	3401      	adds	r4, #1
 8002454:	e7ee      	b.n	8002434 <kl_vsprintf+0x114>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:79 (discriminator 1)
                if((i > 0) && (Delimiter != 0)) {
 8002456:	2f00      	cmp	r7, #0
 8002458:	d0f0      	beq.n	800243c <kl_vsprintf+0x11c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:80
                    PPutChar((char)Delimiter); // do not place delimiter before or after array
 800245a:	9b04      	ldr	r3, [sp, #16]
 800245c:	b2f8      	uxtb	r0, r7
 800245e:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:81
                    if(++CharCnt >= MaxLength) break;
 8002460:	9b03      	ldr	r3, [sp, #12]
 8002462:	9a02      	ldr	r2, [sp, #8]
 8002464:	3301      	adds	r3, #1
 8002466:	4293      	cmp	r3, r2
 8002468:	9303      	str	r3, [sp, #12]
 800246a:	d3e7      	bcc.n	800243c <kl_vsprintf+0x11c>
 800246c:	e000      	b.n	8002470 <kl_vsprintf+0x150>
 800246e:	4625      	mov	r5, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:87
                }
                IPutUint(arr[i], 16);
                if(CharCnt >= MaxLength) break;
            }
        }
        if(CharCnt >= MaxLength) break;
 8002470:	9b02      	ldr	r3, [sp, #8]
 8002472:	9a03      	ldr	r2, [sp, #12]
 8002474:	429a      	cmp	r2, r3
 8002476:	f4bf af6c 	bcs.w	8002352 <kl_vsprintf+0x32>
 800247a:	462c      	mov	r4, r5
 800247c:	4632      	mov	r2, r6
 800247e:	e75a      	b.n	8002336 <kl_vsprintf+0x16>

08002480 <Beeper_t::BeepI(BeepChunk_t const*)>:
_ZN8Beeper_t5BeepIEPK11BeepChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:30
    IPin.Init(GPIOB, 3, TIM2, 2, BEEP_TOP_VALUE);
}

void Beeper_t::BeepI(const BeepChunk_t *PSequence) {
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
 8002480:	68c3      	ldr	r3, [r0, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:28

void Beeper_t::Init() {
    IPin.Init(GPIOB, 3, TIM2, 2, BEEP_TOP_VALUE);
}

void Beeper_t::BeepI(const BeepChunk_t *PSequence) {
 8002482:	b570      	push	{r4, r5, r6, lr}
 8002484:	4605      	mov	r5, r0
 8002486:	460c      	mov	r4, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:30
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
 8002488:	b10b      	cbz	r3, 800248e <Beeper_t::BeepI(BeepChunk_t const*)+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:30 (discriminator 1)
 800248a:	f7ff f891 	bl	80015b0 <chVTResetI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:31
    if(PSequence == nullptr) {
 800248e:	b914      	cbnz	r4, 8002496 <Beeper_t::BeepI(BeepChunk_t const*)+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:32
        IPin.Off();
 8002490:	6a2b      	ldr	r3, [r5, #32]
_ZN8PwmPin_t3OffEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:219
public:
    __IO uint32_t *PCCR;    // Made public to allow DMA
    void SetFreqHz(uint32_t FreqHz);
    void Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted=false);
    void Set(uint16_t Value) { *PCCR = Value; }
    void Off() { *PCCR = 0; }
 8002492:	601c      	str	r4, [r3, #0]
 8002494:	bd70      	pop	{r4, r5, r6, pc}
_ZN8Beeper_t5BeepIEPK11BeepChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:36
        return;
    }
    // Set sound
    IPin.SetFreqHz(PSequence->Freq_Hz);
 8002496:	f105 0018 	add.w	r0, r5, #24
 800249a:	8861      	ldrh	r1, [r4, #2]
 800249c:	f7ff fc58 	bl	8001d50 <PwmPin_t::SetFreqHz(unsigned long)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:32

void Beeper_t::BeepI(const BeepChunk_t *PSequence) {
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
    if(PSequence == nullptr) {
        IPin.Off();
 80024a0:	6a2b      	ldr	r3, [r5, #32]
_ZN8PwmPin_t3SetEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:218
    TIM_TypeDef* Tim;
public:
    __IO uint32_t *PCCR;    // Made public to allow DMA
    void SetFreqHz(uint32_t FreqHz);
    void Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted=false);
    void Set(uint16_t Value) { *PCCR = Value; }
 80024a2:	7822      	ldrb	r2, [r4, #0]
 80024a4:	601a      	str	r2, [r3, #0]
_ZN8Beeper_t5BeepIEPK11BeepChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:40
    // Set sound
    IPin.SetFreqHz(PSequence->Freq_Hz);
    IPin.Set(PSequence->Volume);
    // Proceed sequence, stop it or restart
    const BeepChunk_t *PCh = nullptr;
    switch(PSequence->ChunkKind) {
 80024a6:	79a3      	ldrb	r3, [r4, #6]
 80024a8:	b11b      	cbz	r3, 80024b2 <Beeper_t::BeepI(BeepChunk_t const*)+0x32>
 80024aa:	2b02      	cmp	r3, #2
 80024ac:	d104      	bne.n	80024b8 <Beeper_t::BeepI(BeepChunk_t const*)+0x38>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:43
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
 80024ae:	696b      	ldr	r3, [r5, #20]
 80024b0:	e003      	b.n	80024ba <Beeper_t::BeepI(BeepChunk_t const*)+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:41
    IPin.SetFreqHz(PSequence->Freq_Hz);
    IPin.Set(PSequence->Volume);
    // Proceed sequence, stop it or restart
    const BeepChunk_t *PCh = nullptr;
    switch(PSequence->ChunkKind) {
        case ckNormal: PCh = PSequence + 1; break;
 80024b2:	f104 0308 	add.w	r3, r4, #8
 80024b6:	e000      	b.n	80024ba <Beeper_t::BeepI(BeepChunk_t const*)+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:39
    }
    // Set sound
    IPin.SetFreqHz(PSequence->Freq_Hz);
    IPin.Set(PSequence->Volume);
    // Proceed sequence, stop it or restart
    const BeepChunk_t *PCh = nullptr;
 80024b8:	2300      	movs	r3, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:46
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
    }
    // Start timer
    chVTSetI(&ITmr, MS2ST(PSequence->Time_ms), BeeperTmrCallback, (void*)PCh);
 80024ba:	4628      	mov	r0, r5
 80024bc:	88a1      	ldrh	r1, [r4, #4]
 80024be:	4a02      	ldr	r2, [pc, #8]	; (80024c8 <Beeper_t::BeepI(BeepChunk_t const*)+0x48>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:47
}
 80024c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:46
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
    }
    // Start timer
    chVTSetI(&ITmr, MS2ST(PSequence->Time_ms), BeeperTmrCallback, (void*)PCh);
 80024c4:	f7ff b84c 	b.w	8001560 <chVTSetI>
 80024c8:	080024d1 	.word	0x080024d1
$d():
 80024cc:	00000000 	.word	0x00000000

080024d0 <BeeperTmrCallback(void*)>:
_Z17BeeperTmrCallbackPv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:18

#if 1 // =============================== Beep ==================================
#define BEEP_TOP_VALUE   22
Beeper_t Beeper;
// Timer callback
void BeeperTmrCallback(void *p) {
 80024d0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:19
    chSysLockFromIsr();
 80024d2:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:18

#if 1 // =============================== Beep ==================================
#define BEEP_TOP_VALUE   22
Beeper_t Beeper;
// Timer callback
void BeeperTmrCallback(void *p) {
 80024d4:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:19
    chSysLockFromIsr();
 80024d6:	f383 8811 	msr	BASEPRI, r3
 80024da:	f7fe fc19 	bl	8000d10 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:20
    Beeper.BeepI((const BeepChunk_t*)p);
 80024de:	4805      	ldr	r0, [pc, #20]	; (80024f4 <BeeperTmrCallback(void*)+0x24>)
 80024e0:	4621      	mov	r1, r4
 80024e2:	f7ff ffcd 	bl	8002480 <Beeper_t::BeepI(BeepChunk_t const*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:21
    chSysUnlockFromIsr();
 80024e6:	f7fe fc2b 	bl	8000d40 <dbg_check_unlock_from_isr>
 80024ea:	2300      	movs	r3, #0
 80024ec:	f383 8811 	msr	BASEPRI, r3
 80024f0:	bd10      	pop	{r4, pc}
 80024f2:	bf00      	nop
 80024f4:	20000e08 	.word	0x20000e08
	...

08002500 <PillMgr_t::Deinit()>:
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:22
    chThdSleepMilliseconds(1);  // Allow power to rise
    i2c.Init(PILL_I2C, PILL_I2C_GPIO, PILL_SCL_PIN, PILL_SDA_PIN, PILL_I2C_BITRATE_HZ, PILL_DMATX, PILL_DMARX);
    chSemSignal(&Sem);
}

void PillMgr_t::Deinit() {
 8002500:	b538      	push	{r3, r4, r5, lr}
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8002502:	4c0d      	ldr	r4, [pc, #52]	; (8002538 <PillMgr_t::Deinit()+0x38>)
 8002504:	2380      	movs	r3, #128	; 0x80
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:22
 8002506:	4605      	mov	r5, r0
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 8002508:	8363      	strh	r3, [r4, #26]
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:24
    PinClear(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to fade
 800250a:	2001      	movs	r0, #1
 800250c:	f7fe ffc8 	bl	80014a0 <chThdSleep>
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002510:	4b0a      	ldr	r3, [pc, #40]	; (800253c <PillMgr_t::Deinit()+0x3c>)
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:26
    PinSetupAnalog(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);    // Power
    i2c.Standby();
 8002512:	f105 000c 	add.w	r0, r5, #12
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8002516:	69da      	ldr	r2, [r3, #28]
 8002518:	f042 0202 	orr.w	r2, r2, #2
 800251c:	61da      	str	r2, [r3, #28]
PinSetupAnalog():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:176
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 800251e:	6823      	ldr	r3, [r4, #0]
 8002520:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002524:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:178
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8002526:	68e3      	ldr	r3, [r4, #12]
 8002528:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800252c:	60e3      	str	r3, [r4, #12]
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:27
}
 800252e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:26

void PillMgr_t::Deinit() {
    PinClear(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to fade
    PinSetupAnalog(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);    // Power
    i2c.Standby();
 8002532:	f7ff bc2d 	b.w	8001d90 <i2c_t::Standby()>
 8002536:	bf00      	nop
 8002538:	40020400 	.word	0x40020400
 800253c:	40023800 	.word	0x40023800

08002540 <PillMgr_t::ResetBus()>:
_ZN9PillMgr_t8ResetBusEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:29
}

void PillMgr_t::ResetBus() {
 8002540:	b510      	push	{r4, lr}
 8002542:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:30
    Deinit();
 8002544:	f7ff ffdc 	bl	8002500 <PillMgr_t::Deinit()>
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002548:	4b18      	ldr	r3, [pc, #96]	; (80025ac <PillMgr_t::ResetBus()+0x6c>)
_ZN9PillMgr_t8ResetBusEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:33
    PinSetupOut(PERIPH_PWR_GPIO, PERIPH_PWR_PIN, omPushPull);   // Power
    PinSet(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to rise
 800254a:	2001      	movs	r0, #1
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 800254c:	69da      	ldr	r2, [r3, #28]
 800254e:	f042 0202 	orr.w	r2, r2, #2
 8002552:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8002554:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 8002558:	681a      	ldr	r2, [r3, #0]
 800255a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 800255e:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 8002560:	681a      	ldr	r2, [r3, #0]
 8002562:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002566:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8002568:	889a      	ldrh	r2, [r3, #4]
 800256a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800256e:	0412      	lsls	r2, r2, #16
 8002570:	0c12      	lsrs	r2, r2, #16
 8002572:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8002574:	889a      	ldrh	r2, [r3, #4]
 8002576:	b292      	uxth	r2, r2
 8002578:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 800257a:	68da      	ldr	r2, [r3, #12]
 800257c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002580:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8002582:	68da      	ldr	r2, [r3, #12]
 8002584:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8002586:	689a      	ldr	r2, [r3, #8]
 8002588:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 800258c:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800258e:	689a      	ldr	r2, [r3, #8]
 8002590:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002594:	609a      	str	r2, [r3, #8]
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8002596:	2280      	movs	r2, #128	; 0x80
 8002598:	831a      	strh	r2, [r3, #24]
_ZN9PillMgr_t8ResetBusEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:33
 800259a:	f7fe ff81 	bl	80014a0 <chThdSleep>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:34
    i2c.Resume();
 800259e:	f104 000c 	add.w	r0, r4, #12
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:35
}
 80025a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:34
void PillMgr_t::ResetBus() {
    Deinit();
    PinSetupOut(PERIPH_PWR_GPIO, PERIPH_PWR_PIN, omPushPull);   // Power
    PinSet(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to rise
    i2c.Resume();
 80025a6:	f7ff bc33 	b.w	8001e10 <i2c_t::Resume()>
 80025aa:	bf00      	nop
 80025ac:	40023800 	.word	0x40023800

080025b0 <PillMgr_t::CheckIfConnected(unsigned char)>:
_ZN9PillMgr_t16CheckIfConnectedEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:37
}

uint8_t PillMgr_t::CheckIfConnected(uint8_t i2cAddr) {
 80025b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80025b2:	4604      	mov	r4, r0
 80025b4:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:38
    chSemWait(&Sem);
 80025b6:	f7fe fe33 	bl	8001220 <chSemWait>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:39
    uint8_t Rslt = i2c.CmdWriteWrite(i2cAddr, NULL, 0, NULL, 0);
 80025ba:	2200      	movs	r2, #0
 80025bc:	4629      	mov	r1, r5
 80025be:	4613      	mov	r3, r2
 80025c0:	9200      	str	r2, [sp, #0]
 80025c2:	9201      	str	r2, [sp, #4]
 80025c4:	f104 000c 	add.w	r0, r4, #12
 80025c8:	f7ff fdc2 	bl	8002150 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:40
    if(i2c.Error == true) ResetBus();
 80025cc:	7f23      	ldrb	r3, [r4, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:39
    i2c.Resume();
}

uint8_t PillMgr_t::CheckIfConnected(uint8_t i2cAddr) {
    chSemWait(&Sem);
    uint8_t Rslt = i2c.CmdWriteWrite(i2cAddr, NULL, 0, NULL, 0);
 80025ce:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:40
    if(i2c.Error == true) ResetBus();
 80025d0:	b113      	cbz	r3, 80025d8 <PillMgr_t::CheckIfConnected(unsigned char)+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:40 (discriminator 1)
 80025d2:	4620      	mov	r0, r4
 80025d4:	f7ff ffb4 	bl	8002540 <PillMgr_t::ResetBus()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:41
    chSemSignal(&Sem);
 80025d8:	4620      	mov	r0, r4
 80025da:	f7fe fe39 	bl	8001250 <chSemSignal>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:43
    return Rslt;
}
 80025de:	4628      	mov	r0, r5
 80025e0:	b003      	add	sp, #12
 80025e2:	bd30      	pop	{r4, r5, pc}
	...

080025f0 <PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)>:
_ZN9PillMgr_t4ReadEhPhm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:45

uint8_t PillMgr_t::Read(uint8_t i2cAddr, uint8_t *Ptr, uint32_t Length) {
 80025f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025f2:	461f      	mov	r7, r3
 80025f4:	b085      	sub	sp, #20
 80025f6:	4604      	mov	r4, r0
 80025f8:	460d      	mov	r5, r1
 80025fa:	4616      	mov	r6, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:48
    chSemWait(&Sem);
    uint8_t WordAddress = PILL_START_ADDR;
    uint8_t Rslt = i2c.CmdWriteRead(i2cAddr, &WordAddress, 1, Ptr, Length);
 80025fc:	b2ff      	uxtb	r7, r7
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:46
    chSemSignal(&Sem);
    return Rslt;
}

uint8_t PillMgr_t::Read(uint8_t i2cAddr, uint8_t *Ptr, uint32_t Length) {
    chSemWait(&Sem);
 80025fe:	f7fe fe0f 	bl	8001220 <chSemWait>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:47
    uint8_t WordAddress = PILL_START_ADDR;
 8002602:	aa04      	add	r2, sp, #16
 8002604:	2300      	movs	r3, #0
 8002606:	f802 3d01 	strb.w	r3, [r2, #-1]!
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:48
    uint8_t Rslt = i2c.CmdWriteRead(i2cAddr, &WordAddress, 1, Ptr, Length);
 800260a:	4629      	mov	r1, r5
 800260c:	2301      	movs	r3, #1
 800260e:	9600      	str	r6, [sp, #0]
 8002610:	9701      	str	r7, [sp, #4]
 8002612:	f104 000c 	add.w	r0, r4, #12
 8002616:	f7ff fccb 	bl	8001fb0 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:49
    if(i2c.Error == true) ResetBus();
 800261a:	7f23      	ldrb	r3, [r4, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:48
}

uint8_t PillMgr_t::Read(uint8_t i2cAddr, uint8_t *Ptr, uint32_t Length) {
    chSemWait(&Sem);
    uint8_t WordAddress = PILL_START_ADDR;
    uint8_t Rslt = i2c.CmdWriteRead(i2cAddr, &WordAddress, 1, Ptr, Length);
 800261c:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:49
    if(i2c.Error == true) ResetBus();
 800261e:	b113      	cbz	r3, 8002626 <PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:49 (discriminator 1)
 8002620:	4620      	mov	r0, r4
 8002622:	f7ff ff8d 	bl	8002540 <PillMgr_t::ResetBus()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:50
    chSemSignal(&Sem);
 8002626:	4620      	mov	r0, r4
 8002628:	f7fe fe12 	bl	8001250 <chSemSignal>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:52
    return Rslt;
}
 800262c:	4628      	mov	r0, r5
 800262e:	b005      	add	sp, #20
 8002630:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08002640 <memset>:
memset():
 8002640:	b4f0      	push	{r4, r5, r6, r7}
 8002642:	0784      	lsls	r4, r0, #30
 8002644:	d043      	beq.n	80026ce <memset+0x8e>
 8002646:	1e54      	subs	r4, r2, #1
 8002648:	2a00      	cmp	r2, #0
 800264a:	d03e      	beq.n	80026ca <memset+0x8a>
 800264c:	b2cd      	uxtb	r5, r1
 800264e:	4603      	mov	r3, r0
 8002650:	e003      	b.n	800265a <memset+0x1a>
 8002652:	1e62      	subs	r2, r4, #1
 8002654:	2c00      	cmp	r4, #0
 8002656:	d038      	beq.n	80026ca <memset+0x8a>
 8002658:	4614      	mov	r4, r2
 800265a:	f803 5b01 	strb.w	r5, [r3], #1
 800265e:	079a      	lsls	r2, r3, #30
 8002660:	d1f7      	bne.n	8002652 <memset+0x12>
 8002662:	2c03      	cmp	r4, #3
 8002664:	d92a      	bls.n	80026bc <memset+0x7c>
 8002666:	b2cd      	uxtb	r5, r1
 8002668:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800266c:	2c0f      	cmp	r4, #15
 800266e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8002672:	d915      	bls.n	80026a0 <memset+0x60>
 8002674:	f1a4 0710 	sub.w	r7, r4, #16
 8002678:	093f      	lsrs	r7, r7, #4
 800267a:	f103 0610 	add.w	r6, r3, #16
 800267e:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8002682:	461a      	mov	r2, r3
 8002684:	6015      	str	r5, [r2, #0]
 8002686:	6055      	str	r5, [r2, #4]
 8002688:	6095      	str	r5, [r2, #8]
 800268a:	60d5      	str	r5, [r2, #12]
 800268c:	3210      	adds	r2, #16
 800268e:	42b2      	cmp	r2, r6
 8002690:	d1f8      	bne.n	8002684 <memset+0x44>
 8002692:	f004 040f 	and.w	r4, r4, #15
 8002696:	3701      	adds	r7, #1
 8002698:	2c03      	cmp	r4, #3
 800269a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800269e:	d90d      	bls.n	80026bc <memset+0x7c>
 80026a0:	461e      	mov	r6, r3
 80026a2:	4622      	mov	r2, r4
 80026a4:	3a04      	subs	r2, #4
 80026a6:	2a03      	cmp	r2, #3
 80026a8:	f846 5b04 	str.w	r5, [r6], #4
 80026ac:	d8fa      	bhi.n	80026a4 <memset+0x64>
 80026ae:	1f22      	subs	r2, r4, #4
 80026b0:	f022 0203 	bic.w	r2, r2, #3
 80026b4:	3204      	adds	r2, #4
 80026b6:	4413      	add	r3, r2
 80026b8:	f004 0403 	and.w	r4, r4, #3
 80026bc:	b12c      	cbz	r4, 80026ca <memset+0x8a>
 80026be:	b2c9      	uxtb	r1, r1
 80026c0:	441c      	add	r4, r3
 80026c2:	f803 1b01 	strb.w	r1, [r3], #1
 80026c6:	42a3      	cmp	r3, r4
 80026c8:	d1fb      	bne.n	80026c2 <memset+0x82>
 80026ca:	bcf0      	pop	{r4, r5, r6, r7}
 80026cc:	4770      	bx	lr
 80026ce:	4614      	mov	r4, r2
 80026d0:	4603      	mov	r3, r0
 80026d2:	e7c6      	b.n	8002662 <memset+0x22>
	...
$d():
 80026e0:	08060403 	.word	0x08060403
 80026e4:	2018100c 	.word	0x2018100c
 80026e8:	00000030 	.word	0x00000030
 80026ec:	00000000 	.word	0x00000000
 80026f0:	03020100 	.word	0x03020100
 80026f4:	08070604 	.word	0x08070604
 80026f8:	00000009 	.word	0x00000009
 80026fc:	03020100 	.word	0x03020100
 8002700:	00000004 	.word	0x00000004
	...

08002710 <BeepPillBad>:
 8002710:	0aea0001 000000b4 092d0001 000000b4     ..........-.....
 8002720:	07b70001 000100b4 00000000 00000000     ................
 8002730:	00707041 00000000 00000000 00000000     App.............
 8002740:	53206363 74726174 000a6465 00000000     cc Started......
 8002750:	000d6425 69646172 0000006f 00000000     %d..radio.......
 8002760:	31235653 23565300 56530032 53003323     SV#1.SV#2.SV#3.S
 8002770:	00342356 35235653 23565300 56530036     V#4.SV#5.SV#6.SV
 8002780:	53003723 00382356 39235653 23565300     #7.SV#8.SV#9.SV#
 8002790:	53003031 31312356 00000000 00000000     10.SV#11........
 80027a0:	45686322 65527476 74736967 614d7265     "chEvtRegisterMa
 80027b0:	28226b73 63220029 74764568 65726e55     sk"()."chEvtUnre
 80027c0:	74736967 28227265 63220029 74764568     gister"()."chEvt
 80027d0:	6e676953 22496c61 22002928 76456863     SignalI"()."chEv
 80027e0:	6f724274 61636461 614d7473 22496b73     tBroadcastMaskI"
 80027f0:	22002928 76456863 67695374 226c616e     ()."chEvtSignal"
 8002800:	22002928 76456863 73694474 63746170     ()."chEvtDispatc
 8002810:	29282268 45686300 69447476 74617073     h"().chEvtDispat
 8002820:	29286863 3123202c 00000000 00000000     ch(), #1........

08002830 <ch_debug>:
 8002830:	6e69616d 11801600 08340404 1814100c     main......4.....
 8002840:	0021201c 00002422 00000000 00000000     . !."$..........
 8002850:	63536863 61655268 28497964 23202c29     chSchReadyI(), #
 8002860:	74730031 206b6361 7265766f 776f6c66     1.stack overflow
	...
 8002880:	53686322 6e496d65 28227469 63220029     "chSemInit"()."c
 8002890:	6d655368 65736552 28224974 68630029     hSemResetI"().ch
 80028a0:	526d6553 74657365 2c292849 00312320     SemResetI(), #1.
 80028b0:	53686322 61576d65 22537469 63002928     "chSemWaitS"().c
 80028c0:	6d655368 74696157 2c292853 00312320     hSemWaitS(), #1.
 80028d0:	53686322 61576d65 69547469 756f656d     "chSemWaitTimeou
 80028e0:	28225374 68630029 576d6553 54746961     tS"().chSemWaitT
 80028f0:	6f656d69 28537475 23202c29 63220031     imeoutS(), #1."c
 8002900:	6d655368 6e676953 28226c61 68630029     hSemSignal"().ch
 8002910:	536d6553 616e6769 2c29286c 00312320     SemSignal(), #1.
 8002920:	53686322 69536d65 6c616e67 29282249     "chSemSignalI"()
 8002930:	53686300 69536d65 6c616e67 2c292849     .chSemSignalI(),
 8002940:	00312320 53686322 64416d65 756f4364      #1."chSemAddCou
 8002950:	7265746e 29282249 53686300 64416d65     nterI"().chSemAd
 8002960:	756f4364 7265746e 2c292849 00312320     dCounterI(), #1.
 8002970:	53686322 69536d65 6c616e67 74696157     "chSemSignalWait
 8002980:	00292822 65536863 6769536d 576c616e     "().chSemSignalW
 8002990:	28746961 23202c29 68630031 536d6553     ait(), #1.chSemS
 80029a0:	616e6769 6961576c 2c292874 00322320     ignalWait(), #2.
 80029b0:	656c6469 00000000 00000000 00000000     idle............
 80029c0:	54686322 72436468 65746165 29282249     "chThdCreateI"()
 80029d0:	68632200 53646854 72507465 69726f69     ."chThdSetPriori
 80029e0:	28227974 68630029 52646854 6d757365     ty"().chThdResum
 80029f0:	2c292865 00312320 54686322 6c536468     e(), #1."chThdSl
 8002a00:	22706565 63002928 64685468 74697845     eep"().chThdExit
 8002a10:	2c292853 00312320 54686322 61576468     S(), #1."chThdWa
 8002a20:	28227469 68630029 57646854 28746961     it"().chThdWait(
 8002a30:	23202c29 00000031 00000000 00000000     ), #1...........
 8002a40:	56686322 74655354 29282249 68632200     "chVTSetI"()."ch
 8002a50:	65525456 49746573 00292822 54566863     VTResetI"().chVT
 8002a60:	65736552 29284974 3123202c 00000000     ResetI(), #1....
 8002a70:	616d6422 65727453 6c416d61 61636f6c     "dmaStreamAlloca
 8002a80:	28226574 64220029 7453616d 6d616572     te"()."dmaStream
 8002a90:	656c6552 22657361 64002928 7453616d     Release"().dmaSt
 8002aa0:	6d616572 656c6552 28657361 23202c29     reamRelease(), #
 8002ab0:	00000031 00000000 00000000 00000000     1...............

08002ac0 <_stm32_dma_streams>:
 8002ac0:	40026008 40026004 000b0000 4002601c     .`.@.`.@.....`.@
 8002ad0:	40026004 000c0104 40026030 40026004     .`.@....0`.@.`.@
 8002ae0:	000d0208 40026044 40026004 000e030c     ....D`.@.`.@....
 8002af0:	40026058 40026004 000f0410 4002606c     X`.@.`.@....l`.@
 8002b00:	40026004 00100514 40026080 40026004     .`.@.....`.@.`.@
 8002b10:	00110618                                ....
