
ChArmletBasic.elf:     file format elf32-littlearm
ChArmletBasic.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000d01

Program Header:
    LOAD off    0x00008000 vaddr 0x08000000 paddr 0x08000000 align 2**15
         filesz 0x000031c4 memsz 0x000031c8 flags rwx
    LOAD off    0x00010800 vaddr 0x20000800 paddr 0x080031c8 align 2**15
         filesz 0x00000000 memsz 0x00000b80 flags rw-
    LOAD off    0x00010000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000800 flags rw-
private flags = 5000002: [Version5 EABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 startup       000000f4  08000000  08000000  00008000  2**4  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000030c4  08000100  08000100  00008100  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .textalign    00000004  080031c4  080031c4  0000b1c4  2**0  ALLOC
  3 .stacks       00000800  20000000  20000000  00010000  2**0  ALLOC
  4 .bss          00000b80  20000800  080031c8  00010800  2**3  ALLOC
  5 .debug_info   000170c5  00000000  00000000  0000b1c4  2**0  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00004683  00000000  00000000  00022289  2**0  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00005010  00000000  00000000  0002690c  2**0  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000008b0  00000000  00000000  0002b91c  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000010a8  00000000  00000000  0002c1cc  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00004610  00000000  00000000  0002d274  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00004232  00000000  00000000  00031884  2**0  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000070  00000000  00000000  00035ab6  2**0  CONTENTS, READONLY
 13 .ARM.attributes 00000033  00000000  00000000  00035b26  2**0  CONTENTS, READONLY
 14 .debug_frame  0000148c  00000000  00000000  00035b5c  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  startup	00000000 startup
08000100 l    d  .text	00000000 .text
080031c4 l    d  .textalign	00000000 .textalign
20000000 l    d  .stacks	00000000 .stacks
20000800 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00000000 l    df *ABS*	00000000 main.cpp
08002da0 l     O .text	0000000c BrrBrr
08002db0 l     O .text	00000018 BeepBeep
00000000 l    df *ABS*	00000000 application.cpp
080002c0 l     F .text	00000044 AppThread(void*)
20000800 l     O .bss	00000008 Pill
08002d70 l     O .text	00000018 BeepPillBad
20000808 l     O .bss	00000014 ITmrPillCheck
20000820 l     O .bss	00000198 waAppThread
00000000 l    df *ABS*	00000000 radio_lvl1.cpp
08000420 l     F .text	0000001c rLvl1Thread(void*)
200009d8 l     O .bss	00000198 warLvl1Thread
00000000 l    df *ABS*	00000000 cc1101.cpp
080004e0 l     F .text	00000010 cc1101_t::BusyWait() [clone .isra.6]
00000000 l    df *ABS*	00000000 nvic.c
00000000 l    df *ABS*	00000000 chcore_v7m.c
08000b9c l       .text	00000000 _port_exit_from_isr
00000000 l    df *ABS*	00000000 crt0.c
00000000 l    df *ABS*	00000000 chdebug.c
00000000 l    df *ABS*	00000000 chevents.c
00000000 l    df *ABS*	00000000 chschd.c
080010d0 l     F .text	0000004c wakeup
00000000 l    df *ABS*	00000000 chsem.c
00000000 l    df *ABS*	00000000 chsys.c
20000b8c l     O .bss	00000034 mainthread.4585
00000000 l    df *ABS*	00000000 chthreads.c
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 hal.c
00000000 l    df *ABS*	00000000 hal_lld.cpp
00000000 l    df *ABS*	00000000 stm32_dma.c
20000bc0 l     O .bss	00000038 dma_isr_redir
20000bf8 l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 clocking_L1xx.cpp
00000000 l    df *ABS*	00000000 cmd_uart.cpp
08001bc0 l     F .text	0000000c FPutChar(char)
00000000 l    df *ABS*	00000000 kl_lib_L15x.cpp
08001de0 l     F .text	0000005c PinClockEnable(GPIO_TypeDef*)
08001e40 l     F .text	00000090 PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]
00000000 l    df *ABS*	00000000 kl_sprintf.c
080025f0 l     F .text	00000072 IPutUint.4105
00000000 l    df *ABS*	00000000 peripheral.cpp
00000000 l    df *ABS*	00000000 pill_mgr.cpp
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 
20001380 l       .bss	00000000 __heap_base__
080031c8 l       .textalign	00000000 _etext
20002800 l       *ABS*	00000000 __heap_end__
00002800 l       *ABS*	00000000 __ram_size__
00000000 l       startup	00000000 _text
20000000 l       startup	00000000 __ram_start__
20002800 l       *ABS*	00000000 __ram_end__
20001380 l       .bss	00000000 _end
00000400 l       *ABS*	00000000 __main_stack_size__
00000400 l       *ABS*	00000000 __process_stack_size__
08000b80  w    F .text	00000002 Vector58
08000b80  w    F .text	00000002 VectorE8
08000b80  w    F .text	00000002 Vector9C
08000b00 g     F .text	00000046 nvicEnableVector
08000e40 g     F .text	00000028 dbg_check_lock_from_isr
08001b60 g     F .text	00000034 SetupVCore(VCore_t)
08000b80  w    F .text	00000002 VectorAC
08001670 g     F .text	00000018 chThdExit
08001490 g     F .text	00000068 chSysTimerHandlerI
08001170 g     F .text	00000048 chSchGoSleepTimeoutS
08000de0 g     F .text	00000028 dbg_check_lock
08000210 g     F .text	0000003c TmrPillCheckCallback(void*)
08000b80  w    F .text	00000002 Vector5C
08000b80  w    F .text	00000002 NMIVector
08001970 g     F .text	00000038 dmaInit
08000b80  w    F .text	00000002 Vector8C
08000b80  w    F .text	00000002 VectorDC
08002240 g     F .text	0000002a i2c_t::IBusyWait()
080022c0 g     F .text	0000001a i2c_t::WaitEv8()
08002850 g     F .text	00000028 BeeperTmrCallback(void*)
08000000 g     O startup	000000f4 _vectors
08000550 g     F .text	00000068 cc1101_t::ReadFIFO(rPkt_t*)
08001120 g     F .text	00000050 chSchGoSleepS
08001540 g     F .text	0000004c chThdCreateI
08000dc0 g     F .text	00000020 dbg_check_enable
08000b80  w    F .text	00000002 VectorC8
080011c0 g     F .text	00000058 chSchWakeupS
20000e18 g     O .bss	00000018 Vibro
08001070 g     F .text	00000014 _scheduler_init
08001590 g     F .text	0000005e chThdCreateStatic
08000b80  w    F .text	00000002 Vector94
200009b8 g     O .bss	00000004 App
08000b80  w    F .text	00000002 VectorA8
08000b80  w    F .text	00000002 VectorB4
080021e0 g     F .text	0000005c i2c_t::Init(I2C_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned short, unsigned long, stm32_dma_stream_t const*, stm32_dma_stream_t const*)
08001090 g     F .text	00000040 chSchReadyI
08001ed0 g     F .text	00000168 PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)
08002a80 g     F .text	00000028 VibroTmrCallback(void*)
080000f4 g       startup	00000000 __fini_array_end
20000800 g       .stacks	00000000 __main_thread_stack_end__
08001690 g     F .text	00000018 _vt_init
08001830 g     F .text	00000034 Vector74
08001750 g     F .text	00000004 halInit
200009bc g     O .bss	0000001c Radio
08000b80  w    F .text	00000002 VectorEC
20000800 g       .bss	00000000 _bss_start
08001220 g     F .text	0000004c chSchDoRescheduleBehind
08001db0 g     F .text	00000026 i2cDmaIrqHandler(void*, unsigned long)
08000b80  w    F .text	00000002 UsageFaultVector
08000b80  w    F .text	00000002 DebugMonitorVector
08000e10 g     F .text	00000028 dbg_check_unlock
08000b80  w    F .text	00000002 Vector40
08000d00 g     F .text	000000c0 ResetHandler
08000b80  w    F .text	00000002 VectorBC
08002080 g     F .text	0000007c i2c_t::Standby()
08000bc0 g     F .text	00000034 _port_init
08001760 g     F .text	00000064 hal_lld_init
08001370 g     F .text	00000024 chSemWait
08001620 g     F .text	00000048 chThdExitS
08000a90 g     F .text	0000004c cc1101_t::IGdo0IrqHandler()
20000e98 g     O .bss	00000408 dbg_trace_buffer
08000b80  w    F .text	00000002 PendSVVector
080006c0 g     F .text	0000016e cc1101_t::RfConfig()
08000250  w    F .text	00000026 Beeper_t::Beep(BeepChunk_t const*)
080016b0 g     F .text	00000050 chVTSetI
08000ae0 g     F .text	0000001c Vector64
20001380 g       .bss	00000000 _bss_end
200012a0 g     O .bss	00000004 dbg_panic_msg
08000cf0  w    F .text	00000002 _default_exit
08001d30 g     F .text	0000006c CmdUart_t::IRQDmaTxHandler()
08000b80  w    F .text	00000002 VectorCC
080027d0 g     F .text	00000024 Beeper_t::Init()
080012f0 g     F .text	00000020 chSemInit
08000b80  w    F .text	00000002 Vector54
08000b80  w    F .text	00000002 Vector98
08000440 g     F .text	00000098 rLevel1_t::Init(unsigned short)
080022e0 g     F .text	00000018 i2c_t::WaitBTF()
08000b80  w    F .text	00000002 VectorD8
080029d0 g     F .text	00000054 Vibro_t::Init()
08002300 g     F .text	00000198 i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)
08000b80  w    F .text	00000002 Vector24
08000f20 g     F .text	00000024 chDbgCheckClassI
080005f0 g     F .text	0000002c cc1101_t::WriteStrobe(unsigned char)
080012d0 g     F .text	00000018 chSchDoReschedule
08001420 g     F .text	0000006c chSysInit
080015f0 g     F .text	00000030 chThdSleep
08003170 g     O .text	00000054 _stm32_dma_streams
08001930 g     F .text	00000034 Vector84
08000c70 g     F .text	0000002a SysTickVector
08002af0 g     F .text	000000a4 PillMgr_t::Init()
200012a4 g     O .bss	00000004 dbg_isr_cnt
08002880 g     F .text	00000144 LedRGB_t::Init()
20000c0c g     O .bss	0000020c Uart
080024a0 g     F .text	00000144 i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)
08000b80  w    F .text	00000002 BusFaultVector
08000b80  w    F .text	00000002 VectorD0
08001a40 g     F .text	00000114 Clk_t::UpdateFreqValues()
08000830 g     F .text	00000248 cc1101_t::Init()
20000e30 g     O .bss	00000024 Beeper
08000b80  w    F .text	00000002 VectorE4
08000b80  w    F .text	00000002 VectorC0
08000ca0 g     F .text	00000010 _port_switch
08002c10 g     F .text	00000034 PillMgr_t::CheckIfConnected(unsigned char)
08002270 g     F .text	00000024 i2c_t::WaitEv5()
08001310 g     F .text	00000060 chSemWaitS
08000ba0 g     F .text	00000012 SVCallVector
08000ce0  w    F .text	00000002 __late_init
08002060 g     F .text	0000001c chDbgPanic
20001370 g     O .bss	00000010 vtlist
080005c0 g     F .text	00000030 cc1101_t::WriteRegister(unsigned char, unsigned char)
08000b80  w    F .text	00000002 HardFaultVector
08000c00 g     F .text	0000006c _port_irq_epilogue
08001c50 g     F .text	000000d4 CmdUart_t::Init(unsigned long)
08000280 g     F .text	00000038 App_t::IPillHandler()
08000310 g     F .text	00000050 App_t::Init()
08000f50 g     F .text	00000024 chDbgCheckClassS
08000b80  w    F .text	00000002 VectorF0
20000c00 g     O .bss	0000000c Clk
080004f0  w    F .text	00000010 Spi_t::ReadWriteByte(unsigned char)
08000ee0 g     F .text	00000038 dbg_check_leave_isr
080031c8 g       .textalign	00000000 _textdata
08000b80  w    F .text	00000002 VectorE0
08002800 g     F .text	0000004c Beeper_t::BeepI(BeepChunk_t const*)
08000b80  w    F .text	00000002 MemManageVector
080000f4 g       startup	00000000 __fini_array_start
20000b70 g     O .bss	0000001c CC
08002ca0 g     F .text	00000094 memset
08000100 g     F .text	00000108 main
080017d0 g     F .text	00000030 Vector6C
200012ac g     O .bss	0000001c rlist
08000b80  w    F .text	00000002 VectorA0
08000650 g     F .text	00000064 cc1101_t::ReceiveSync(unsigned long, rPkt_t*)
08000ea0 g     F .text	00000038 dbg_check_enter_isr
08002ba0 g     F .text	00000070 PillMgr_t::ResetBus()
080013a0 g     F .text	0000005c chSemSignal
080000f4 g       startup	00000000 __init_array_end
08000b80  w    F .text	00000002 VectorC4
080018b0 g     F .text	00000034 Vector7C
08002ab0 g     F .text	00000040 PillMgr_t::Deinit()
08001400 g     F .text	00000014 _idle_thread
08000b80  w    F .text	00000002 VectorB0
08002ee0 g     O .text	00000016 ch_debug
20000e6c g     O .bss	0000002c PillMgr
08000630 g     F .text	0000001e cc1101_t::SetChannel(unsigned char)
08000b80  w    F .text	00000002 Vector90
08000fe0 g     F .text	00000048 chEvtSignalI
200012a8 g     O .bss	00000004 dbg_lock_cnt
08001bd0 g     F .text	00000074 CmdUart_t::Printf(char const*, ...)
08000cb0 g     F .text	00000016 _port_thread_start
08000b80  w    F .text	00000002 Vector60
08000b80  w    F .text	00000002 Vector1C
08001270 g     F .text	0000005c chSchDoRescheduleAhead
08002100 g     F .text	000000d8 i2c_t::Resume()
08000b80  w    F .text	00000002 Vector48
20000400 g       .stacks	00000000 __process_stack_base__
08000500 g     F .text	00000018 cc1101_t::RSSI_dBm(unsigned char)
20000bfc g     O .bss	00000001 VCore
08001800 g     F .text	00000030 Vector70
08000b80  w    F .text	00000002 VectorD4
08000b50 g     F .text	00000026 nvicSetSystemHandlerPriority
08002670 g     F .text	00000160 kl_vsprintf
200012c8 g     O .bss	000000a8 _idle_thread_wa
20000800 g       .bss	00000000 _data
08001da0 g     F .text	0000000c CmdUartTxIrq
08000b80  w    F .text	00000002 Vector4C
080018f0 g     F .text	00000034 Vector80
08000b90 g     F .text	0000000e _port_switch_from_isr
08000b80  w    F .text	00000002 Vector68
08000f80 g     F .text	00000014 _trace_init
20000400 g       .stacks	00000000 __main_stack_end__
08001870 g     F .text	00000034 Vector78
20000800 g       .bss	00000000 _edata
08002040 g     F .text	0000001a PwmPin_t::SetFreqHz(unsigned long)
08001030 g     F .text	00000040 chEvtWaitAny
08001700 g     F .text	00000044 chVTResetI
08000b80 g     F .text	00000002 _unhandled_exception
08002c50 g     F .text	00000042 PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)
08000b80  w    F .text	00000002 Vector88
20000400 g       .stacks	00000000 __main_thread_stack_base__
08000a80 g     F .text	00000010 cc1101_t::IHandleAsync()
08000fa0 g     F .text	00000040 dbg_trace
080000f4 g       startup	00000000 __init_array_start
080022a0 g     F .text	0000001e i2c_t::WaitEv6()
08002a30 g     F .text	00000050 Vibro_t::IFlinchI(VibroChunk_t const*)
08000360 g     F .text	000000c0 rLevel1_t::ITask()
08001500 g     F .text	00000038 _thread_init
08000b80  w    F .text	00000002 Vector50
080019b0 g     F .text	00000088 dmaStreamAllocate
08000620  w    F .text	00000010 cc1101_t::EnterIdle()
20000000 g       .stacks	00000000 __main_stack_base__
08000b80  w    F .text	00000002 Vector44
08000b80  w    F .text	00000002 Vector28
08000b80  w    F .text	00000002 VectorB8
20000e54 g     O .bss	00000018 Led
08001ba0 g     F .text	0000001e CmdUart_t::IPutChar(char)
08000e70 g     F .text	0000002c dbg_check_unlock_from_isr
20000800 g       .stacks	00000000 __process_stack_end__
08000520 g     F .text	0000002c cc1101_t::ReadRegister(unsigned char)
08000b80  w    F .text	00000002 Vector34
08000cd0  w    F .text	00000002 __early_init
08000b80  w    F .text	00000002 VectorA4
08000b80  w    F .text	00000002 Vector20



Disassembly of section .text:

08000100 <main>:
main():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:27
int main(void) {
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V2);
    //Clk.SetupFlashLatency(24);  // Setup Flash Latency for clock in MHz
//    Clk.SetupBusDividers(ahbDiv1, apbDiv1, apbDiv1);
    Clk.UpdateFreqValues();
 8000100:	4c35      	ldr	r4, [pc, #212]	; (80001d8 <main+0xd8>)
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:22
#include "application.h"
#include "radio_lvl1.h"

static inline void Init();

int main(void) {
 8000102:	b507      	push	{r0, r1, r2, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:24
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V2);
 8000104:	2003      	movs	r0, #3
 8000106:	f001 fd2b 	bl	8001b60 <SetupVCore(VCore_t)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:27
    //Clk.SetupFlashLatency(24);  // Setup Flash Latency for clock in MHz
//    Clk.SetupBusDividers(ahbDiv1, apbDiv1, apbDiv1);
    Clk.UpdateFreqValues();
 800010a:	4620      	mov	r0, r4
 800010c:	f001 fc98 	bl	8001a40 <Clk_t::UpdateFreqValues()>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:30

    // ==== Init OS ====
    halInit();
 8000110:	f001 fb1e 	bl	8001750 <halInit>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:31
    chSysInit();
 8000114:	f001 f984 	bl	8001420 <chSysInit>
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:45
//        Beeper.Beep(BeepShort);
    } // while
}

void Init() {
    Uart.Init(115200);
 8000118:	4830      	ldr	r0, [pc, #192]	; (80001dc <main+0xdc>)
 800011a:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 800011e:	f001 fd97 	bl	8001c50 <CmdUart_t::Init(unsigned long)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:46
    Uart.Printf("ChibiArmlet AHB=%u; APB1=%u; APB2=%u\r", Clk.AHBFreqHz, Clk.APB1FreqHz, Clk.APB2FreqHz);
 8000122:	68a3      	ldr	r3, [r4, #8]
 8000124:	492e      	ldr	r1, [pc, #184]	; (80001e0 <main+0xe0>)
 8000126:	9300      	str	r3, [sp, #0]
 8000128:	e894 000c 	ldmia.w	r4, {r2, r3}
 800012c:	482b      	ldr	r0, [pc, #172]	; (80001dc <main+0xdc>)
_ZN8LedRGB_t7ISetRedEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:90

class LedRGB_t {
private:
    const LedChunk_t *IPFirstChunk;
    VirtualTimer ITmr;
    void ISetRed  (uint8_t AValue) {LED_TIM->LED_RED_CCR   = AValue;}
 800012e:	4c2d      	ldr	r4, [pc, #180]	; (80001e4 <main+0xe4>)
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:46
 8000130:	f001 fd4e 	bl	8001bd0 <CmdUart_t::Printf(char const*, ...)>
_ZN8LedRGB_t9ISetGreenEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:91
    void ISetGreen(uint8_t AValue) {LED_TIM->LED_GREEN_CCR = AValue;}
 8000134:	2500      	movs	r5, #0
_ZN8LedRGB_t7ISetRedEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:90

class LedRGB_t {
private:
    const LedChunk_t *IPFirstChunk;
    VirtualTimer ITmr;
    void ISetRed  (uint8_t AValue) {LED_TIM->LED_RED_CCR   = AValue;}
 8000136:	26ff      	movs	r6, #255	; 0xff
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:47
    Led.Init();
 8000138:	482b      	ldr	r0, [pc, #172]	; (80001e8 <main+0xe8>)
 800013a:	f002 fba1 	bl	8002880 <LedRGB_t::Init()>
_ZN8LedRGB_t7ISetRedEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:90
 800013e:	6426      	str	r6, [r4, #64]	; 0x40
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:49
    Led.SetColor(clRed);
    chThdSleepMilliseconds(450);
 8000140:	f44f 70e1 	mov.w	r0, #450	; 0x1c2
_ZN8LedRGB_t9ISetGreenEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:91
    void ISetGreen(uint8_t AValue) {LED_TIM->LED_GREEN_CCR = AValue;}
 8000144:	63e5      	str	r5, [r4, #60]	; 0x3c
_ZN8LedRGB_t8ISetBlueEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:92
    void ISetBlue (uint8_t AValue) {LED_TIM->LED_BLUE_CCR  = AValue;}
 8000146:	63a5      	str	r5, [r4, #56]	; 0x38
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:49
 8000148:	f001 fa52 	bl	80015f0 <chThdSleep>
_ZN8LedRGB_t7ISetRedEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:90

class LedRGB_t {
private:
    const LedChunk_t *IPFirstChunk;
    VirtualTimer ITmr;
    void ISetRed  (uint8_t AValue) {LED_TIM->LED_RED_CCR   = AValue;}
 800014c:	6425      	str	r5, [r4, #64]	; 0x40
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:51
    Led.SetColor(clGreen);
    chThdSleepMilliseconds(450);
 800014e:	f44f 70e1 	mov.w	r0, #450	; 0x1c2
_ZN8LedRGB_t9ISetGreenEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:91
    void ISetGreen(uint8_t AValue) {LED_TIM->LED_GREEN_CCR = AValue;}
 8000152:	63e6      	str	r6, [r4, #60]	; 0x3c
_ZN8LedRGB_t8ISetBlueEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:92
    void ISetBlue (uint8_t AValue) {LED_TIM->LED_BLUE_CCR  = AValue;}
 8000154:	63a5      	str	r5, [r4, #56]	; 0x38
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:51
 8000156:	f001 fa4b 	bl	80015f0 <chThdSleep>
_ZN8LedRGB_t7ISetRedEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:90

class LedRGB_t {
private:
    const LedChunk_t *IPFirstChunk;
    VirtualTimer ITmr;
    void ISetRed  (uint8_t AValue) {LED_TIM->LED_RED_CCR   = AValue;}
 800015a:	6425      	str	r5, [r4, #64]	; 0x40
_ZN8LedRGB_t9ISetGreenEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:91
    void ISetGreen(uint8_t AValue) {LED_TIM->LED_GREEN_CCR = AValue;}
 800015c:	63e5      	str	r5, [r4, #60]	; 0x3c
_ZN8LedRGB_t8ISetBlueEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:92
    void ISetBlue (uint8_t AValue) {LED_TIM->LED_BLUE_CCR  = AValue;}
 800015e:	63a6      	str	r6, [r4, #56]	; 0x38
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:54
    Led.SetColor(clBlue);
    chThdSleepMilliseconds(450);
    Beeper.Init();
 8000160:	4c22      	ldr	r4, [pc, #136]	; (80001ec <main+0xec>)
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:53
    Led.SetColor(clRed);
    chThdSleepMilliseconds(450);
    Led.SetColor(clGreen);
    chThdSleepMilliseconds(450);
    Led.SetColor(clBlue);
    chThdSleepMilliseconds(450);
 8000162:	f44f 70e1 	mov.w	r0, #450	; 0x1c2
 8000166:	f001 fa43 	bl	80015f0 <chThdSleep>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:54
    Beeper.Init();
 800016a:	4620      	mov	r0, r4
 800016c:	f002 fb30 	bl	80027d0 <Beeper_t::Init()>
_ZN8Beeper_t4BeepEPK11BeepChunk_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:31
    VirtualTimer ITmr;
    const BeepChunk_t *IPFirstChunk;
public:
    void BeepI(const BeepChunk_t *PSequence);
    void Beep(const BeepChunk_t *PSequence) {   // Beep with this function
        IPFirstChunk = PSequence;
 8000170:	4b1f      	ldr	r3, [pc, #124]	; (80001f0 <main+0xf0>)
 8000172:	6163      	str	r3, [r4, #20]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:32
        chSysLock();
 8000174:	2320      	movs	r3, #32
 8000176:	f383 8811 	msr	BASEPRI, r3
 800017a:	f000 fe31 	bl	8000de0 <dbg_check_lock>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:33
        BeepI(PSequence);
 800017e:	4620      	mov	r0, r4
 8000180:	491b      	ldr	r1, [pc, #108]	; (80001f0 <main+0xf0>)
 8000182:	f002 fb3d 	bl	8002800 <Beeper_t::BeepI(BeepChunk_t const*)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:34
        chSysUnlock();
 8000186:	f000 fe43 	bl	8000e10 <dbg_check_unlock>
 800018a:	2300      	movs	r3, #0
 800018c:	f383 8811 	msr	BASEPRI, r3
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:56
    Beeper.Beep(BeepBeep);
    Vibro.Init();
 8000190:	4c18      	ldr	r4, [pc, #96]	; (80001f4 <main+0xf4>)
 8000192:	4620      	mov	r0, r4
 8000194:	f002 fc1c 	bl	80029d0 <Vibro_t::Init()>
_ZN7Vibro_t6FlinchEPK12VibroChunk_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:138
private:
    VirtualTimer ITmr;
    const VibroChunk_t *IPFirstChunk;
public:
    void Flinch(const VibroChunk_t *PSequence) {   // Beep with this function
        IPFirstChunk = PSequence;
 8000198:	4b17      	ldr	r3, [pc, #92]	; (80001f8 <main+0xf8>)
 800019a:	6163      	str	r3, [r4, #20]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:139
        chSysLock();
 800019c:	2320      	movs	r3, #32
 800019e:	f383 8811 	msr	BASEPRI, r3
 80001a2:	f000 fe1d 	bl	8000de0 <dbg_check_lock>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:140
        IFlinchI(PSequence);
 80001a6:	4620      	mov	r0, r4
 80001a8:	4913      	ldr	r1, [pc, #76]	; (80001f8 <main+0xf8>)
 80001aa:	f002 fc41 	bl	8002a30 <Vibro_t::IFlinchI(VibroChunk_t const*)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:141
        chSysUnlock();
 80001ae:	f000 fe2f 	bl	8000e10 <dbg_check_unlock>
 80001b2:	2300      	movs	r3, #0
 80001b4:	f383 8811 	msr	BASEPRI, r3
Init():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:58
    Vibro.Flinch(BrrBrr);
    PillMgr.Init();
 80001b8:	4810      	ldr	r0, [pc, #64]	; (80001fc <main+0xfc>)
 80001ba:	f002 fc99 	bl	8002af0 <PillMgr_t::Init()>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:59
    Radio.Init(0);
 80001be:	4810      	ldr	r0, [pc, #64]	; (8000200 <main+0x100>)
 80001c0:	2100      	movs	r1, #0
 80001c2:	f000 f93d 	bl	8000440 <rLevel1_t::Init(unsigned short)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:61

    App.Init();
 80001c6:	480f      	ldr	r0, [pc, #60]	; (8000204 <main+0x104>)
 80001c8:	f000 f8a2 	bl	8000310 <App_t::Init()>
main():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/main.cpp:38 (discriminator 1)
    Init();
//    if(ClkResult) Uart.Printf("Clock failure\r");

    while(1) {
        //chThdSleep(TIME_INFINITE);
        chThdSleepMilliseconds(2007);
 80001cc:	f240 70d7 	movw	r0, #2007	; 0x7d7
 80001d0:	f001 fa0e 	bl	80015f0 <chThdSleep>
 80001d4:	e7fa      	b.n	80001cc <main+0xcc>
 80001d6:	bf00      	nop
 80001d8:	20000c00 	.word	0x20000c00
 80001dc:	20000c0c 	.word	0x20000c0c
 80001e0:	08002dd0 	.word	0x08002dd0
 80001e4:	40000400 	.word	0x40000400
 80001e8:	20000e54 	.word	0x20000e54
 80001ec:	20000e30 	.word	0x20000e30
 80001f0:	08002db0 	.word	0x08002db0
 80001f4:	20000e18 	.word	0x20000e18
 80001f8:	08002da0 	.word	0x08002da0
 80001fc:	20000e6c 	.word	0x20000e6c
 8000200:	200009bc 	.word	0x200009bc
 8000204:	200009b8 	.word	0x200009b8
	...

08000210 <TmrPillCheckCallback(void*)>:
_Z20TmrPillCheckCallbackPv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:161
    chSysLockFromIsr();
    chEvtSignalI(App.PThd, EVTMSK_DOSE_STORE);
    chVTSetI(&ITmrDoseSave,  MS2ST(TM_DOSE_SAVE_MS),     TmrDoseSaveCallback, nullptr);
    chSysUnlockFromIsr();
}
void TmrPillCheckCallback(void *p) {
 8000210:	b508      	push	{r3, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:162
    chSysLockFromIsr();
 8000212:	2320      	movs	r3, #32
 8000214:	f383 8811 	msr	BASEPRI, r3
 8000218:	f000 fe12 	bl	8000e40 <dbg_check_lock_from_isr>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:163
    chEvtSignalI(App.PThd, EVTMSK_PILL_CHECK);
 800021c:	4b08      	ldr	r3, [pc, #32]	; (8000240 <TmrPillCheckCallback(void*)+0x30>)
 800021e:	2104      	movs	r1, #4
 8000220:	6818      	ldr	r0, [r3, #0]
 8000222:	f000 fedd 	bl	8000fe0 <chEvtSignalI>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:164
    chVTSetI(&ITmrPillCheck, MS2ST(TM_PILL_CHECK_MS),    TmrPillCheckCallback, nullptr);
 8000226:	4807      	ldr	r0, [pc, #28]	; (8000244 <TmrPillCheckCallback(void*)+0x34>)
 8000228:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
 800022c:	4a06      	ldr	r2, [pc, #24]	; (8000248 <TmrPillCheckCallback(void*)+0x38>)
 800022e:	2300      	movs	r3, #0
 8000230:	f001 fa3e 	bl	80016b0 <chVTSetI>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:165
    chSysUnlockFromIsr();
 8000234:	f000 fe1c 	bl	8000e70 <dbg_check_unlock_from_isr>
 8000238:	2300      	movs	r3, #0
 800023a:	f383 8811 	msr	BASEPRI, r3
 800023e:	bd08      	pop	{r3, pc}
 8000240:	200009b8 	.word	0x200009b8
 8000244:	20000808 	.word	0x20000808
 8000248:	08000211 	.word	0x08000211
$d():
 800024c:	00000000 	.word	0x00000000

08000250 <Beeper_t::Beep(BeepChunk_t const*)>:
_ZN8Beeper_t4BeepEPK11BeepChunk_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:30
private:
    VirtualTimer ITmr;
    const BeepChunk_t *IPFirstChunk;
public:
    void BeepI(const BeepChunk_t *PSequence);
    void Beep(const BeepChunk_t *PSequence) {   // Beep with this function
 8000250:	b538      	push	{r3, r4, r5, lr}
 8000252:	4605      	mov	r5, r0
 8000254:	460c      	mov	r4, r1
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:31
        IPFirstChunk = PSequence;
 8000256:	6169      	str	r1, [r5, #20]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:32
        chSysLock();
 8000258:	2320      	movs	r3, #32
 800025a:	f383 8811 	msr	BASEPRI, r3
 800025e:	f000 fdbf 	bl	8000de0 <dbg_check_lock>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:33
        BeepI(PSequence);
 8000262:	4628      	mov	r0, r5
 8000264:	4621      	mov	r1, r4
 8000266:	f002 facb 	bl	8002800 <Beeper_t::BeepI(BeepChunk_t const*)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:34
        chSysUnlock();
 800026a:	f000 fdd1 	bl	8000e10 <dbg_check_unlock>
 800026e:	2300      	movs	r3, #0
 8000270:	f383 8811 	msr	BASEPRI, r3
 8000274:	bd38      	pop	{r3, r4, r5, pc}
	...

08000280 <App_t::IPillHandler()>:
_ZN5App_t12IPillHandlerEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:117
    uint16_t Charge;
    uint32_t Value;
} __attribute__ ((__packed__));
static Pill_t Pill;

void App_t::IPillHandler() {
 8000280:	b508      	push	{r3, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:119
    // Read med
    if(PillMgr.Read(PILL_I2C_ADDR, (uint8_t*)&Pill, sizeof(Pill_t)) != OK) return;
 8000282:	4809      	ldr	r0, [pc, #36]	; (80002a8 <App_t::IPillHandler()+0x28>)
 8000284:	2150      	movs	r1, #80	; 0x50
 8000286:	4a09      	ldr	r2, [pc, #36]	; (80002ac <App_t::IPillHandler()+0x2c>)
 8000288:	2308      	movs	r3, #8
 800028a:	f002 fce1 	bl	8002c50 <PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)>
 800028e:	b948      	cbnz	r0, 80002a4 <App_t::IPillHandler()+0x24>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:139
//            Dose.ChangeIndication();
//            return;
//        }
//    } // if Cure
    // Will be here in case of strange/discharged pill
    Beeper.Beep(BeepPillBad);
 8000290:	4807      	ldr	r0, [pc, #28]	; (80002b0 <App_t::IPillHandler()+0x30>)
 8000292:	4908      	ldr	r1, [pc, #32]	; (80002b4 <App_t::IPillHandler()+0x34>)
 8000294:	f7ff ffdc 	bl	8000250 <Beeper_t::Beep(BeepChunk_t const*)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:143
//    Led.StartBlink(LedPillBad);
    chThdSleep(2007);    // Let indication to complete
//    Dose.ChangeIndication();
}
 8000298:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:141
//        }
//    } // if Cure
    // Will be here in case of strange/discharged pill
    Beeper.Beep(BeepPillBad);
//    Led.StartBlink(LedPillBad);
    chThdSleep(2007);    // Let indication to complete
 800029c:	f240 70d7 	movw	r0, #2007	; 0x7d7
 80002a0:	f001 b9a6 	b.w	80015f0 <chThdSleep>
 80002a4:	bd08      	pop	{r3, pc}
 80002a6:	bf00      	nop
 80002a8:	20000e6c 	.word	0x20000e6c
 80002ac:	20000800 	.word	0x20000800
 80002b0:	20000e30 	.word	0x20000e30
 80002b4:	08002d70 	.word	0x08002d70
	...

080002c0 <AppThread(void*)>:
AppThread():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:172
#endif

#if 1 // ========================= Application =================================
static WORKING_AREA(waAppThread, 256);
__attribute__((noreturn))
static void AppThread(void *arg) {
 80002c0:	b508      	push	{r3, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:173
    chRegSetThreadName("App");
 80002c2:	4b0c      	ldr	r3, [pc, #48]	; (80002f4 <AppThread(void*)+0x34>)
 80002c4:	4a0c      	ldr	r2, [pc, #48]	; (80002f8 <AppThread(void*)+0x38>)
 80002c6:	699b      	ldr	r3, [r3, #24]
 80002c8:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:201
                if(!PillConnected) {
                    PillConnected = true;
                    App.IPillHandler();
                }
            }
            else PillConnected = false;
 80002ca:	2400      	movs	r4, #0
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:177
static void AppThread(void *arg) {
    chRegSetThreadName("App");
    uint32_t EvtMsk;
    bool PillConnected = false;
    while(true) {
        EvtMsk = chEvtWaitAny(ALL_EVENTS);
 80002cc:	f04f 30ff 	mov.w	r0, #4294967295
 80002d0:	f000 feae 	bl	8001030 <chEvtWaitAny>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:193
//        if(EvtMsk & EVTMSK_DOSE_STORE) {
//            //if(Dose.Save() != OK) Uart.Printf("EE Fail\r");   // DEBUG
//        }

        // ==== Check pill ====
        if(EvtMsk & EVTMSK_PILL_CHECK) {
 80002d4:	0743      	lsls	r3, r0, #29
 80002d6:	d5f9      	bpl.n	80002cc <AppThread(void*)+0xc>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:195
            // Check if new connection occured
            if(PillMgr.CheckIfConnected(PILL_I2C_ADDR) == OK) {
 80002d8:	4808      	ldr	r0, [pc, #32]	; (80002fc <AppThread(void*)+0x3c>)
 80002da:	2150      	movs	r1, #80	; 0x50
 80002dc:	f002 fc98 	bl	8002c10 <PillMgr_t::CheckIfConnected(unsigned char)>
 80002e0:	2800      	cmp	r0, #0
 80002e2:	d1f2      	bne.n	80002ca <AppThread(void*)+0xa>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:196
                if(!PillConnected) {
 80002e4:	2c00      	cmp	r4, #0
 80002e6:	d1f1      	bne.n	80002cc <AppThread(void*)+0xc>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:198
                    PillConnected = true;
                    App.IPillHandler();
 80002e8:	4805      	ldr	r0, [pc, #20]	; (8000300 <AppThread(void*)+0x40>)
 80002ea:	f7ff ffc9 	bl	8000280 <App_t::IPillHandler()>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:197
        // ==== Check pill ====
        if(EvtMsk & EVTMSK_PILL_CHECK) {
            // Check if new connection occured
            if(PillMgr.CheckIfConnected(PILL_I2C_ADDR) == OK) {
                if(!PillConnected) {
                    PillConnected = true;
 80002ee:	2401      	movs	r4, #1
 80002f0:	e7ec      	b.n	80002cc <AppThread(void*)+0xc>
 80002f2:	bf00      	nop
 80002f4:	200012ac 	.word	0x200012ac
 80002f8:	08002d99 	.word	0x08002d99
 80002fc:	20000e6c 	.word	0x20000e6c
 8000300:	200009b8 	.word	0x200009b8
	...

08000310 <App_t::Init()>:
_ZN5App_t4InitEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:206
            else PillConnected = false;
        } // if EVTMSK_PILL_CHECK
    } // while 1
}

void App_t::Init() {
 8000310:	b513      	push	{r0, r1, r4, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:209
    //Dose.Load();
//    Uart.Printf("Dose = %u\r", Dose.Get());
    PThd = chThdCreateStatic(waAppThread, sizeof(waAppThread), NORMALPRIO, (tfunc_t)AppThread, NULL);
 8000312:	2300      	movs	r3, #0
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:206
            else PillConnected = false;
        } // if EVTMSK_PILL_CHECK
    } // while 1
}

void App_t::Init() {
 8000314:	4604      	mov	r4, r0
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:209
    //Dose.Load();
//    Uart.Printf("Dose = %u\r", Dose.Get());
    PThd = chThdCreateStatic(waAppThread, sizeof(waAppThread), NORMALPRIO, (tfunc_t)AppThread, NULL);
 8000316:	9300      	str	r3, [sp, #0]
 8000318:	f44f 71cc 	mov.w	r1, #408	; 0x198
 800031c:	2240      	movs	r2, #64	; 0x40
 800031e:	4b0c      	ldr	r3, [pc, #48]	; (8000350 <App_t::Init()+0x40>)
 8000320:	480c      	ldr	r0, [pc, #48]	; (8000354 <App_t::Init()+0x44>)
 8000322:	f001 f935 	bl	8001590 <chThdCreateStatic>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:211
    // Timers init
    chSysLock();
 8000326:	2320      	movs	r3, #32
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:209
}

void App_t::Init() {
    //Dose.Load();
//    Uart.Printf("Dose = %u\r", Dose.Get());
    PThd = chThdCreateStatic(waAppThread, sizeof(waAppThread), NORMALPRIO, (tfunc_t)AppThread, NULL);
 8000328:	6020      	str	r0, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:211
    // Timers init
    chSysLock();
 800032a:	f383 8811 	msr	BASEPRI, r3
 800032e:	f000 fd57 	bl	8000de0 <dbg_check_lock>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:214
//    chVTSetI(&ITmrDose,      MS2ST(TM_DOSE_INCREASE_MS), TmrDoseCallback, nullptr);
//    chVTSetI(&ITmrDoseSave,  MS2ST(TM_DOSE_SAVE_MS),     TmrDoseSaveCallback, nullptr);
    chVTSetI(&ITmrPillCheck, MS2ST(TM_PILL_CHECK_MS),    TmrPillCheckCallback, nullptr);
 8000332:	4809      	ldr	r0, [pc, #36]	; (8000358 <App_t::Init()+0x48>)
 8000334:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
 8000338:	4a08      	ldr	r2, [pc, #32]	; (800035c <App_t::Init()+0x4c>)
 800033a:	2300      	movs	r3, #0
 800033c:	f001 f9b8 	bl	80016b0 <chVTSetI>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:215
    chSysUnlock();
 8000340:	f000 fd66 	bl	8000e10 <dbg_check_unlock>
 8000344:	2300      	movs	r3, #0
 8000346:	f383 8811 	msr	BASEPRI, r3
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/application.cpp:216
}
 800034a:	b002      	add	sp, #8
 800034c:	bd10      	pop	{r4, pc}
 800034e:	bf00      	nop
 8000350:	080002c1 	.word	0x080002c1
 8000354:	20000820 	.word	0x20000820
 8000358:	20000808 	.word	0x20000808
 800035c:	08000211 	.word	0x08000211

08000360 <rLevel1_t::ITask()>:
_ZN9rLevel1_t5ITaskEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:39
}

//#define TX
#define LED_RX

void rLevel1_t::ITask() {
 8000360:	b570      	push	{r4, r5, r6, lr}
 8000362:	4605      	mov	r5, r0
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:66
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 8000364:	4c29      	ldr	r4, [pc, #164]	; (800040c <rLevel1_t::ITask()+0xac>)
 8000366:	7823      	ldrb	r3, [r4, #0]
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:63
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 8000368:	4620      	mov	r0, r4
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:66
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
 800036a:	b12b      	cbz	r3, 8000378 <rLevel1_t::ITask()+0x18>
_ZN8cc1101_t9EnterIdleEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:63
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 800036c:	2136      	movs	r1, #54	; 0x36
 800036e:	f000 f93f 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
 8000372:	2300      	movs	r3, #0
 8000374:	7623      	strb	r3, [r4, #24]
 8000376:	e7f5      	b.n	8000364 <rLevel1_t::ITask()+0x4>
_ZN8cc1101_t11RecalibrateEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:67
    void Sleep() { WriteStrobe(CC_SPWD); State = ccSleeping; }
    void Recalibrate() {
        while(IState != CC_STB_IDLE) EnterIdle();
        WriteStrobe(CC_SCAL);
 8000378:	2133      	movs	r1, #51	; 0x33
 800037a:	f000 f939 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
PinIsSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:127
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 800037e:	4b24      	ldr	r3, [pc, #144]	; (8000410 <rLevel1_t::ITask()+0xb0>)
 8000380:	8a1e      	ldrh	r6, [r3, #16]
 8000382:	f006 0640 	and.w	r6, r6, #64	; 0x40
_ZN8cc1101_t8BusyWaitEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:36
    PinIrq_t IGdo0;
    void CsHi() { PinSet(CC_GPIO, CC_CS); }
    void CsLo() { PinClear(CC_GPIO, CC_CS); }
    bool GDO0IsHi() { return PinIsSet(CC_GPIO, CC_GDO0); }
    bool GDO2IsHi() { return PinIsSet(CC_GPIO, CC_GDO2); }
    void BusyWait() { while(PinIsSet(CC_GPIO, CC_MISO)); }
 8000386:	b2b6      	uxth	r6, r6
 8000388:	2e00      	cmp	r6, #0
 800038a:	d1f8      	bne.n	800037e <rLevel1_t::ITask()+0x1e>
_ZN9rLevel1_t5ITaskEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:52
        CC.TransmitSync(&PktTx);
        DBG1_CLR();
        chThdSleepMilliseconds(99);
#elif defined LED_RX
        Color_t Clr;
        uint8_t RxRslt = CC.ReceiveSync(306, &PktRx);
 800038c:	481f      	ldr	r0, [pc, #124]	; (800040c <rLevel1_t::ITask()+0xac>)
 800038e:	f44f 7199 	mov.w	r1, #306	; 0x132
 8000392:	462a      	mov	r2, r5
 8000394:	f000 f95c 	bl	8000650 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:53
        if(RxRslt == OK) {
 8000398:	4604      	mov	r4, r0
 800039a:	b9e8      	cbnz	r0, 80003d8 <rLevel1_t::ITask()+0x78>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:54
            Uart.Printf("%d\r", PktRx.RSSI);
 800039c:	491d      	ldr	r1, [pc, #116]	; (8000414 <rLevel1_t::ITask()+0xb4>)
 800039e:	481e      	ldr	r0, [pc, #120]	; (8000418 <rLevel1_t::ITask()+0xb8>)
 80003a0:	f995 2005 	ldrsb.w	r2, [r5, #5]
 80003a4:	f001 fc14 	bl	8001bd0 <CmdUart_t::Printf(char const*, ...)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:56
            Clr = clWhite;
            if     (PktRx.RSSI < -100) Clr = clRed;
 80003a8:	f995 1005 	ldrsb.w	r1, [r5, #5]
 80003ac:	f111 0f64 	cmn.w	r1, #100	; 0x64
 80003b0:	db15      	blt.n	80003de <rLevel1_t::ITask()+0x7e>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:57
            else if(PktRx.RSSI < -90) Clr = clYellow;
 80003b2:	f111 0f5a 	cmn.w	r1, #90	; 0x5a
 80003b6:	db16      	blt.n	80003e6 <rLevel1_t::ITask()+0x86>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:58
            else if(PktRx.RSSI < -80) Clr = clGreen;
 80003b8:	f111 0f50 	cmn.w	r1, #80	; 0x50
 80003bc:	db16      	blt.n	80003ec <rLevel1_t::ITask()+0x8c>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:59
            else if(PktRx.RSSI < -70) Clr = clCyan;
 80003be:	f111 0f46 	cmn.w	r1, #70	; 0x46
 80003c2:	db17      	blt.n	80003f4 <rLevel1_t::ITask()+0x94>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:60
            else if(PktRx.RSSI < -60) Clr = clBlue;
 80003c4:	f111 0f3c 	cmn.w	r1, #60	; 0x3c
 80003c8:	db17      	blt.n	80003fa <rLevel1_t::ITask()+0x9a>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:61
            else if(PktRx.RSSI < -50) Clr = clMagenta;
 80003ca:	f111 0f32 	cmn.w	r1, #50	; 0x32
 80003ce:	bfac      	ite	ge
 80003d0:	21ff      	movge	r1, #255	; 0xff
 80003d2:	2100      	movlt	r1, #0
 80003d4:	23ff      	movs	r3, #255	; 0xff
 80003d6:	e00b      	b.n	80003f0 <rLevel1_t::ITask()+0x90>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:63
        }
        else Clr = clBlack;
 80003d8:	4633      	mov	r3, r6
 80003da:	4631      	mov	r1, r6
 80003dc:	e008      	b.n	80003f0 <rLevel1_t::ITask()+0x90>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:56
        Color_t Clr;
        uint8_t RxRslt = CC.ReceiveSync(306, &PktRx);
        if(RxRslt == OK) {
            Uart.Printf("%d\r", PktRx.RSSI);
            Clr = clWhite;
            if     (PktRx.RSSI < -100) Clr = clRed;
 80003de:	4623      	mov	r3, r4
 80003e0:	4621      	mov	r1, r4
 80003e2:	24ff      	movs	r4, #255	; 0xff
 80003e4:	e00c      	b.n	8000400 <rLevel1_t::ITask()+0xa0>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:57
            else if(PktRx.RSSI < -90) Clr = clYellow;
 80003e6:	4623      	mov	r3, r4
 80003e8:	21ff      	movs	r1, #255	; 0xff
 80003ea:	e008      	b.n	80003fe <rLevel1_t::ITask()+0x9e>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:58
            else if(PktRx.RSSI < -80) Clr = clGreen;
 80003ec:	4623      	mov	r3, r4
 80003ee:	21ff      	movs	r1, #255	; 0xff
 80003f0:	461c      	mov	r4, r3
 80003f2:	e005      	b.n	8000400 <rLevel1_t::ITask()+0xa0>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:59
            else if(PktRx.RSSI < -70) Clr = clCyan;
 80003f4:	23ff      	movs	r3, #255	; 0xff
 80003f6:	4619      	mov	r1, r3
 80003f8:	e002      	b.n	8000400 <rLevel1_t::ITask()+0xa0>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:60
            else if(PktRx.RSSI < -60) Clr = clBlue;
 80003fa:	23ff      	movs	r3, #255	; 0xff
 80003fc:	4621      	mov	r1, r4
 80003fe:	460c      	mov	r4, r1
_ZN8LedRGB_t7ISetRedEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:90

class LedRGB_t {
private:
    const LedChunk_t *IPFirstChunk;
    VirtualTimer ITmr;
    void ISetRed  (uint8_t AValue) {LED_TIM->LED_RED_CCR   = AValue;}
 8000400:	4a06      	ldr	r2, [pc, #24]	; (800041c <rLevel1_t::ITask()+0xbc>)
 8000402:	6414      	str	r4, [r2, #64]	; 0x40
_ZN8LedRGB_t9ISetGreenEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:91
    void ISetGreen(uint8_t AValue) {LED_TIM->LED_GREEN_CCR = AValue;}
 8000404:	63d1      	str	r1, [r2, #60]	; 0x3c
_ZN8LedRGB_t8ISetBlueEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/peripheral.h:92
    void ISetBlue (uint8_t AValue) {LED_TIM->LED_BLUE_CCR  = AValue;}
 8000406:	6393      	str	r3, [r2, #56]	; 0x38
_ZN9rLevel1_t5ITaskEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:70
#else
        IterateEmanators();
//        Uart.Printf("%d\r", Damage);
        chThdSleepMilliseconds(45);
#endif
    } // while true
 8000408:	e7ac      	b.n	8000364 <rLevel1_t::ITask()+0x4>
 800040a:	bf00      	nop
 800040c:	20000b70 	.word	0x20000b70
 8000410:	40020000 	.word	0x40020000
 8000414:	08002e00 	.word	0x08002e00
 8000418:	20000c0c 	.word	0x20000c0c
 800041c:	40000400 	.word	0x40000400

08000420 <rLvl1Thread(void*)>:
rLvl1Thread():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:31
rLevel1_t Radio;

#if 1 // ================================ Task =================================
static WORKING_AREA(warLvl1Thread, 256);
__attribute__((noreturn))
static void rLvl1Thread(void *arg) {
 8000420:	b508      	push	{r3, lr}
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:32
    chRegSetThreadName("rLvl1");
 8000422:	4b03      	ldr	r3, [pc, #12]	; (8000430 <rLvl1Thread(void*)+0x10>)
 8000424:	4a03      	ldr	r2, [pc, #12]	; (8000434 <rLvl1Thread(void*)+0x14>)
 8000426:	699b      	ldr	r3, [r3, #24]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:33
    while(true) Radio.ITask();
 8000428:	4803      	ldr	r0, [pc, #12]	; (8000438 <rLvl1Thread(void*)+0x18>)
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:32

#if 1 // ================================ Task =================================
static WORKING_AREA(warLvl1Thread, 256);
__attribute__((noreturn))
static void rLvl1Thread(void *arg) {
    chRegSetThreadName("rLvl1");
 800042a:	619a      	str	r2, [r3, #24]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:33
    while(true) Radio.ITask();
 800042c:	f7ff ff98 	bl	8000360 <rLevel1_t::ITask()>
 8000430:	200012ac 	.word	0x200012ac
 8000434:	08002e04 	.word	0x08002e04
 8000438:	200009bc 	.word	0x200009bc
$d():
 800043c:	00000000 	.word	0x00000000

08000440 <rLevel1_t::Init(unsigned short)>:
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8000440:	4b21      	ldr	r3, [pc, #132]	; (80004c8 <rLevel1_t::Init(unsigned short)+0x88>)
_ZN9rLevel1_t4InitEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:76
}

#endif

#if 1 // ============================
void rLevel1_t::Init(uint16_t ASelfID) {
 8000442:	b537      	push	{r0, r1, r2, r4, r5, lr}
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8000444:	69da      	ldr	r2, [r3, #28]
_ZN9rLevel1_t4InitEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:81
#ifdef DBG_PINS
    PinSetupOut(DBG_GPIO1, DBG_PIN1, omPushPull);
#endif
    // Init radioIC
    CC.Init();
 8000446:	4c21      	ldr	r4, [pc, #132]	; (80004cc <rLevel1_t::Init(unsigned short)+0x8c>)
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8000448:	f042 0202 	orr.w	r2, r2, #2
 800044c:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800044e:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 8000452:	681a      	ldr	r2, [r3, #0]
_ZN9rLevel1_t4InitEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:76
}

#endif

#if 1 // ============================
void rLevel1_t::Init(uint16_t ASelfID) {
 8000454:	4605      	mov	r5, r0
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
 8000456:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800045a:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 800045c:	681a      	ldr	r2, [r3, #0]
_ZN9rLevel1_t4InitEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:81
#ifdef DBG_PINS
    PinSetupOut(DBG_GPIO1, DBG_PIN1, omPushPull);
#endif
    // Init radioIC
    CC.Init();
 800045e:	4620      	mov	r0, r4
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
 8000460:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000464:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000466:	889a      	ldrh	r2, [r3, #4]
 8000468:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800046c:	0412      	lsls	r2, r2, #16
 800046e:	0c12      	lsrs	r2, r2, #16
 8000470:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000472:	889a      	ldrh	r2, [r3, #4]
 8000474:	b292      	uxth	r2, r2
 8000476:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000478:	68da      	ldr	r2, [r3, #12]
 800047a:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800047e:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000480:	68da      	ldr	r2, [r3, #12]
 8000482:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000484:	689a      	ldr	r2, [r3, #8]
 8000486:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800048a:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800048c:	689a      	ldr	r2, [r3, #8]
 800048e:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8000492:	609a      	str	r2, [r3, #8]
_ZN9rLevel1_t4InitEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:81
 8000494:	f000 f9cc 	bl	8000830 <cc1101_t::Init()>
_ZN8cc1101_t10SetTxPowerEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Radio/cc1101.h:57
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
public:
    CCState_t State;
    void Init();
    void SetChannel(uint8_t AChannel);
    void SetTxPower(uint8_t APwr) { WriteRegister(CC_PATABLE, APwr); }
 8000498:	4620      	mov	r0, r4
 800049a:	2250      	movs	r2, #80	; 0x50
 800049c:	213e      	movs	r1, #62	; 0x3e
 800049e:	f000 f88f 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
_ZN9rLevel1_t4InitEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:83
    CC.SetTxPower(CC_Pwr0dBm);
    CC.SetChannel(CHANNEL_ZERO);
 80004a2:	4620      	mov	r0, r4
 80004a4:	2100      	movs	r1, #0
 80004a6:	f000 f8c3 	bl	8000630 <cc1101_t::SetChannel(unsigned char)>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:85
    // Variables
    Damage = 1;
 80004aa:	2301      	movs	r3, #1
 80004ac:	61ab      	str	r3, [r5, #24]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:87
    // Thread
    PThread = chThdCreateStatic(warLvl1Thread, sizeof(warLvl1Thread), HIGHPRIO, (tfunc_t)rLvl1Thread, NULL);
 80004ae:	2300      	movs	r3, #0
 80004b0:	9300      	str	r3, [sp, #0]
 80004b2:	f44f 71cc 	mov.w	r1, #408	; 0x198
 80004b6:	227f      	movs	r2, #127	; 0x7f
 80004b8:	4b05      	ldr	r3, [pc, #20]	; (80004d0 <rLevel1_t::Init(unsigned short)+0x90>)
 80004ba:	4806      	ldr	r0, [pc, #24]	; (80004d4 <rLevel1_t::Init(unsigned short)+0x94>)
 80004bc:	f001 f868 	bl	8001590 <chThdCreateStatic>
 80004c0:	60e8      	str	r0, [r5, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../src/radio_lvl1.cpp:88
}
 80004c2:	b003      	add	sp, #12
 80004c4:	bd30      	pop	{r4, r5, pc}
 80004c6:	bf00      	nop
 80004c8:	40023800 	.word	0x40023800
 80004cc:	20000b70 	.word	0x20000b70
 80004d0:	08000421 	.word	0x08000421
 80004d4:	200009d8 	.word	0x200009d8
	...

080004e0 <cc1101_t::BusyWait() [clone .isra.6]>:
PinIsSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:127
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 80004e0:	4b02      	ldr	r3, [pc, #8]	; (80004ec <cc1101_t::BusyWait() [clone .isra.6]+0xc>)
 80004e2:	8a1b      	ldrh	r3, [r3, #16]
_ZN8cc1101_t8BusyWaitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:36
    PinIrq_t IGdo0;
    void CsHi() { PinSet(CC_GPIO, CC_CS); }
    void CsLo() { PinClear(CC_GPIO, CC_CS); }
    bool GDO0IsHi() { return PinIsSet(CC_GPIO, CC_GDO0); }
    bool GDO2IsHi() { return PinIsSet(CC_GPIO, CC_GDO2); }
    void BusyWait() { while(PinIsSet(CC_GPIO, CC_MISO)); }
 80004e4:	065b      	lsls	r3, r3, #25
 80004e6:	d4fb      	bmi.n	80004e0 <cc1101_t::BusyWait() [clone .isra.6]>
 80004e8:	4770      	bx	lr
 80004ea:	bf00      	nop
 80004ec:	40020000 	.word	0x40020000

080004f0 <Spi_t::ReadWriteByte(unsigned char)>:
_ZN5Spi_t13ReadWriteByteEh():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:427
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
    void Disable() { PSpi->CR1 &= ~SPI_CR1_SPE; }
    void EnableTxDma() { PSpi->CR2 |= SPI_CR2_TXDMAEN; }
    void WaitBsyHi2Lo() { while(PSpi->SR & SPI_SR_BSY); }
    uint8_t ReadWriteByte(uint8_t AByte) {
        PSpi->DR = AByte;
 80004f0:	6803      	ldr	r3, [r0, #0]
 80004f2:	8199      	strh	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:428 (discriminator 1)
        while(!(PSpi->SR & SPI_SR_RXNE));  // Wait for SPI transmission to complete
 80004f4:	891a      	ldrh	r2, [r3, #8]
 80004f6:	07d2      	lsls	r2, r2, #31
 80004f8:	d5fc      	bpl.n	80004f4 <Spi_t::ReadWriteByte(unsigned char)+0x4>
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:429
        return PSpi->DR;
 80004fa:	8998      	ldrh	r0, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:430
    }
 80004fc:	b2c0      	uxtb	r0, r0
 80004fe:	4770      	bx	lr

08000500 <cc1101_t::RSSI_dBm(unsigned char)>:
_ZN8cc1101_t8RSSI_dBmEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:105
}

// Return RSSI in dBm
int8_t cc1101_t::RSSI_dBm(uint8_t ARawRSSI) {
    int16_t RSSI = ARawRSSI;
    if (RSSI >= 128) RSSI -= 256;
 8000500:	297f      	cmp	r1, #127	; 0x7f
 8000502:	bfc4      	itt	gt
 8000504:	f5a1 7180 	subgt.w	r1, r1, #256	; 0x100
 8000508:	b289      	uxthgt	r1, r1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:106
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
 800050a:	b208      	sxth	r0, r1
 800050c:	2302      	movs	r3, #2
 800050e:	fb90 f0f3 	sdiv	r0, r0, r3
 8000512:	384a      	subs	r0, #74	; 0x4a
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:108
    return RSSI;
}
 8000514:	b240      	sxtb	r0, r0
 8000516:	4770      	bx	lr
	...

08000520 <cc1101_t::ReadRegister(unsigned char)>:
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:137
     }
     else return FAILURE;
}

// =========================== Registers & Strobes =============================
uint8_t cc1101_t::ReadRegister (uint8_t ARegAddr){
 8000520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000522:	4c09      	ldr	r4, [pc, #36]	; (8000548 <cc1101_t::ReadRegister(unsigned char)+0x28>)
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:137
 8000524:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 8000526:	2510      	movs	r5, #16
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:137
 8000528:	460f      	mov	r7, r1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:140
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
 800052a:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 800052c:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:139
}

// =========================== Registers & Strobes =============================
uint8_t cc1101_t::ReadRegister (uint8_t ARegAddr){
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 800052e:	f7ff ffd7 	bl	80004e0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:140
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
 8000532:	f047 0180 	orr.w	r1, r7, #128	; 0x80
 8000536:	4630      	mov	r0, r6
 8000538:	f7ff ffda 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:141
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
 800053c:	4630      	mov	r0, r6
 800053e:	2100      	movs	r1, #0
 8000540:	f7ff ffd6 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8000544:	8325      	strh	r5, [r4, #24]
_ZN8cc1101_t12ReadRegisterEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:144
    CsHi();                                 // End transmission
    return FReply;
}
 8000546:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000548:	40020000 	.word	0x40020000
$d():
 800054c:	00000000 	.word	0x00000000

08000550 <cc1101_t::ReadFIFO(rPkt_t*)>:
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:111
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
    return RSSI;
}


uint8_t cc1101_t::ReadFIFO(rPkt_t *pPkt) {
 8000550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000552:	460e      	mov	r6, r1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:114
    uint8_t b, *p = (uint8_t*)pPkt;
     // Check if received successfully
     b = ReadRegister(CC_PKTSTATUS);
 8000554:	2178      	movs	r1, #120	; 0x78
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:111
    RSSI = (RSSI / 2) - 74;    // now it is in dBm
    return RSSI;
}


uint8_t cc1101_t::ReadFIFO(rPkt_t *pPkt) {
 8000556:	4607      	mov	r7, r0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:114
    uint8_t b, *p = (uint8_t*)pPkt;
     // Check if received successfully
     b = ReadRegister(CC_PKTSTATUS);
 8000558:	f7ff ffe2 	bl	8000520 <cc1101_t::ReadRegister(unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:116
     //    Uart.Printf("St: %X  ", b);
     if(b & 0x80) {  // CRC OK
 800055c:	0603      	lsls	r3, r0, #24
 800055e:	d526      	bpl.n	80005ae <cc1101_t::ReadFIFO(rPkt_t*)+0x5e>
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8000560:	4b14      	ldr	r3, [pc, #80]	; (80005b4 <cc1101_t::ReadFIFO(rPkt_t*)+0x64>)
 8000562:	2210      	movs	r2, #16
 8000564:	835a      	strh	r2, [r3, #26]
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:120
         // Read FIFO
         CsLo();                                            // Start transmission
         BusyWait();                                        // Wait for chip to become ready
         ISpi.ReadWriteByte(CC_FIFO|CC_READ_FLAG|CC_BURST_FLAG); // Address with read & burst flags
 8000566:	f107 0408 	add.w	r4, r7, #8
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:119
     b = ReadRegister(CC_PKTSTATUS);
     //    Uart.Printf("St: %X  ", b);
     if(b & 0x80) {  // CRC OK
         // Read FIFO
         CsLo();                                            // Start transmission
         BusyWait();                                        // Wait for chip to become ready
 800056a:	f7ff ffb9 	bl	80004e0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:120
         ISpi.ReadWriteByte(CC_FIFO|CC_READ_FLAG|CC_BURST_FLAG); // Address with read & burst flags
 800056e:	4620      	mov	r0, r4
 8000570:	21ff      	movs	r1, #255	; 0xff
 8000572:	f7ff ffbd 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
 8000576:	2500      	movs	r5, #0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:122 (discriminator 2)
         for(uint8_t i=0; i<RPKT_LEN; i++) {                // Read bytes
             b = ISpi.ReadWriteByte(0);
 8000578:	4620      	mov	r0, r4
 800057a:	2100      	movs	r1, #0
 800057c:	f7ff ffb8 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:123 (discriminator 2)
             *p++ = b;
 8000580:	5570      	strb	r0, [r6, r5]
 8000582:	3501      	adds	r5, #1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:121 (discriminator 2)
     if(b & 0x80) {  // CRC OK
         // Read FIFO
         CsLo();                                            // Start transmission
         BusyWait();                                        // Wait for chip to become ready
         ISpi.ReadWriteByte(CC_FIFO|CC_READ_FLAG|CC_BURST_FLAG); // Address with read & burst flags
         for(uint8_t i=0; i<RPKT_LEN; i++) {                // Read bytes
 8000584:	2d05      	cmp	r5, #5
 8000586:	d1f7      	bne.n	8000578 <cc1101_t::ReadFIFO(rPkt_t*)+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:127
             b = ISpi.ReadWriteByte(0);
             *p++ = b;
             // Uart.Printf(" %X", b);
         }
         // Receive two additional info bytes
         b = ISpi.ReadWriteByte(0); // RSSI
 8000588:	4620      	mov	r0, r4
 800058a:	2100      	movs	r1, #0
 800058c:	f7ff ffb0 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:128
         ISpi.ReadWriteByte(0);     // LQI
 8000590:	2100      	movs	r1, #0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:127
             b = ISpi.ReadWriteByte(0);
             *p++ = b;
             // Uart.Printf(" %X", b);
         }
         // Receive two additional info bytes
         b = ISpi.ReadWriteByte(0); // RSSI
 8000592:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:128
         ISpi.ReadWriteByte(0);     // LQI
 8000594:	4620      	mov	r0, r4
 8000596:	f7ff ffab 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800059a:	4b06      	ldr	r3, [pc, #24]	; (80005b4 <cc1101_t::ReadFIFO(rPkt_t*)+0x64>)
 800059c:	2210      	movs	r2, #16
 800059e:	831a      	strh	r2, [r3, #24]
_ZN8cc1101_t8ReadFIFOEP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:130
         CsHi();                    // End transmission
         pPkt->RSSI = RSSI_dBm(b);
 80005a0:	4638      	mov	r0, r7
 80005a2:	4629      	mov	r1, r5
 80005a4:	f7ff ffac 	bl	8000500 <cc1101_t::RSSI_dBm(unsigned char)>
 80005a8:	7170      	strb	r0, [r6, #5]
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:131
         return OK;
 80005aa:	2000      	movs	r0, #0
 80005ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:133
     }
     else return FAILURE;
 80005ae:	2001      	movs	r0, #1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:134
}
 80005b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80005b2:	bf00      	nop
 80005b4:	40020000 	.word	0x40020000
	...

080005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>:
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:145
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister (uint8_t ARegAddr, uint8_t AData){
 80005c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80005c4:	4c09      	ldr	r4, [pc, #36]	; (80005ec <cc1101_t::WriteRegister(unsigned char, unsigned char)+0x2c>)
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:145
 80005c6:	4606      	mov	r6, r0
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 80005c8:	2510      	movs	r5, #16
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:145
 80005ca:	4688      	mov	r8, r1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:148
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 80005cc:	3608      	adds	r6, #8
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 80005ce:	8365      	strh	r5, [r4, #26]
_ZN8cc1101_t13WriteRegisterEhh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:145
    ISpi.ReadWriteByte(ARegAddr | CC_READ_FLAG); // Transmit header byte
    uint8_t FReply = ISpi.ReadWriteByte(0); // Read reply
    CsHi();                                 // End transmission
    return FReply;
}
void cc1101_t::WriteRegister (uint8_t ARegAddr, uint8_t AData){
 80005d0:	4617      	mov	r7, r2
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:147
    CsLo();                         // Start transmission
    BusyWait();                     // Wait for chip to become ready
 80005d2:	f7ff ff85 	bl	80004e0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:148
    ISpi.ReadWriteByte(ARegAddr);   // Transmit header byte
 80005d6:	4641      	mov	r1, r8
 80005d8:	4630      	mov	r0, r6
 80005da:	f7ff ff89 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:149
    ISpi.ReadWriteByte(AData);      // Write data
 80005de:	4630      	mov	r0, r6
 80005e0:	4639      	mov	r1, r7
 80005e2:	f7ff ff85 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 80005e6:	8325      	strh	r5, [r4, #24]
 80005e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80005ec:	40020000 	.word	0x40020000

080005f0 <cc1101_t::WriteStrobe(unsigned char)>:
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:152
    CsHi();                         // End transmission
}
void cc1101_t::WriteStrobe (uint8_t AStrobe){
 80005f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 80005f2:	4d09      	ldr	r5, [pc, #36]	; (8000618 <cc1101_t::WriteStrobe(unsigned char)+0x28>)
 80005f4:	2610      	movs	r6, #16
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:152
 80005f6:	4604      	mov	r4, r0
 80005f8:	460f      	mov	r7, r1
_ZN8cc1101_t4CsLoEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 80005fa:	836e      	strh	r6, [r5, #26]
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:154
    CsLo();                                 // Start transmission
    BusyWait();                             // Wait for chip to become ready
 80005fc:	f7ff ff70 	bl	80004e0 <cc1101_t::BusyWait() [clone .isra.6]>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:155
    IState = ISpi.ReadWriteByte(AStrobe);   // Write strobe
 8000600:	f104 0008 	add.w	r0, r4, #8
 8000604:	4639      	mov	r1, r7
 8000606:	f7ff ff73 	bl	80004f0 <Spi_t::ReadWriteByte(unsigned char)>
 800060a:	7020      	strb	r0, [r4, #0]
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 800060c:	832e      	strh	r6, [r5, #24]
_ZN8cc1101_t11WriteStrobeEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:157
    CsHi();                                 // End transmission
    IState &= 0b01110000;                   // Mask needed bits
 800060e:	7823      	ldrb	r3, [r4, #0]
 8000610:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000614:	7023      	strb	r3, [r4, #0]
 8000616:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000618:	40020000 	.word	0x40020000
$d():
 800061c:	00000000 	.word	0x00000000

08000620 <cc1101_t::EnterIdle()>:
_ZN8cc1101_t9EnterIdleEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:63
    // State change
    void TransmitSync(rPkt_t *pPkt);
    uint8_t ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt);
    void TransmitAsync(rPkt_t *pPkt);
    void ReceiveAsync();
    void EnterIdle()  { WriteStrobe(CC_SIDLE); State = ccIdle; }
 8000620:	b510      	push	{r4, lr}
 8000622:	2136      	movs	r1, #54	; 0x36
 8000624:	4604      	mov	r4, r0
 8000626:	f7ff ffe3 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
 800062a:	2300      	movs	r3, #0
 800062c:	7623      	strb	r3, [r4, #24]
 800062e:	bd10      	pop	{r4, pc}

08000630 <cc1101_t::SetChannel(unsigned char)>:
_ZN8cc1101_t10SetChannelEh():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:40
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIRQ(IRQ_PRIO_MEDIUM);
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
 8000630:	b538      	push	{r3, r4, r5, lr}
 8000632:	4604      	mov	r4, r0
 8000634:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:41 (discriminator 1)
    while(IState != CC_STB_IDLE) EnterIdle();   // CC must be in IDLE mode
 8000636:	7823      	ldrb	r3, [r4, #0]
 8000638:	4620      	mov	r0, r4
 800063a:	b113      	cbz	r3, 8000642 <cc1101_t::SetChannel(unsigned char)+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:41 (discriminator 2)
 800063c:	f7ff fff0 	bl	8000620 <cc1101_t::EnterIdle()>
 8000640:	e7f9      	b.n	8000636 <cc1101_t::SetChannel(unsigned char)+0x6>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:42
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 8000642:	462a      	mov	r2, r5
 8000644:	210a      	movs	r1, #10
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:43
}
 8000646:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:42
}

// ========================== TX, RX, freq and power ===========================
void cc1101_t::SetChannel(uint8_t AChannel) {
    while(IState != CC_STB_IDLE) EnterIdle();   // CC must be in IDLE mode
    WriteRegister(CC_CHANNR, AChannel);         // Now set channel
 800064a:	f7ff bfb9 	b.w	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

08000650 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)>:
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:79
}

/*
 * Enter RX mode and wait reception for Timeout_ms.
 */
uint8_t cc1101_t::ReceiveSync(uint32_t Timeout_ms, rPkt_t *pPkt) {
 8000650:	b570      	push	{r4, r5, r6, lr}
 8000652:	460d      	mov	r5, r1
_ZN8cc1101_t11FlushRxFIFOEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:52
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 8000654:	213a      	movs	r1, #58	; 0x3a
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:79
 8000656:	4604      	mov	r4, r0
 8000658:	4616      	mov	r6, r2
_ZN8cc1101_t11FlushRxFIFOEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:52
 800065a:	f7ff ffc9 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:81
    FlushRxFIFO();
    chSysLock();
 800065e:	2320      	movs	r3, #32
 8000660:	f383 8811 	msr	BASEPRI, r3
 8000664:	f000 fbbc 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:82
    PWaitingThread = chThdSelf();
 8000668:	4b11      	ldr	r3, [pc, #68]	; (80006b0 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)+0x60>)
_ZN8cc1101_t7EnterRXEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:51
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
 800066a:	2134      	movs	r1, #52	; 0x34
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:82
 800066c:	6998      	ldr	r0, [r3, #24]
 800066e:	6060      	str	r0, [r4, #4]
_ZN8cc1101_t7EnterRXEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:51
 8000670:	4620      	mov	r0, r4
 8000672:	f7ff ffbd 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11ReceiveSyncEmP6rPkt_t():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:84
    EnterRX();      // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
 8000676:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800067a:	435d      	muls	r5, r3
 800067c:	f5a5 757a 	sub.w	r5, r5, #1000	; 0x3e8
 8000680:	fbb5 f1f3 	udiv	r1, r5, r3
 8000684:	3101      	adds	r1, #1
 8000686:	2002      	movs	r0, #2
 8000688:	f000 fd72 	bl	8001170 <chSchGoSleepTimeoutS>
 800068c:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:85
    chSysUnlock();  // Will be here when IRQ will fire, or timeout occur - with appropriate message
 800068e:	f000 fbbf 	bl	8000e10 <dbg_check_unlock>
 8000692:	2300      	movs	r3, #0
 8000694:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:87

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
 8000698:	3501      	adds	r5, #1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:88
        EnterIdle();            // Get out of RX mode
 800069a:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:87
    PWaitingThread = chThdSelf();
    EnterRX();      // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
    chSysUnlock();  // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
 800069c:	d004      	beq.n	80006a8 <cc1101_t::ReceiveSync(unsigned long, rPkt_t*)+0x58>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:92
        EnterIdle();            // Get out of RX mode
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
 800069e:	4631      	mov	r1, r6
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:93
}
 80006a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:92
    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
        EnterIdle();            // Get out of RX mode
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
 80006a4:	f7ff bf54 	b.w	8000550 <cc1101_t::ReadFIFO(rPkt_t*)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:88
    EnterRX();      // After that, some time will be wasted to recalibrate if enabled
    msg_t Rslt = chSchGoSleepTimeoutS(THD_STATE_SUSPENDED, MS2ST(Timeout_ms));
    chSysUnlock();  // Will be here when IRQ will fire, or timeout occur - with appropriate message

    if(Rslt == RDY_TIMEOUT) {   // Nothing received, timeout occured
        EnterIdle();            // Get out of RX mode
 80006a8:	f7ff ffba 	bl	8000620 <cc1101_t::EnterIdle()>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:93
        return TIMEOUT;
    }
    // IRQ occured: something received, or CRC error
    else return ReadFIFO(pPkt);
}
 80006ac:	2002      	movs	r0, #2
 80006ae:	bd70      	pop	{r4, r5, r6, pc}
 80006b0:	200012ac 	.word	0x200012ac
	...

080006c0 <cc1101_t::RfConfig()>:
_ZN8cc1101_t8RfConfigEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:176
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 80006c0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:177
    WriteRegister(CC_FSCTRL1,  CC_FSCTRL1_VALUE);    // Frequency synthesizer control.
 80006c2:	210b      	movs	r1, #11
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:176
    CsHi();    // End transmission
    //Uart.Printf("\r");
}

// ==== Used to setup CC with needed values ====
void cc1101_t::RfConfig() {
 80006c4:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:177
    WriteRegister(CC_FSCTRL1,  CC_FSCTRL1_VALUE);    // Frequency synthesizer control.
 80006c6:	220c      	movs	r2, #12
 80006c8:	f7ff ff7a 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:178
    WriteRegister(CC_FSCTRL0,  CC_FSCTRL0_VALUE);    // Frequency synthesizer control.
 80006cc:	4620      	mov	r0, r4
 80006ce:	210c      	movs	r1, #12
 80006d0:	2200      	movs	r2, #0
 80006d2:	f7ff ff75 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:179
    WriteRegister(CC_FREQ2,    CC_FREQ2_VALUE);      // Frequency control word, high byte.
 80006d6:	4620      	mov	r0, r4
 80006d8:	210d      	movs	r1, #13
 80006da:	2220      	movs	r2, #32
 80006dc:	f7ff ff70 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:180
    WriteRegister(CC_FREQ1,    CC_FREQ1_VALUE);      // Frequency control word, middle byte.
 80006e0:	4620      	mov	r0, r4
 80006e2:	210e      	movs	r1, #14
 80006e4:	2225      	movs	r2, #37	; 0x25
 80006e6:	f7ff ff6b 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:181
    WriteRegister(CC_FREQ0,    CC_FREQ0_VALUE);      // Frequency control word, low byte.
 80006ea:	4620      	mov	r0, r4
 80006ec:	210f      	movs	r1, #15
 80006ee:	22ed      	movs	r2, #237	; 0xed
 80006f0:	f7ff ff66 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:182
    WriteRegister(CC_MDMCFG4,  CC_MDMCFG4_VALUE);    // Modem configuration.
 80006f4:	4620      	mov	r0, r4
 80006f6:	2110      	movs	r1, #16
 80006f8:	222d      	movs	r2, #45	; 0x2d
 80006fa:	f7ff ff61 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:183
    WriteRegister(CC_MDMCFG3,  CC_MDMCFG3_VALUE);    // Modem configuration.
 80006fe:	4620      	mov	r0, r4
 8000700:	2111      	movs	r1, #17
 8000702:	222f      	movs	r2, #47	; 0x2f
 8000704:	f7ff ff5c 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:184
    WriteRegister(CC_MDMCFG2,  CC_MDMCFG2_VALUE);    // Modem configuration.
 8000708:	4620      	mov	r0, r4
 800070a:	2112      	movs	r1, #18
 800070c:	2213      	movs	r2, #19
 800070e:	f7ff ff57 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:185
    WriteRegister(CC_MDMCFG1,  CC_MDMCFG1_VALUE);    // Modem configuration.
 8000712:	4620      	mov	r0, r4
 8000714:	2113      	movs	r1, #19
 8000716:	2222      	movs	r2, #34	; 0x22
 8000718:	f7ff ff52 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:186
    WriteRegister(CC_MDMCFG0,  CC_MDMCFG0_VALUE);    // Modem configuration.
 800071c:	4620      	mov	r0, r4
 800071e:	2114      	movs	r1, #20
 8000720:	22e5      	movs	r2, #229	; 0xe5
 8000722:	f7ff ff4d 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:187
    WriteRegister(CC_CHANNR,   CC_CHANNR_VALUE);     // Channel number.
 8000726:	4620      	mov	r0, r4
 8000728:	210a      	movs	r1, #10
 800072a:	2200      	movs	r2, #0
 800072c:	f7ff ff48 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:188
    WriteRegister(CC_DEVIATN,  CC_DEVIATN_VALUE);    // Modem deviation setting (when FSK modulation is enabled).
 8000730:	4620      	mov	r0, r4
 8000732:	2115      	movs	r1, #21
 8000734:	2262      	movs	r2, #98	; 0x62
 8000736:	f7ff ff43 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:189
    WriteRegister(CC_FREND1,   CC_FREND1_VALUE);     // Front end RX configuration.
 800073a:	4620      	mov	r0, r4
 800073c:	2121      	movs	r1, #33	; 0x21
 800073e:	22b6      	movs	r2, #182	; 0xb6
 8000740:	f7ff ff3e 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:190
    WriteRegister(CC_FREND0,   CC_FREND0_VALUE);     // Front end RX configuration.
 8000744:	4620      	mov	r0, r4
 8000746:	2122      	movs	r1, #34	; 0x22
 8000748:	2210      	movs	r2, #16
 800074a:	f7ff ff39 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:191
    WriteRegister(CC_MCSM0,    CC_MCSM0_VALUE);      // Main Radio Control State Machine configuration.
 800074e:	4620      	mov	r0, r4
 8000750:	2118      	movs	r1, #24
 8000752:	2208      	movs	r2, #8
 8000754:	f7ff ff34 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:192
    WriteRegister(CC_FOCCFG,   CC_FOCCFG_VALUE);     // Frequency Offset Compensation Configuration.
 8000758:	4620      	mov	r0, r4
 800075a:	2119      	movs	r1, #25
 800075c:	221d      	movs	r2, #29
 800075e:	f7ff ff2f 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:193
    WriteRegister(CC_BSCFG,    CC_BSCFG_VALUE);      // Bit synchronization Configuration.
 8000762:	4620      	mov	r0, r4
 8000764:	211a      	movs	r1, #26
 8000766:	221c      	movs	r2, #28
 8000768:	f7ff ff2a 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:194
    WriteRegister(CC_AGCCTRL2, CC_AGCCTRL2_VALUE);   // AGC control.
 800076c:	4620      	mov	r0, r4
 800076e:	211b      	movs	r1, #27
 8000770:	22c7      	movs	r2, #199	; 0xc7
 8000772:	f7ff ff25 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:195
    WriteRegister(CC_AGCCTRL1, CC_AGCCTRL1_VALUE);   // AGC control.
 8000776:	4620      	mov	r0, r4
 8000778:	211c      	movs	r1, #28
 800077a:	2200      	movs	r2, #0
 800077c:	f7ff ff20 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:196
    WriteRegister(CC_AGCCTRL0, CC_AGCCTRL0_VALUE);   // AGC control.
 8000780:	4620      	mov	r0, r4
 8000782:	211d      	movs	r1, #29
 8000784:	22b0      	movs	r2, #176	; 0xb0
 8000786:	f7ff ff1b 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:197
    WriteRegister(CC_FSCAL3,   CC_FSCAL3_VALUE);     // Frequency synthesizer calibration.
 800078a:	4620      	mov	r0, r4
 800078c:	2123      	movs	r1, #35	; 0x23
 800078e:	22ea      	movs	r2, #234	; 0xea
 8000790:	f7ff ff16 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:198
    WriteRegister(CC_FSCAL2,   CC_FSCAL2_VALUE);     // Frequency synthesizer calibration.
 8000794:	4620      	mov	r0, r4
 8000796:	2124      	movs	r1, #36	; 0x24
 8000798:	222a      	movs	r2, #42	; 0x2a
 800079a:	f7ff ff11 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:199
    WriteRegister(CC_FSCAL1,   CC_FSCAL1_VALUE);     // Frequency synthesizer calibration.
 800079e:	4620      	mov	r0, r4
 80007a0:	2125      	movs	r1, #37	; 0x25
 80007a2:	2200      	movs	r2, #0
 80007a4:	f7ff ff0c 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:200
    WriteRegister(CC_FSCAL0,   CC_FSCAL0_VALUE);     // Frequency synthesizer calibration.
 80007a8:	4620      	mov	r0, r4
 80007aa:	2126      	movs	r1, #38	; 0x26
 80007ac:	221f      	movs	r2, #31
 80007ae:	f7ff ff07 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:201
    WriteRegister(CC_TEST2,    CC_TEST2_VALUE);      // Various test settings.
 80007b2:	4620      	mov	r0, r4
 80007b4:	212c      	movs	r1, #44	; 0x2c
 80007b6:	2288      	movs	r2, #136	; 0x88
 80007b8:	f7ff ff02 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:202
    WriteRegister(CC_TEST1,    CC_TEST1_VALUE);      // Various test settings.
 80007bc:	4620      	mov	r0, r4
 80007be:	212d      	movs	r1, #45	; 0x2d
 80007c0:	2231      	movs	r2, #49	; 0x31
 80007c2:	f7ff fefd 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:203
    WriteRegister(CC_TEST0,    CC_TEST0_VALUE);      // Various test settings.
 80007c6:	4620      	mov	r0, r4
 80007c8:	212e      	movs	r1, #46	; 0x2e
 80007ca:	2209      	movs	r2, #9
 80007cc:	f7ff fef8 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:204
    WriteRegister(CC_FIFOTHR,  CC_FIFOTHR_VALUE);    // fifo threshold
 80007d0:	4620      	mov	r0, r4
 80007d2:	2103      	movs	r1, #3
 80007d4:	2207      	movs	r2, #7
 80007d6:	f7ff fef3 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:205
    WriteRegister(CC_IOCFG2,   CC_IOCFG2_VALUE);     // GDO2 output pin configuration.
 80007da:	4620      	mov	r0, r4
 80007dc:	2100      	movs	r1, #0
 80007de:	2207      	movs	r2, #7
 80007e0:	f7ff feee 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:206
    WriteRegister(CC_IOCFG0,   CC_IOCFG0_VALUE);     // GDO0 output pin configuration.
 80007e4:	4620      	mov	r0, r4
 80007e6:	2102      	movs	r1, #2
 80007e8:	2206      	movs	r2, #6
 80007ea:	f7ff fee9 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:207
    WriteRegister(CC_PKTCTRL1, CC_PKTCTRL1_VALUE);   // Packet automation control.
 80007ee:	4620      	mov	r0, r4
 80007f0:	2107      	movs	r1, #7
 80007f2:	220c      	movs	r2, #12
 80007f4:	f7ff fee4 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:208
    WriteRegister(CC_PKTCTRL0, CC_PKTCTRL0_VALUE);   // Packet automation control.
 80007f8:	4620      	mov	r0, r4
 80007fa:	2108      	movs	r1, #8
 80007fc:	2244      	movs	r2, #68	; 0x44
 80007fe:	f7ff fedf 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:209
    WriteRegister(CC_PKTLEN,   RPKT_LEN);            // Packet length, dummy
 8000802:	4620      	mov	r0, r4
 8000804:	2106      	movs	r1, #6
 8000806:	2205      	movs	r2, #5
 8000808:	f7ff feda 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:211

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);
 800080c:	4620      	mov	r0, r4
 800080e:	213e      	movs	r1, #62	; 0x3e
 8000810:	2250      	movs	r2, #80	; 0x50
 8000812:	f7ff fed5 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:213

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
 8000816:	4620      	mov	r0, r4
 8000818:	2116      	movs	r1, #22
 800081a:	2207      	movs	r2, #7
 800081c:	f7ff fed0 	bl	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:214
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 8000820:	4620      	mov	r0, r4
 8000822:	2117      	movs	r1, #23
 8000824:	2200      	movs	r2, #0
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:215
}
 8000826:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:214
    WriteRegister(CC_PKTLEN,   RPKT_LEN);            // Packet length, dummy

    WriteRegister(CC_PATABLE, CC_Pwr0dBm);

    WriteRegister(CC_MCSM2, CC_MCSM2_VALUE);
    WriteRegister(CC_MCSM1, CC_MCSM1_VALUE);
 800082a:	f7ff bec9 	b.w	80005c0 <cc1101_t::WriteRegister(unsigned char, unsigned char)>
	...

08000830 <cc1101_t::Init()>:
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:13
#include "cc1101.h"
#include "ch.h"

cc1101_t CC;

void cc1101_t::Init() {
 8000830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000832:	4d8d      	ldr	r5, [pc, #564]	; (8000a68 <cc1101_t::Init()+0x238>)
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000834:	4c8d      	ldr	r4, [pc, #564]	; (8000a6c <cc1101_t::Init()+0x23c>)
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000836:	69eb      	ldr	r3, [r5, #28]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:419
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
        PSpi->CR2 = 0;
 8000838:	2700      	movs	r7, #0
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 800083a:	f043 0301 	orr.w	r3, r3, #1
 800083e:	61eb      	str	r3, [r5, #28]
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000840:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:13
 8000842:	4606      	mov	r6, r0
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
 8000844:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000848:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 800084a:	6823      	ldr	r3, [r4, #0]
_ZN8cc1101_t6CResetEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:47
    void WriteRegister (const uint8_t Addr, const uint8_t AData);
    uint8_t ReadRegister (const uint8_t Addr);
    void WriteStrobe(uint8_t AStrobe);
    void WriteTX(uint8_t* Ptr, uint8_t Length);
    // Strobes
    void CReset()      { WriteStrobe(CC_SRES); }
 800084c:	2130      	movs	r1, #48	; 0x30
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
 800084e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000852:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000854:	88a3      	ldrh	r3, [r4, #4]
 8000856:	f023 0310 	bic.w	r3, r3, #16
 800085a:	041b      	lsls	r3, r3, #16
 800085c:	0c1b      	lsrs	r3, r3, #16
 800085e:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000860:	88a3      	ldrh	r3, [r4, #4]
 8000862:	b29b      	uxth	r3, r3
 8000864:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000866:	68e3      	ldr	r3, [r4, #12]
 8000868:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800086c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800086e:	68e3      	ldr	r3, [r4, #12]
 8000870:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000872:	68a3      	ldr	r3, [r4, #8]
 8000874:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000878:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800087a:	68a3      	ldr	r3, [r4, #8]
 800087c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8000880:	60a3      	str	r3, [r4, #8]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000882:	69eb      	ldr	r3, [r5, #28]
 8000884:	f043 0301 	orr.w	r3, r3, #1
 8000888:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800088a:	6823      	ldr	r3, [r4, #0]
 800088c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8000890:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8000892:	6823      	ldr	r3, [r4, #0]
 8000894:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000898:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 800089a:	88a3      	ldrh	r3, [r4, #4]
 800089c:	f023 0320 	bic.w	r3, r3, #32
 80008a0:	041b      	lsls	r3, r3, #16
 80008a2:	0c1b      	lsrs	r3, r3, #16
 80008a4:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80008a6:	88a3      	ldrh	r3, [r4, #4]
 80008a8:	b29b      	uxth	r3, r3
 80008aa:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80008ac:	68e3      	ldr	r3, [r4, #12]
 80008ae:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80008b2:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80008b4:	68e3      	ldr	r3, [r4, #12]
 80008b6:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80008b8:	68a3      	ldr	r3, [r4, #8]
 80008ba:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80008be:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80008c0:	68a3      	ldr	r3, [r4, #8]
 80008c2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80008c6:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 80008c8:	6a23      	ldr	r3, [r4, #32]
 80008ca:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80008ce:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 80008d0:	6a23      	ldr	r3, [r4, #32]
 80008d2:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 80008d6:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80008d8:	69eb      	ldr	r3, [r5, #28]
 80008da:	f043 0301 	orr.w	r3, r3, #1
 80008de:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80008e0:	6823      	ldr	r3, [r4, #0]
 80008e2:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80008e6:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80008e8:	6823      	ldr	r3, [r4, #0]
 80008ea:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80008ee:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80008f0:	88a3      	ldrh	r3, [r4, #4]
 80008f2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80008f6:	041b      	lsls	r3, r3, #16
 80008f8:	0c1b      	lsrs	r3, r3, #16
 80008fa:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80008fc:	88a3      	ldrh	r3, [r4, #4]
 80008fe:	b29b      	uxth	r3, r3
 8000900:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000902:	68e3      	ldr	r3, [r4, #12]
 8000904:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8000908:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800090a:	68e3      	ldr	r3, [r4, #12]
 800090c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 800090e:	68a3      	ldr	r3, [r4, #8]
 8000910:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8000914:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8000916:	68a3      	ldr	r3, [r4, #8]
 8000918:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800091c:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 800091e:	6a23      	ldr	r3, [r4, #32]
 8000920:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8000924:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8000926:	6a23      	ldr	r3, [r4, #32]
 8000928:	f043 63a0 	orr.w	r3, r3, #83886080	; 0x5000000
 800092c:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 800092e:	69eb      	ldr	r3, [r5, #28]
 8000930:	f043 0301 	orr.w	r3, r3, #1
 8000934:	61eb      	str	r3, [r5, #28]
PinSetupAlterFunc():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8000936:	6823      	ldr	r3, [r4, #0]
 8000938:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800093c:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 800093e:	6823      	ldr	r3, [r4, #0]
 8000940:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000944:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8000946:	88a3      	ldrh	r3, [r4, #4]
 8000948:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800094c:	041b      	lsls	r3, r3, #16
 800094e:	0c1b      	lsrs	r3, r3, #16
 8000950:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8000952:	88a3      	ldrh	r3, [r4, #4]
 8000954:	b29b      	uxth	r3, r3
 8000956:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8000958:	68e3      	ldr	r3, [r4, #12]
 800095a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800095e:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8000960:	68e3      	ldr	r3, [r4, #12]
 8000962:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8000964:	68a3      	ldr	r3, [r4, #8]
 8000966:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800096a:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800096c:	68a3      	ldr	r3, [r4, #8]
 800096e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000972:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8000974:	6a23      	ldr	r3, [r4, #32]
 8000976:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800097a:	6223      	str	r3, [r4, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 800097c:	6a23      	ldr	r3, [r4, #32]
 800097e:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
 8000982:	6223      	str	r3, [r4, #32]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000984:	69eb      	ldr	r3, [r5, #28]
 8000986:	f043 0301 	orr.w	r3, r3, #1
 800098a:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:167
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 800098c:	6823      	ldr	r3, [r4, #0]
 800098e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8000992:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:169
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000994:	68e3      	ldr	r3, [r4, #12]
 8000996:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800099a:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:170
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 800099c:	68e3      	ldr	r3, [r4, #12]
 800099e:	60e3      	str	r3, [r4, #12]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 80009a0:	69eb      	ldr	r3, [r5, #28]
 80009a2:	f043 0301 	orr.w	r3, r3, #1
 80009a6:	61eb      	str	r3, [r5, #28]
PinSetupIn():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:167
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 80009a8:	6823      	ldr	r3, [r4, #0]
 80009aa:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80009ae:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:169
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 80009b0:	68e3      	ldr	r3, [r4, #12]
 80009b2:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80009b6:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:170
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 80009b8:	68e3      	ldr	r3, [r4, #12]
 80009ba:	60e3      	str	r3, [r4, #12]
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 80009bc:	2310      	movs	r3, #16
 80009be:	8323      	strh	r3, [r4, #24]
_ZN5Spi_t5SetupEP11SPI_TypeDef10BitOrder_t6CPOL_t6CPHA_t13SpiBaudrate_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:409
private:
    SPI_TypeDef *PSpi;
public:
    void Setup(SPI_TypeDef *Spi, BitOrder_t BitOrder,
            CPOL_t CPOL, CPHA_t CPHA, SpiBaudrate_t Baudrate) {
        PSpi = Spi;
 80009c0:	4b2b      	ldr	r3, [pc, #172]	; (8000a70 <cc1101_t::Init()+0x240>)
 80009c2:	6083      	str	r3, [r0, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:411
        // Clocking
        if      (PSpi == SPI1) { rccEnableSPI1(FALSE); }
 80009c4:	6a2a      	ldr	r2, [r5, #32]
 80009c6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80009ca:	622a      	str	r2, [r5, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:414
        else if (PSpi == SPI2) { rccEnableSPI2(FALSE); }
        // Mode: Master, NSS software controlled and is 1, 8bit, NoCRC, FullDuplex
        PSpi->CR1 = SPI_CR1_SSM | SPI_CR1_SSI | SPI_CR1_MSTR;
 80009cc:	f44f 7241 	mov.w	r2, #772	; 0x304
 80009d0:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:418
        if(BitOrder == boLSB) PSpi->CR1 |= SPI_CR1_LSBFIRST;    // MSB/LSB
        if(CPOL == cpolIdleHigh) PSpi->CR1 |= SPI_CR1_CPOL;     // CPOL
        if(CPHA == cphaSecondEdge) PSpi->CR1 |= SPI_CR1_CPHA;   // CPHA
        PSpi->CR1 |= ((uint16_t)Baudrate) << 3;                 // Baudrate
 80009d2:	881a      	ldrh	r2, [r3, #0]
 80009d4:	b292      	uxth	r2, r2
 80009d6:	801a      	strh	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:419
        PSpi->CR2 = 0;
 80009d8:	809f      	strh	r7, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:420
        PSpi->I2SCFGR &= ~((uint16_t)SPI_I2SCFGR_I2SMOD);       // Disable I2S
 80009da:	8b9a      	ldrh	r2, [r3, #28]
 80009dc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80009e0:	0412      	lsls	r2, r2, #16
 80009e2:	0c12      	lsrs	r2, r2, #16
 80009e4:	839a      	strh	r2, [r3, #28]
_ZN5Spi_t6EnableEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:422
    }
    void Enable () { PSpi->CR1 |=  SPI_CR1_SPE; }
 80009e6:	881a      	ldrh	r2, [r3, #0]
 80009e8:	b292      	uxth	r2, r2
 80009ea:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80009ee:	801a      	strh	r2, [r3, #0]
_ZN8cc1101_t6CResetEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:47
 80009f0:	f7ff fdfe 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t11FlushRxFIFOEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.h:52
    void EnterTX()     { WriteStrobe(CC_STX);  }
    void FlushTxFIFO() { WriteStrobe(CC_SFTX); }
    void GetState()    { WriteStrobe(CC_SNOP); }
    void EnterRX()     { WriteStrobe(CC_SRX);  }
    void FlushRxFIFO() { WriteStrobe(CC_SFRX); }
 80009f4:	4630      	mov	r0, r6
 80009f6:	213a      	movs	r1, #58	; 0x3a
 80009f8:	f7ff fdfa 	bl	80005f0 <cc1101_t::WriteStrobe(unsigned char)>
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:30
    ISpi.Enable();

    // ==== Init CC ====
    CReset();
    FlushRxFIFO();
    RfConfig();
 80009fc:	4630      	mov	r0, r6
 80009fe:	f7ff fe5f 	bl	80006c0 <cc1101_t::RfConfig()>
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:251
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
        IPinNumber = APinNumber;
 8000a02:	2303      	movs	r3, #3
 8000a04:	7533      	strb	r3, [r6, #20]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:252
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 8000a06:	6a2b      	ldr	r3, [r5, #32]
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:31
    PWaitingThread = nullptr;
 8000a08:	6077      	str	r7, [r6, #4]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:252
 8000a0a:	f043 0301 	orr.w	r3, r3, #1
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:32
    State = ccIdle;
 8000a0e:	7637      	strb	r7, [r6, #24]
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:250
                break;
        } // switch
    }

    void Setup(GPIO_TypeDef *GPIO, const uint8_t APinNumber, ExtiTrigType_t ATriggerType) {
        IGPIO = GPIO;
 8000a10:	6134      	str	r4, [r6, #16]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:252
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
 8000a12:	622b      	str	r3, [r5, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:256
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 8000a14:	4b17      	ldr	r3, [pc, #92]	; (8000a74 <cc1101_t::Init()+0x244>)
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:232
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 8000a16:	2101      	movs	r1, #1
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:256
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 8000a18:	689a      	ldr	r2, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:267
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 8000a1a:	2009      	movs	r0, #9
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:256
        IPinNumber = APinNumber;
        rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, FALSE); // Enable sys cfg controller
        // Connect EXTI line to the pin of the port
        uint8_t Indx   = APinNumber / 4;            // Indx of EXTICR register
        uint8_t Offset = (APinNumber & 0x03) * 4;   // Offset in EXTICR register
        SYSCFG->EXTICR[Indx] &= ~((uint32_t)0b1111 << Offset);  // Clear port-related bits
 8000a1c:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 8000a20:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:262
        // GPIOA requires all zeroes => nothing to do in this case
        if     (GPIO == GPIOB) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0001 << Offset;
        else if(GPIO == GPIOC) SYSCFG->EXTICR[Indx] |= (uint32_t)0b0010 << Offset;
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
 8000a22:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 8000a26:	f042 0208 	orr.w	r2, r2, #8
 8000a2a:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:263
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
 8000a2e:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 8000a32:	f022 0208 	bic.w	r2, r2, #8
 8000a36:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
_ZN8PinIrq_t14SetTriggerTypeE14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:232
    uint32_t IIrqChnl;
    GPIO_TypeDef *IGPIO;
    uint8_t IPinNumber;
public:
    void SetTriggerType(ExtiTrigType_t ATriggerType) {
        uint32_t IrqMsk = 1 << IPinNumber;
 8000a3a:	7d32      	ldrb	r2, [r6, #20]
 8000a3c:	fa01 f202 	lsl.w	r2, r1, r2
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:239
            case ttRising:
                EXTI->RTSR |=  IrqMsk;  // Rising trigger enabled
                EXTI->FTSR &= ~IrqMsk;  // Falling trigger disabled
                break;
            case ttFalling:
                EXTI->RTSR &= ~IrqMsk;  // Rising trigger disabled
 8000a40:	f8d3 1408 	ldr.w	r1, [r3, #1032]	; 0x408
 8000a44:	ea21 0102 	bic.w	r1, r1, r2
 8000a48:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:240
                EXTI->FTSR |=  IrqMsk;  // Falling trigger enabled
 8000a4c:	f8d3 140c 	ldr.w	r1, [r3, #1036]	; 0x40c
 8000a50:	430a      	orrs	r2, r1
 8000a52:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:265
        // Configure EXTI line
        uint32_t IrqMsk = 1 << APinNumber;
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
 8000a56:	2208      	movs	r2, #8
 8000a58:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
_ZN8PinIrq_t9EnableIRQEm():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:271
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIRQ(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 8000a5c:	2190      	movs	r1, #144	; 0x90
_ZN8PinIrq_t5SetupEP12GPIO_TypeDefh14ExtiTrigType_t():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:267
        EXTI->IMR  |=  IrqMsk;      // Interrupt mode enabled
        EXTI->EMR  &= ~IrqMsk;      // Event mode disabled
        SetTriggerType(ATriggerType);
        EXTI->PR    =  IrqMsk;      // Clean irq flag
        // Get IRQ channel
        if      ((APinNumber >= 0)  and (APinNumber <= 4))  IIrqChnl = EXTI0_IRQn + APinNumber;
 8000a5e:	60f0      	str	r0, [r6, #12]
_ZN8cc1101_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:37

    // ==== IRQ ====
    IGdo0.Setup(CC_GPIO, CC_GDO0, ttFalling);
    IGdo0.EnableIRQ(IRQ_PRIO_MEDIUM);
}
 8000a60:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
_ZN8PinIrq_t9EnableIRQEm():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:271
        else if ((APinNumber >= 5)  and (APinNumber <= 9))  IIrqChnl = EXTI9_5_IRQn;
        else if ((APinNumber >= 10) and (APinNumber <= 15)) IIrqChnl = EXTI15_10_IRQn;
    }
    void EnableIRQ(const uint32_t Priority) { nvicEnableVector(IIrqChnl, CORTEX_PRIORITY_MASK(Priority)); }
 8000a64:	f000 b84c 	b.w	8000b00 <nvicEnableVector>
 8000a68:	40023800 	.word	0x40023800
 8000a6c:	40020000 	.word	0x40020000
 8000a70:	40013000 	.word	0x40013000
 8000a74:	40010000 	.word	0x40010000
	...

08000a80 <cc1101_t::IHandleAsync()>:
_ZN8cc1101_t12IHandleAsyncEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:223
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcTx);  // FIXME
    }
    else if(State == ccReceiving) {
 8000a80:	7e03      	ldrb	r3, [r0, #24]
 8000a82:	3b02      	subs	r3, #2
 8000a84:	b2db      	uxtb	r3, r3
 8000a86:	2b01      	cmp	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:220
}

// ============================= Interrupts ====================================
void cc1101_t::IHandleAsync() {
    if(State == ccTransmitting) {
        State = ccIdle;
 8000a88:	bf9c      	itt	ls
 8000a8a:	2300      	movls	r3, #0
 8000a8c:	7603      	strbls	r3, [r0, #24]
 8000a8e:	4770      	bx	lr

08000a90 <cc1101_t::IGdo0IrqHandler()>:
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:229
        State = ccIdle;
//        chEvtBroadcastI(&IEvtSrcRx);  // FIXME
    }
}

void cc1101_t::IGdo0IrqHandler() {
 8000a90:	b510      	push	{r4, lr}
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:273
    void DisableIrq() { nvicDisableVector(IIrqChnl); }
    void CleanIrqFlag() { EXTI->PR = (1 << IPinNumber); }
 8000a92:	7d03      	ldrb	r3, [r0, #20]
 8000a94:	2201      	movs	r2, #1
 8000a96:	409a      	lsls	r2, r3
 8000a98:	4b0f      	ldr	r3, [pc, #60]	; (8000ad8 <cc1101_t::IGdo0IrqHandler()+0x48>)
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:229
 8000a9a:	4604      	mov	r4, r0
_ZN8PinIrq_t12CleanIrqFlagEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:273
 8000a9c:	615a      	str	r2, [r3, #20]
_ZN8cc1101_t15IGdo0IrqHandlerEv():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:232
    IGdo0.CleanIrqFlag();
    // Resume thread if any
    chSysLockFromIsr();
 8000a9e:	2320      	movs	r3, #32
 8000aa0:	f383 8811 	msr	BASEPRI, r3
 8000aa4:	f000 f9cc 	bl	8000e40 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:233
    if(PWaitingThread != NULL) {
 8000aa8:	6863      	ldr	r3, [r4, #4]
 8000aaa:	b15b      	cbz	r3, 8000ac4 <cc1101_t::IGdo0IrqHandler()+0x34>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:234
        if(PWaitingThread->p_state == THD_STATE_SUSPENDED) {
 8000aac:	f893 2020 	ldrb.w	r2, [r3, #32]
 8000ab0:	2a02      	cmp	r2, #2
 8000ab2:	d104      	bne.n	8000abe <cc1101_t::IGdo0IrqHandler()+0x2e>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:235
            PWaitingThread->p_u.rdymsg = RDY_OK;    // Signal that IRQ fired
 8000ab4:	2200      	movs	r2, #0
 8000ab6:	629a      	str	r2, [r3, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:236
            chSchReadyI(PWaitingThread);
 8000ab8:	6860      	ldr	r0, [r4, #4]
 8000aba:	f000 fae9 	bl	8001090 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:238 (discriminator 1)
        }
        PWaitingThread = NULL;
 8000abe:	2300      	movs	r3, #0
 8000ac0:	6063      	str	r3, [r4, #4]
 8000ac2:	e002      	b.n	8000aca <cc1101_t::IGdo0IrqHandler()+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:240
    }
    else IHandleAsync(); // Async task completed
 8000ac4:	4620      	mov	r0, r4
 8000ac6:	f7ff ffdb 	bl	8000a80 <cc1101_t::IHandleAsync()>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:241
    chSysUnlockFromIsr();
 8000aca:	f000 f9d1 	bl	8000e70 <dbg_check_unlock_from_isr>
 8000ace:	2300      	movs	r3, #0
 8000ad0:	f383 8811 	msr	BASEPRI, r3
 8000ad4:	bd10      	pop	{r4, pc}
 8000ad6:	bf00      	nop
 8000ad8:	40010400 	.word	0x40010400
$d():
 8000adc:	00000000 	.word	0x00000000

08000ae0 <Vector64>:
Vector64():
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:245
}

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
 8000ae0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:246
    CH_IRQ_PROLOGUE();
 8000ae2:	f000 f9dd 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:247
    CC.IGdo0IrqHandler();
 8000ae6:	4804      	ldr	r0, [pc, #16]	; (8000af8 <Vector64+0x18>)
 8000ae8:	f7ff ffd2 	bl	8000a90 <cc1101_t::IGdo0IrqHandler()>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:248
    CH_IRQ_EPILOGUE();
 8000aec:	f000 f9f8 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:249
}
 8000af0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Radio/cc1101.cpp:248

extern "C" {
CH_IRQ_HANDLER(GDO0_IRQ_HANLER) {
    CH_IRQ_PROLOGUE();
    CC.IGdo0IrqHandler();
    CH_IRQ_EPILOGUE();
 8000af4:	f000 b884 	b.w	8000c00 <_port_irq_epilogue>
 8000af8:	20000b70 	.word	0x20000b70
$d():
 8000afc:	00000000 	.word	0x00000000

08000b00 <nvicEnableVector>:
nvicEnableVector():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:47
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 8000b00:	f000 0203 	and.w	r2, r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:46
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000b04:	b530      	push	{r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:47
  unsigned sh = (n & 3) << 3;
 8000b06:	00d2      	lsls	r2, r2, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:49

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000b08:	24ff      	movs	r4, #255	; 0xff
 8000b0a:	4094      	lsls	r4, r2
 8000b0c:	4091      	lsls	r1, r2
 8000b0e:	f020 0303 	bic.w	r3, r0, #3
 8000b12:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8000b16:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8000b1a:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 8000b1e:	2201      	movs	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:49
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000b20:	ea25 0404 	bic.w	r4, r5, r4
 8000b24:	430c      	orrs	r4, r1
 8000b26:	f8c3 4300 	str.w	r4, [r3, #768]	; 0x300
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 8000b2a:	f000 031f 	and.w	r3, r0, #31
 8000b2e:	fa02 f303 	lsl.w	r3, r2, r3
 8000b32:	0940      	lsrs	r0, r0, #5
 8000b34:	0080      	lsls	r0, r0, #2
 8000b36:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000b3a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000b3e:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:51
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
 8000b42:	6003      	str	r3, [r0, #0]
 8000b44:	bd30      	pop	{r4, r5, pc}
	...

08000b50 <nvicSetSystemHandlerPriority>:
nvicSetSystemHandlerPriority():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000b50:	f020 0303 	bic.w	r3, r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:75
  unsigned sh = (handler & 3) * 8;
 8000b54:	f000 0003 	and.w	r0, r0, #3
 8000b58:	00c0      	lsls	r0, r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:78

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
                           ~(0xFF << sh)) | (prio << sh);
 8000b5a:	22ff      	movs	r2, #255	; 0xff
 8000b5c:	4082      	lsls	r2, r0
 8000b5e:	4081      	lsls	r1, r0
 8000b60:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000b64:	b510      	push	{r4, lr}
 8000b66:	f503 436d 	add.w	r3, r3, #60672	; 0xed00
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:77
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000b6a:	699c      	ldr	r4, [r3, #24]
 8000b6c:	ea24 0202 	bic.w	r2, r4, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:78
                           ~(0xFF << sh)) | (prio << sh);
 8000b70:	430a      	orrs	r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/common/ARMCMx/nvic.c:77
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000b72:	619a      	str	r2, [r3, #24]
 8000b74:	bd10      	pop	{r4, pc}
	...

08000b80 <_unhandled_exception>:
_unhandled_exception():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/STM32L1xx/vectors.c:169
 * @notapi
 */
#if !defined(__DOXYGEN__)
__attribute__ ((naked))
#endif
void _unhandled_exception(void) {
 8000b80:	e7fe      	b.n	8000b80 <_unhandled_exception>
	...

08000b90 <_port_switch_from_isr>:
_port_switch_from_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:209
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
 8000b90:	f000 f926 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:210
  chSchDoReschedule();
 8000b94:	f000 fb9c 	bl	80012d0 <chSchDoReschedule>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:211
  dbg_check_unlock();
 8000b98:	f000 f93a 	bl	8000e10 <dbg_check_unlock>

08000b9c <_port_exit_from_isr>:
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:214
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
 8000b9c:	df00      	svc	0
	...

08000ba0 <SVCallVector>:
SVCallVector():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:69
 */
void SVCallVector(void) {
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000ba0:	f3ef 8309 	mrs	r3, PSP
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:73

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000ba4:	3320      	adds	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:80
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000ba6:	f383 8809 	msr	PSP, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:81
  port_unlock_from_isr();
 8000baa:	2300      	movs	r3, #0
 8000bac:	f383 8811 	msr	BASEPRI, r3
 8000bb0:	4770      	bx	lr
	...

08000bc0 <_port_init>:
_port_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:118
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
 8000bc0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:121

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
 8000bc2:	4b0a      	ldr	r3, [pc, #40]	; (8000bec <_port_init+0x2c>)
 8000bc4:	2200      	movs	r2, #0
 8000bc6:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:122
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 8000bc8:	4a09      	ldr	r2, [pc, #36]	; (8000bf0 <_port_init+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 8000bca:	2007      	movs	r0, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:122
 */
void _port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 8000bcc:	60da      	str	r2, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 8000bce:	2110      	movs	r1, #16
 8000bd0:	f7ff ffbe 	bl	8000b50 <nvicSetSystemHandlerPriority>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:127
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
 8000bd4:	200a      	movs	r0, #10
 8000bd6:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000bda:	f7ff ffb9 	bl	8000b50 <nvicSetSystemHandlerPriority>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:131
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
}
 8000bde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:129
  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
 8000be2:	200b      	movs	r0, #11
 8000be4:	2180      	movs	r1, #128	; 0x80
 8000be6:	f7ff bfb3 	b.w	8000b50 <nvicSetSystemHandlerPriority>
 8000bea:	bf00      	nop
 8000bec:	e000ed00 	.word	0xe000ed00
 8000bf0:	05fa0300 	.word	0x05fa0300
	...

08000c00 <_port_irq_epilogue>:
_port_irq_epilogue():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:150
/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
 8000c00:	2320      	movs	r3, #32
 8000c02:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:151
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
 8000c06:	4b15      	ldr	r3, [pc, #84]	; (8000c5c <_port_irq_epilogue+0x5c>)
 8000c08:	685b      	ldr	r3, [r3, #4]
 8000c0a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000c0e:	d021      	beq.n	8000c54 <_port_irq_epilogue+0x54>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:155
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000c10:	f3ef 8309 	mrs	r3, PSP
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:159

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000c14:	f1a3 0220 	sub.w	r2, r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:160
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000c18:	f382 8809 	msr	PSP, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:161
    ctxp->xpsr = (regarm_t)0x01000000;
 8000c1c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000c20:	f843 2c04 	str.w	r2, [r3, #-4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000c24:	4a0e      	ldr	r2, [pc, #56]	; (8000c60 <_port_irq_epilogue+0x60>)
 8000c26:	6991      	ldr	r1, [r2, #24]
 8000c28:	6812      	ldr	r2, [r2, #0]
 8000c2a:	f891 0022 	ldrb.w	r0, [r1, #34]	; 0x22
 8000c2e:	6892      	ldr	r2, [r2, #8]
 8000c30:	6889      	ldr	r1, [r1, #8]
 8000c32:	b120      	cbz	r0, 8000c3e <_port_irq_epilogue+0x3e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165 (discriminator 1)
 8000c34:	428a      	cmp	r2, r1
 8000c36:	bf94      	ite	ls
 8000c38:	2200      	movls	r2, #0
 8000c3a:	2201      	movhi	r2, #1
 8000c3c:	e003      	b.n	8000c46 <_port_irq_epilogue+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165 (discriminator 2)
 8000c3e:	428a      	cmp	r2, r1
 8000c40:	bf34      	ite	cc
 8000c42:	2200      	movcc	r2, #0
 8000c44:	2201      	movcs	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:165 (discriminator 3)
 8000c46:	b10a      	cbz	r2, 8000c4c <_port_irq_epilogue+0x4c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:167
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
 8000c48:	4a06      	ldr	r2, [pc, #24]	; (8000c64 <_port_irq_epilogue+0x64>)
 8000c4a:	e000      	b.n	8000c4e <_port_irq_epilogue+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:176
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
 8000c4c:	4a06      	ldr	r2, [pc, #24]	; (8000c68 <_port_irq_epilogue+0x68>)
 8000c4e:	f843 2c08 	str.w	r2, [r3, #-8]
 8000c52:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:197

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8000c54:	f383 8811 	msr	BASEPRI, r3
 8000c58:	4770      	bx	lr
 8000c5a:	bf00      	nop
 8000c5c:	e000ed00 	.word	0xe000ed00
 8000c60:	200012ac 	.word	0x200012ac
 8000c64:	08000b91 	.word	0x08000b91
 8000c68:	08000b9c 	.word	0x08000b9c
$d():
 8000c6c:	00000000 	.word	0x00000000

08000c70 <SysTickVector>:
SysTickVector():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:47
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
 8000c70:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:49

  CH_IRQ_PROLOGUE();
 8000c72:	f000 f915 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:51

  chSysLockFromIsr();
 8000c76:	2320      	movs	r3, #32
 8000c78:	f383 8811 	msr	BASEPRI, r3
 8000c7c:	f000 f8e0 	bl	8000e40 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:52
  chSysTimerHandlerI();
 8000c80:	f000 fc06 	bl	8001490 <chSysTimerHandlerI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:53
  chSysUnlockFromIsr();
 8000c84:	f000 f8f4 	bl	8000e70 <dbg_check_unlock_from_isr>
 8000c88:	2300      	movs	r3, #0
 8000c8a:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:55

  CH_IRQ_EPILOGUE();
 8000c8e:	f000 f927 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:56
}
 8000c92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:55

  chSysLockFromIsr();
  chSysTimerHandlerI();
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
 8000c96:	f7ff bfb3 	b.w	8000c00 <_port_irq_epilogue>
 8000c9a:	0000      	movs	r0, r0
 8000c9c:	0000      	movs	r0, r0
	...

08000ca0 <_port_switch>:
_port_switch():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:238
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
 8000ca0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:244
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
 8000ca4:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000ca8:	f8d0 d00c 	ldr.w	sp, [r0, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:250
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
 8000cac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000cb0 <_port_thread_start>:
_port_thread_start():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:259
/**
 * @brief   Start a thread by invoking its work function.
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {
 8000cb0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:261

  chSysUnlock();
 8000cb2:	f000 f8ad 	bl	8000e10 <dbg_check_unlock>
 8000cb6:	2300      	movs	r3, #0
 8000cb8:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/chcore_v7m.c:262
  asm volatile ("mov     r0, r5                                 \n\t"
 8000cbc:	4628      	mov	r0, r5
 8000cbe:	47a0      	blx	r4
 8000cc0:	f000 fcd6 	bl	8001670 <chThdExit>
 8000cc4:	bd08      	pop	{r3, pc}
	...

08000cd0 <__early_init>:
__early_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:234
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __early_init(void) {}
 8000cd0:	4770      	bx	lr
	...

08000ce0 <__late_init>:
__late_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:246
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 8000ce0:	4770      	bx	lr
	...

08000cf0 <_default_exit>:
_default_exit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:257
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak, naked))
#endif
void _default_exit(void) {
 8000cf0:	e7fe      	b.n	8000cf0 <_default_exit>
	...

08000d00 <ResetHandler>:
ResetHandler():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:274
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000d00:	b672      	cpsid	i
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:276
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000d02:	4b22      	ldr	r3, [pc, #136]	; (8000d8c <ResetHandler+0x8c>)
 8000d04:	f383 8809 	msr	PSP, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:296
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000d08:	2302      	movs	r3, #2
 8000d0a:	f383 8814 	msr	CONTROL, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:297
  asm volatile ("isb");
 8000d0e:	f3bf 8f6f 	isb	sy
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000d12:	4b1f      	ldr	r3, [pc, #124]	; (8000d90 <ResetHandler+0x90>)
 8000d14:	4a1d      	ldr	r2, [pc, #116]	; (8000d8c <ResetHandler+0x8c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301 (discriminator 1)
 8000d16:	491f      	ldr	r1, [pc, #124]	; (8000d94 <ResetHandler+0x94>)
 8000d18:	428b      	cmp	r3, r1
 8000d1a:	d204      	bcs.n	8000d26 <ResetHandler+0x26>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301 (discriminator 2)
 8000d1c:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000d20:	f843 1b04 	str.w	r1, [r3], #4
 8000d24:	e7f7      	b.n	8000d16 <ResetHandler+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:301
 8000d26:	4b1c      	ldr	r3, [pc, #112]	; (8000d98 <ResetHandler+0x98>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:304 (discriminator 1)
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000d28:	4293      	cmp	r3, r2
 8000d2a:	d204      	bcs.n	8000d36 <ResetHandler+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:304 (discriminator 2)
 8000d2c:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000d30:	f843 1b04 	str.w	r1, [r3], #4
 8000d34:	e7f8      	b.n	8000d28 <ResetHandler+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:310
         &__process_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
#endif

  /* Early initialization hook invocation.*/
  __early_init();
 8000d36:	f7ff ffcb 	bl	8000cd0 <__early_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000d3a:	2300      	movs	r3, #0
 8000d3c:	4a17      	ldr	r2, [pc, #92]	; (8000d9c <ResetHandler+0x9c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:319 (discriminator 1)
 8000d3e:	4918      	ldr	r1, [pc, #96]	; (8000da0 <ResetHandler+0xa0>)
 8000d40:	1898      	adds	r0, r3, r2
 8000d42:	4288      	cmp	r0, r1
 8000d44:	d204      	bcs.n	8000d50 <ResetHandler+0x50>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:320
      *dp++ = *tp++;
 8000d46:	4917      	ldr	r1, [pc, #92]	; (8000da4 <ResetHandler+0xa4>)
 8000d48:	5859      	ldr	r1, [r3, r1]
 8000d4a:	5099      	str	r1, [r3, r2]
 8000d4c:	3304      	adds	r3, #4
 8000d4e:	e7f5      	b.n	8000d3c <ResetHandler+0x3c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000d50:	4b15      	ldr	r3, [pc, #84]	; (8000da8 <ResetHandler+0xa8>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:326 (discriminator 1)
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000d52:	4a16      	ldr	r2, [pc, #88]	; (8000dac <ResetHandler+0xac>)
 8000d54:	4293      	cmp	r3, r2
 8000d56:	d203      	bcs.n	8000d60 <ResetHandler+0x60>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:326 (discriminator 2)
 8000d58:	2200      	movs	r2, #0
 8000d5a:	f843 2b04 	str.w	r2, [r3], #4
 8000d5e:	e7f8      	b.n	8000d52 <ResetHandler+0x52>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:330
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 8000d60:	f7ff ffbe 	bl	8000ce0 <__late_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:335

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
 8000d64:	4c12      	ldr	r4, [pc, #72]	; (8000db0 <ResetHandler+0xb0>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:336 (discriminator 1)
    while (fpp < &__init_array_end) {
 8000d66:	4b13      	ldr	r3, [pc, #76]	; (8000db4 <ResetHandler+0xb4>)
 8000d68:	429c      	cmp	r4, r3
 8000d6a:	d203      	bcs.n	8000d74 <ResetHandler+0x74>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:337
      (*fpp)();
 8000d6c:	f854 3b04 	ldr.w	r3, [r4], #4
 8000d70:	4798      	blx	r3
 8000d72:	e7f8      	b.n	8000d66 <ResetHandler+0x66>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:344
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000d74:	f7ff f9c4 	bl	8000100 <main>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:349

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
 8000d78:	4c0f      	ldr	r4, [pc, #60]	; (8000db8 <ResetHandler+0xb8>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:350 (discriminator 1)
    while (fpp < &__fini_array_end) {
 8000d7a:	4b10      	ldr	r3, [pc, #64]	; (8000dbc <ResetHandler+0xbc>)
 8000d7c:	429c      	cmp	r4, r3
 8000d7e:	d203      	bcs.n	8000d88 <ResetHandler+0x88>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:351
      (*fpp)();
 8000d80:	f854 3b04 	ldr.w	r3, [r4], #4
 8000d84:	4798      	blx	r3
 8000d86:	e7f8      	b.n	8000d7a <ResetHandler+0x7a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/ports/GCC/ARMCMx/crt0.c:358
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000d88:	f7ff ffb2 	bl	8000cf0 <_default_exit>
 8000d8c:	20000800 	.word	0x20000800
 8000d90:	20000000 	.word	0x20000000
 8000d94:	20000400 	.word	0x20000400
 8000d98:	20000400 	.word	0x20000400
 8000d9c:	20000800 	.word	0x20000800
 8000da0:	20000800 	.word	0x20000800
 8000da4:	080031c8 	.word	0x080031c8
 8000da8:	20000800 	.word	0x20000800
 8000dac:	20001380 	.word	0x20001380
 8000db0:	080000f4 	.word	0x080000f4
 8000db4:	080000f4 	.word	0x080000f4
 8000db8:	080000f4 	.word	0x080000f4
 8000dbc:	080000f4 	.word	0x080000f4

08000dc0 <dbg_check_enable>:
dbg_check_enable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:105
 *
 * @notapi
 */
void dbg_check_enable(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt != 0))
 8000dc0:	4b04      	ldr	r3, [pc, #16]	; (8000dd4 <dbg_check_enable+0x14>)
 8000dc2:	681b      	ldr	r3, [r3, #0]
 8000dc4:	b913      	cbnz	r3, 8000dcc <dbg_check_enable+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:105 (discriminator 1)
 8000dc6:	4b04      	ldr	r3, [pc, #16]	; (8000dd8 <dbg_check_enable+0x18>)
 8000dc8:	681b      	ldr	r3, [r3, #0]
 8000dca:	b113      	cbz	r3, 8000dd2 <dbg_check_enable+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:106
    chDbgPanic("SV#3");
 8000dcc:	4803      	ldr	r0, [pc, #12]	; (8000ddc <dbg_check_enable+0x1c>)
 8000dce:	f001 b947 	b.w	8002060 <chDbgPanic>
 8000dd2:	4770      	bx	lr
 8000dd4:	200012a4 	.word	0x200012a4
 8000dd8:	200012a8 	.word	0x200012a8
 8000ddc:	08002e1a 	.word	0x08002e1a

08000de0 <dbg_check_lock>:
dbg_check_lock():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:116
 *
 * @notapi
 */
void dbg_check_lock(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt != 0))
 8000de0:	4b06      	ldr	r3, [pc, #24]	; (8000dfc <dbg_check_lock+0x1c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:114
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void dbg_check_lock(void) {
 8000de2:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:116

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt != 0))
 8000de4:	681b      	ldr	r3, [r3, #0]
 8000de6:	4c06      	ldr	r4, [pc, #24]	; (8000e00 <dbg_check_lock+0x20>)
 8000de8:	b90b      	cbnz	r3, 8000dee <dbg_check_lock+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:116 (discriminator 1)
 8000dea:	6823      	ldr	r3, [r4, #0]
 8000dec:	b113      	cbz	r3, 8000df4 <dbg_check_lock+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:117
    chDbgPanic("SV#4");
 8000dee:	4805      	ldr	r0, [pc, #20]	; (8000e04 <dbg_check_lock+0x24>)
 8000df0:	f001 f936 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:118
  dbg_enter_lock();
 8000df4:	2301      	movs	r3, #1
 8000df6:	6023      	str	r3, [r4, #0]
 8000df8:	bd10      	pop	{r4, pc}
 8000dfa:	bf00      	nop
 8000dfc:	200012a4 	.word	0x200012a4
 8000e00:	200012a8 	.word	0x200012a8
 8000e04:	08002e1f 	.word	0x08002e1f
	...

08000e10 <dbg_check_unlock>:
dbg_check_unlock():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:128
 *
 * @notapi
 */
void dbg_check_unlock(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt <= 0))
 8000e10:	4b06      	ldr	r3, [pc, #24]	; (8000e2c <dbg_check_unlock+0x1c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:126
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void dbg_check_unlock(void) {
 8000e12:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:128

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt <= 0))
 8000e14:	681b      	ldr	r3, [r3, #0]
 8000e16:	4c06      	ldr	r4, [pc, #24]	; (8000e30 <dbg_check_unlock+0x20>)
 8000e18:	b913      	cbnz	r3, 8000e20 <dbg_check_unlock+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:128 (discriminator 1)
 8000e1a:	6823      	ldr	r3, [r4, #0]
 8000e1c:	2b00      	cmp	r3, #0
 8000e1e:	dc02      	bgt.n	8000e26 <dbg_check_unlock+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:129
    chDbgPanic("SV#5");
 8000e20:	4804      	ldr	r0, [pc, #16]	; (8000e34 <dbg_check_unlock+0x24>)
 8000e22:	f001 f91d 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:130
  dbg_leave_lock();
 8000e26:	2300      	movs	r3, #0
 8000e28:	6023      	str	r3, [r4, #0]
 8000e2a:	bd10      	pop	{r4, pc}
 8000e2c:	200012a4 	.word	0x200012a4
 8000e30:	200012a8 	.word	0x200012a8
 8000e34:	08002e24 	.word	0x08002e24
	...

08000e40 <dbg_check_lock_from_isr>:
dbg_check_lock_from_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:140
 *
 * @notapi
 */
void dbg_check_lock_from_isr(void) {

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt != 0))
 8000e40:	4b06      	ldr	r3, [pc, #24]	; (8000e5c <dbg_check_lock_from_isr+0x1c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:138
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void dbg_check_lock_from_isr(void) {
 8000e42:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:140

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt != 0))
 8000e44:	681b      	ldr	r3, [r3, #0]
 8000e46:	4c06      	ldr	r4, [pc, #24]	; (8000e60 <dbg_check_lock_from_isr+0x20>)
 8000e48:	2b00      	cmp	r3, #0
 8000e4a:	dd01      	ble.n	8000e50 <dbg_check_lock_from_isr+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:140 (discriminator 1)
 8000e4c:	6823      	ldr	r3, [r4, #0]
 8000e4e:	b113      	cbz	r3, 8000e56 <dbg_check_lock_from_isr+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:141
    chDbgPanic("SV#6");
 8000e50:	4804      	ldr	r0, [pc, #16]	; (8000e64 <dbg_check_lock_from_isr+0x24>)
 8000e52:	f001 f905 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:142
  dbg_enter_lock();
 8000e56:	2301      	movs	r3, #1
 8000e58:	6023      	str	r3, [r4, #0]
 8000e5a:	bd10      	pop	{r4, pc}
 8000e5c:	200012a4 	.word	0x200012a4
 8000e60:	200012a8 	.word	0x200012a8
 8000e64:	08002e29 	.word	0x08002e29
	...

08000e70 <dbg_check_unlock_from_isr>:
dbg_check_unlock_from_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:152
 *
 * @notapi
 */
void dbg_check_unlock_from_isr(void) {

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt <= 0))
 8000e70:	4b07      	ldr	r3, [pc, #28]	; (8000e90 <dbg_check_unlock_from_isr+0x20>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:150
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void dbg_check_unlock_from_isr(void) {
 8000e72:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:152

  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt <= 0))
 8000e74:	681b      	ldr	r3, [r3, #0]
 8000e76:	4c07      	ldr	r4, [pc, #28]	; (8000e94 <dbg_check_unlock_from_isr+0x24>)
 8000e78:	2b00      	cmp	r3, #0
 8000e7a:	dd02      	ble.n	8000e82 <dbg_check_unlock_from_isr+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:152 (discriminator 1)
 8000e7c:	6823      	ldr	r3, [r4, #0]
 8000e7e:	2b00      	cmp	r3, #0
 8000e80:	dc02      	bgt.n	8000e88 <dbg_check_unlock_from_isr+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:153
    chDbgPanic("SV#7");
 8000e82:	4805      	ldr	r0, [pc, #20]	; (8000e98 <dbg_check_unlock_from_isr+0x28>)
 8000e84:	f001 f8ec 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:154
  dbg_leave_lock();
 8000e88:	2300      	movs	r3, #0
 8000e8a:	6023      	str	r3, [r4, #0]
 8000e8c:	bd10      	pop	{r4, pc}
 8000e8e:	bf00      	nop
 8000e90:	200012a4 	.word	0x200012a4
 8000e94:	200012a8 	.word	0x200012a8
 8000e98:	08002e2e 	.word	0x08002e2e
$d():
 8000e9c:	00000000 	.word	0x00000000

08000ea0 <dbg_check_enter_isr>:
dbg_check_enter_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:162
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void dbg_check_enter_isr(void) {
 8000ea0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:164

  port_lock_from_isr();
 8000ea2:	2320      	movs	r3, #32
 8000ea4:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:165
  if ((dbg_isr_cnt < 0) || (dbg_lock_cnt != 0))
 8000ea8:	4c08      	ldr	r4, [pc, #32]	; (8000ecc <dbg_check_enter_isr+0x2c>)
 8000eaa:	6823      	ldr	r3, [r4, #0]
 8000eac:	2b00      	cmp	r3, #0
 8000eae:	db02      	blt.n	8000eb6 <dbg_check_enter_isr+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:165 (discriminator 1)
 8000eb0:	4b07      	ldr	r3, [pc, #28]	; (8000ed0 <dbg_check_enter_isr+0x30>)
 8000eb2:	681b      	ldr	r3, [r3, #0]
 8000eb4:	b113      	cbz	r3, 8000ebc <dbg_check_enter_isr+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:166
    chDbgPanic("SV#8");
 8000eb6:	4807      	ldr	r0, [pc, #28]	; (8000ed4 <dbg_check_enter_isr+0x34>)
 8000eb8:	f001 f8d2 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:167
  dbg_isr_cnt++;
 8000ebc:	6823      	ldr	r3, [r4, #0]
 8000ebe:	3301      	adds	r3, #1
 8000ec0:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:168
  port_unlock_from_isr();
 8000ec2:	2300      	movs	r3, #0
 8000ec4:	f383 8811 	msr	BASEPRI, r3
 8000ec8:	bd10      	pop	{r4, pc}
 8000eca:	bf00      	nop
 8000ecc:	200012a4 	.word	0x200012a4
 8000ed0:	200012a8 	.word	0x200012a8
 8000ed4:	08002e33 	.word	0x08002e33
	...

08000ee0 <dbg_check_leave_isr>:
dbg_check_leave_isr():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:176
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void dbg_check_leave_isr(void) {
 8000ee0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:178

  port_lock_from_isr();
 8000ee2:	2320      	movs	r3, #32
 8000ee4:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:179
  if ((dbg_isr_cnt <= 0) || (dbg_lock_cnt != 0))
 8000ee8:	4c08      	ldr	r4, [pc, #32]	; (8000f0c <dbg_check_leave_isr+0x2c>)
 8000eea:	6823      	ldr	r3, [r4, #0]
 8000eec:	2b00      	cmp	r3, #0
 8000eee:	dd02      	ble.n	8000ef6 <dbg_check_leave_isr+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:179 (discriminator 1)
 8000ef0:	4b07      	ldr	r3, [pc, #28]	; (8000f10 <dbg_check_leave_isr+0x30>)
 8000ef2:	681b      	ldr	r3, [r3, #0]
 8000ef4:	b113      	cbz	r3, 8000efc <dbg_check_leave_isr+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:180
    chDbgPanic("SV#9");
 8000ef6:	4807      	ldr	r0, [pc, #28]	; (8000f14 <dbg_check_leave_isr+0x34>)
 8000ef8:	f001 f8b2 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:181
  dbg_isr_cnt--;
 8000efc:	6823      	ldr	r3, [r4, #0]
 8000efe:	3b01      	subs	r3, #1
 8000f00:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:182
  port_unlock_from_isr();
 8000f02:	2300      	movs	r3, #0
 8000f04:	f383 8811 	msr	BASEPRI, r3
 8000f08:	bd10      	pop	{r4, pc}
 8000f0a:	bf00      	nop
 8000f0c:	200012a4 	.word	0x200012a4
 8000f10:	200012a8 	.word	0x200012a8
 8000f14:	08002e38 	.word	0x08002e38
	...

08000f20 <chDbgCheckClassI>:
chDbgCheckClassI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:195
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((dbg_isr_cnt < 0) || (dbg_lock_cnt <= 0))
 8000f20:	4b05      	ldr	r3, [pc, #20]	; (8000f38 <chDbgCheckClassI+0x18>)
 8000f22:	681b      	ldr	r3, [r3, #0]
 8000f24:	2b00      	cmp	r3, #0
 8000f26:	db03      	blt.n	8000f30 <chDbgCheckClassI+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:195 (discriminator 1)
 8000f28:	4b04      	ldr	r3, [pc, #16]	; (8000f3c <chDbgCheckClassI+0x1c>)
 8000f2a:	681b      	ldr	r3, [r3, #0]
 8000f2c:	2b00      	cmp	r3, #0
 8000f2e:	dc02      	bgt.n	8000f36 <chDbgCheckClassI+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:196
    chDbgPanic("SV#10");
 8000f30:	4803      	ldr	r0, [pc, #12]	; (8000f40 <chDbgCheckClassI+0x20>)
 8000f32:	f001 b895 	b.w	8002060 <chDbgPanic>
 8000f36:	4770      	bx	lr
 8000f38:	200012a4 	.word	0x200012a4
 8000f3c:	200012a8 	.word	0x200012a8
 8000f40:	08002e3d 	.word	0x08002e3d
	...

08000f50 <chDbgCheckClassS>:
chDbgCheckClassS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:209
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((dbg_isr_cnt != 0) || (dbg_lock_cnt <= 0))
 8000f50:	4b05      	ldr	r3, [pc, #20]	; (8000f68 <chDbgCheckClassS+0x18>)
 8000f52:	681b      	ldr	r3, [r3, #0]
 8000f54:	b91b      	cbnz	r3, 8000f5e <chDbgCheckClassS+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:209 (discriminator 1)
 8000f56:	4b05      	ldr	r3, [pc, #20]	; (8000f6c <chDbgCheckClassS+0x1c>)
 8000f58:	681b      	ldr	r3, [r3, #0]
 8000f5a:	2b00      	cmp	r3, #0
 8000f5c:	dc02      	bgt.n	8000f64 <chDbgCheckClassS+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:210
    chDbgPanic("SV#11");
 8000f5e:	4804      	ldr	r0, [pc, #16]	; (8000f70 <chDbgCheckClassS+0x20>)
 8000f60:	f001 b87e 	b.w	8002060 <chDbgPanic>
 8000f64:	4770      	bx	lr
 8000f66:	bf00      	nop
 8000f68:	200012a4 	.word	0x200012a4
 8000f6c:	200012a8 	.word	0x200012a8
 8000f70:	08002e43 	.word	0x08002e43
	...

08000f80 <_trace_init>:
_trace_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:231
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {

  dbg_trace_buffer.tb_size = CH_TRACE_BUFFER_SIZE;
 8000f80:	4a03      	ldr	r2, [pc, #12]	; (8000f90 <_trace_init+0x10>)
 8000f82:	2140      	movs	r1, #64	; 0x40
 8000f84:	4613      	mov	r3, r2
 8000f86:	f843 1b08 	str.w	r1, [r3], #8
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:232
  dbg_trace_buffer.tb_ptr = &dbg_trace_buffer.tb_buffer[0];
 8000f8a:	6053      	str	r3, [r2, #4]
 8000f8c:	4770      	bx	lr
 8000f8e:	bf00      	nop
 8000f90:	20000e98 	.word	0x20000e98
	...

08000fa0 <dbg_trace>:
dbg_trace():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:244
 *
 * @notapi
 */
void dbg_trace(Thread *otp) {

  dbg_trace_buffer.tb_ptr->se_time   = chTimeNow();
 8000fa0:	4b0c      	ldr	r3, [pc, #48]	; (8000fd4 <dbg_trace+0x34>)
 8000fa2:	490d      	ldr	r1, [pc, #52]	; (8000fd8 <dbg_trace+0x38>)
 8000fa4:	685a      	ldr	r2, [r3, #4]
 8000fa6:	68c9      	ldr	r1, [r1, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:248
  dbg_trace_buffer.tb_ptr->se_tp     = currp;
  dbg_trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
  dbg_trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
  if (++dbg_trace_buffer.tb_ptr >=
 8000fa8:	3210      	adds	r2, #16
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:244
 *
 * @notapi
 */
void dbg_trace(Thread *otp) {

  dbg_trace_buffer.tb_ptr->se_time   = chTimeNow();
 8000faa:	f842 1c10 	str.w	r1, [r2, #-16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:245
  dbg_trace_buffer.tb_ptr->se_tp     = currp;
 8000fae:	490b      	ldr	r1, [pc, #44]	; (8000fdc <dbg_trace+0x3c>)
 8000fb0:	6989      	ldr	r1, [r1, #24]
 8000fb2:	f842 1c0c 	str.w	r1, [r2, #-12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:246
  dbg_trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8000fb6:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8000fb8:	f842 1c08 	str.w	r1, [r2, #-8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:247
  dbg_trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000fbc:	f890 1020 	ldrb.w	r1, [r0, #32]
 8000fc0:	f802 1c04 	strb.w	r1, [r2, #-4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:248
  if (++dbg_trace_buffer.tb_ptr >=
 8000fc4:	f503 6181 	add.w	r1, r3, #1032	; 0x408
 8000fc8:	428a      	cmp	r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chdebug.c:250
      &dbg_trace_buffer.tb_buffer[CH_TRACE_BUFFER_SIZE])
    dbg_trace_buffer.tb_ptr = &dbg_trace_buffer.tb_buffer[0];
 8000fca:	bf28      	it	cs
 8000fcc:	f103 0208 	addcs.w	r2, r3, #8
 8000fd0:	605a      	str	r2, [r3, #4]
 8000fd2:	4770      	bx	lr
 8000fd4:	20000e98 	.word	0x20000e98
 8000fd8:	20001370 	.word	0x20001370
 8000fdc:	200012ac 	.word	0x200012ac

08000fe0 <chEvtSignalI>:
chEvtSignalI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:251
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
 8000fe0:	b538      	push	{r3, r4, r5, lr}
 8000fe2:	4604      	mov	r4, r0
 8000fe4:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:253

  chDbgCheckClassI();
 8000fe6:	f7ff ff9b 	bl	8000f20 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:254
  chDbgCheck(tp != NULL, "chEvtSignalI");
 8000fea:	b914      	cbnz	r4, 8000ff2 <chEvtSignalI+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:254 (discriminator 1)
 8000fec:	480d      	ldr	r0, [pc, #52]	; (8001024 <chEvtSignalI+0x44>)
 8000fee:	f001 f837 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:256

  tp->p_epending |= mask;
 8000ff2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000ff4:	ea45 0103 	orr.w	r1, r5, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:258
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8000ff8:	f894 3020 	ldrb.w	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:256
void chEvtSignalI(Thread *tp, eventmask_t mask) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
 8000ffc:	6321      	str	r1, [r4, #48]	; 0x30
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:258
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8000ffe:	2b08      	cmp	r3, #8
 8001000:	d103      	bne.n	800100a <chEvtSignalI+0x2a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:259 (discriminator 1)
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8001002:	6aa3      	ldr	r3, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:258 (discriminator 1)
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8001004:	4219      	tst	r1, r3
 8001006:	d106      	bne.n	8001016 <chEvtSignalI+0x36>
 8001008:	bd38      	pop	{r3, r4, r5, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:259
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 800100a:	2b09      	cmp	r3, #9
 800100c:	d108      	bne.n	8001020 <chEvtSignalI+0x40>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:261
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
 800100e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001010:	4019      	ands	r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:260

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
 8001012:	4299      	cmp	r1, r3
 8001014:	d104      	bne.n	8001020 <chEvtSignalI+0x40>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:262
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
 8001016:	4620      	mov	r0, r4
 8001018:	f000 f83a 	bl	8001090 <chSchReadyI>
 800101c:	2300      	movs	r3, #0
 800101e:	6283      	str	r3, [r0, #40]	; 0x28
 8001020:	bd38      	pop	{r3, r4, r5, pc}
 8001022:	bf00      	nop
 8001024:	08002e7a 	.word	0x08002e7a
	...

08001030 <chEvtWaitAny>:
chEvtWaitAny():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:380
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
  Thread *ctp = currp;
 8001030:	4b0e      	ldr	r3, [pc, #56]	; (800106c <chEvtWaitAny+0x3c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:379
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
 8001032:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:380
  Thread *ctp = currp;
 8001034:	699c      	ldr	r4, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:379
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
 8001036:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:383
  Thread *ctp = currp;
  eventmask_t m;

  chSysLock();
 8001038:	2320      	movs	r3, #32
 800103a:	f383 8811 	msr	BASEPRI, r3
 800103e:	f7ff fecf 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:385

  if ((m = (ctp->p_epending & mask)) == 0) {
 8001042:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8001044:	402e      	ands	r6, r5
 8001046:	d105      	bne.n	8001054 <chEvtWaitAny+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:386
    ctp->p_u.ewmask = mask;
 8001048:	62a5      	str	r5, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:387
    chSchGoSleepS(THD_STATE_WTOREVT);
 800104a:	2008      	movs	r0, #8
 800104c:	f000 f868 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:388
    m = ctp->p_epending & mask;
 8001050:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8001052:	402e      	ands	r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:390
  }
  ctp->p_epending &= ~m;
 8001054:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001056:	ea23 0306 	bic.w	r3, r3, r6
 800105a:	6323      	str	r3, [r4, #48]	; 0x30
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:392

  chSysUnlock();
 800105c:	f7ff fed8 	bl	8000e10 <dbg_check_unlock>
 8001060:	2300      	movs	r3, #0
 8001062:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chevents.c:394
  return m;
}
 8001066:	4630      	mov	r0, r6
 8001068:	bd70      	pop	{r4, r5, r6, pc}
 800106a:	bf00      	nop
 800106c:	200012ac 	.word	0x200012ac

08001070 <_scheduler_init>:
_scheduler_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8001070:	4b03      	ldr	r3, [pc, #12]	; (8001080 <_scheduler_init+0x10>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8001072:	2200      	movs	r2, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8001074:	605b      	str	r3, [r3, #4]
 8001076:	601b      	str	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8001078:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:60
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 800107a:	615b      	str	r3, [r3, #20]
 800107c:	611b      	str	r3, [r3, #16]
 800107e:	4770      	bx	lr
 8001080:	200012ac 	.word	0x200012ac
	...

08001090 <chSchReadyI>:
chSchReadyI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 8001090:	b510      	push	{r4, lr}
 8001092:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:84
  Thread *cp;

  chDbgCheckClassI();
 8001094:	f7ff ff44 	bl	8000f20 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:87

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 8001098:	f894 3020 	ldrb.w	r3, [r4, #32]
 800109c:	b10b      	cbz	r3, 80010a2 <chSchReadyI+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:87 (discriminator 2)
 800109e:	2b0e      	cmp	r3, #14
 80010a0:	d102      	bne.n	80010a8 <chSchReadyI+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:87 (discriminator 1)
 80010a2:	4809      	ldr	r0, [pc, #36]	; (80010c8 <chSchReadyI+0x38>)
 80010a4:	f000 ffdc 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:92
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 80010a8:	2300      	movs	r3, #0
 80010aa:	f884 3020 	strb.w	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:96
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 80010ae:	68a1      	ldr	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:93
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 80010b0:	4b06      	ldr	r3, [pc, #24]	; (80010cc <chSchReadyI+0x3c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:95 (discriminator 1)
  do {
    cp = cp->p_next;
 80010b2:	681b      	ldr	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:96 (discriminator 1)
  } while (cp->p_prio >= tp->p_prio);
 80010b4:	689a      	ldr	r2, [r3, #8]
 80010b6:	428a      	cmp	r2, r1
 80010b8:	d2fb      	bcs.n	80010b2 <chSchReadyI+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:99
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80010ba:	685a      	ldr	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:98
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80010bc:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:99
  tp->p_prev = cp->p_prev;
 80010be:	6062      	str	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:102
  tp->p_prev->p_next = cp->p_prev = tp;
  return tp;
}
 80010c0:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:100
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80010c2:	605c      	str	r4, [r3, #4]
 80010c4:	6014      	str	r4, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:102
  return tp;
}
 80010c6:	bd10      	pop	{r4, pc}
 80010c8:	08002f00 	.word	0x08002f00
 80010cc:	200012ac 	.word	0x200012ac

080010d0 <wakeup>:
wakeup():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:136

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80010d0:	b538      	push	{r3, r4, r5, lr}
 80010d2:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:139
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
 80010d4:	2320      	movs	r3, #32
 80010d6:	f383 8811 	msr	BASEPRI, r3
 80010da:	f7ff feb1 	bl	8000e40 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:140
  switch (tp->p_state) {
 80010de:	f894 5020 	ldrb.w	r5, [r4, #32]
 80010e2:	b15d      	cbz	r5, 80010fc <wakeup+0x2c>
 80010e4:	2d03      	cmp	r5, #3
 80010e6:	d10d      	bne.n	8001104 <wakeup+0x34>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:150
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 80010e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80010ea:	689a      	ldr	r2, [r3, #8]
 80010ec:	3201      	adds	r2, #1
 80010ee:	609a      	str	r2, [r3, #8]
dequeue():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:75
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
 80010f0:	e894 000c 	ldmia.w	r4, {r2, r3}
 80010f4:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:76
  tp->p_next->p_prev = tp->p_prev;
 80010f6:	6822      	ldr	r2, [r4, #0]
 80010f8:	6053      	str	r3, [r2, #4]
 80010fa:	e003      	b.n	8001104 <wakeup+0x34>
wakeup():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:144
  chSysLockFromIsr();
  switch (tp->p_state) {
  case THD_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromIsr();
 80010fc:	f7ff feb8 	bl	8000e70 <dbg_check_unlock_from_isr>
 8001100:	462b      	mov	r3, r5
 8001102:	e008      	b.n	8001116 <wakeup+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:163
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 8001104:	f04f 33ff 	mov.w	r3, #4294967295
 8001108:	62a3      	str	r3, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:164
  chSchReadyI(tp);
 800110a:	4620      	mov	r0, r4
 800110c:	f7ff ffc0 	bl	8001090 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:165
  chSysUnlockFromIsr();
 8001110:	f7ff feae 	bl	8000e70 <dbg_check_unlock_from_isr>
 8001114:	2300      	movs	r3, #0
 8001116:	f383 8811 	msr	BASEPRI, r3
 800111a:	bd38      	pop	{r3, r4, r5, pc}
 800111c:	0000      	movs	r0, r0
	...

08001120 <chSchGoSleepS>:
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:115
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
 8001120:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:120
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8001122:	4c11      	ldr	r4, [pc, #68]	; (8001168 <chSchGoSleepS+0x48>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:115
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
 8001124:	4606      	mov	r6, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:118
  Thread *otp;

  chDbgCheckClassS();
 8001126:	f7ff ff13 	bl	8000f50 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:120

  (otp = currp)->p_state = newstate;
 800112a:	69a5      	ldr	r5, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 800112c:	2314      	movs	r3, #20
 800112e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8001132:	6823      	ldr	r3, [r4, #0]
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8001134:	f885 6020 	strb.w	r6, [r5, #32]
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8001138:	681a      	ldr	r2, [r3, #0]
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800113a:	4628      	mov	r0, r5
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62
 800113c:	6054      	str	r4, [r2, #4]
 800113e:	6022      	str	r2, [r4, #0]
chSchGoSleepS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:127
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8001140:	2201      	movs	r2, #1
 8001142:	f883 2020 	strb.w	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:126
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 8001146:	61a3      	str	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8001148:	f7ff ff2a 	bl	8000fa0 <dbg_trace>
 800114c:	69eb      	ldr	r3, [r5, #28]
 800114e:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 8001152:	4293      	cmp	r3, r2
 8001154:	d902      	bls.n	800115c <chSchGoSleepS+0x3c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128 (discriminator 1)
 8001156:	4805      	ldr	r0, [pc, #20]	; (800116c <chSchGoSleepS+0x4c>)
 8001158:	f000 ff82 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128 (discriminator 2)
 800115c:	69a0      	ldr	r0, [r4, #24]
 800115e:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:129 (discriminator 2)
}
 8001160:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:128 (discriminator 2)
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8001164:	f7ff bd9c 	b.w	8000ca0 <_port_switch>
 8001168:	200012ac 	.word	0x200012ac
 800116c:	08002f12 	.word	0x08002f12

08001170 <chSchGoSleepTimeoutS>:
chSchGoSleepTimeoutS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001170:	b570      	push	{r4, r5, r6, lr}
 8001172:	460e      	mov	r6, r1
 8001174:	b086      	sub	sp, #24
 8001176:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:191

  chDbgCheckClassS();
 8001178:	f7ff feea 	bl	8000f50 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:193

  if (TIME_INFINITE != time) {
 800117c:	1c73      	adds	r3, r6, #1
 800117e:	4c0c      	ldr	r4, [pc, #48]	; (80011b0 <chSchGoSleepTimeoutS+0x40>)
 8001180:	d00e      	beq.n	80011a0 <chSchGoSleepTimeoutS+0x30>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:196
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 8001182:	69a3      	ldr	r3, [r4, #24]
 8001184:	a801      	add	r0, sp, #4
 8001186:	4631      	mov	r1, r6
 8001188:	4a0a      	ldr	r2, [pc, #40]	; (80011b4 <chSchGoSleepTimeoutS+0x44>)
 800118a:	f000 fa91 	bl	80016b0 <chVTSetI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:197
    chSchGoSleepS(newstate);
 800118e:	4628      	mov	r0, r5
 8001190:	f7ff ffc6 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:198
    if (chVTIsArmedI(&vt))
 8001194:	9b04      	ldr	r3, [sp, #16]
 8001196:	b133      	cbz	r3, 80011a6 <chSchGoSleepTimeoutS+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:199
      chVTResetI(&vt);
 8001198:	a801      	add	r0, sp, #4
 800119a:	f000 fab1 	bl	8001700 <chVTResetI>
 800119e:	e002      	b.n	80011a6 <chSchGoSleepTimeoutS+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:202
  }
  else
    chSchGoSleepS(newstate);
 80011a0:	4628      	mov	r0, r5
 80011a2:	f7ff ffbd 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:203
  return currp->p_u.rdymsg;
 80011a6:	69a3      	ldr	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:204
}
 80011a8:	6a98      	ldr	r0, [r3, #40]	; 0x28
 80011aa:	b006      	add	sp, #24
 80011ac:	bd70      	pop	{r4, r5, r6, pc}
 80011ae:	bf00      	nop
 80011b0:	200012ac 	.word	0x200012ac
 80011b4:	080010d1 	.word	0x080010d1
	...

080011c0 <chSchWakeupS>:
chSchWakeupS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 80011c0:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80011c2:	4e13      	ldr	r6, [pc, #76]	; (8001210 <chSchWakeupS+0x50>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 80011c4:	4604      	mov	r4, r0
 80011c6:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:227

  chDbgCheckClassS();
 80011c8:	f7ff fec2 	bl	8000f50 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80011cc:	69b0      	ldr	r0, [r6, #24]
 80011ce:	68a2      	ldr	r2, [r4, #8]
 80011d0:	6883      	ldr	r3, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:229
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 80011d2:	62a5      	str	r5, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:234
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80011d4:	429a      	cmp	r2, r3
 80011d6:	d804      	bhi.n	80011e2 <chSchWakeupS+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:235
    chSchReadyI(ntp);
 80011d8:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:242
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80011da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:235
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
 80011de:	f7ff bf57 	b.w	8001090 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:237
  else {
    Thread *otp = chSchReadyI(currp);
 80011e2:	f7ff ff55 	bl	8001090 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80011e6:	2301      	movs	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:237
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
 80011e8:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80011ea:	f884 3020 	strb.w	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:238
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80011ee:	61b4      	str	r4, [r6, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80011f0:	f7ff fed6 	bl	8000fa0 <dbg_trace>
 80011f4:	69eb      	ldr	r3, [r5, #28]
 80011f6:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 80011fa:	4293      	cmp	r3, r2
 80011fc:	d902      	bls.n	8001204 <chSchWakeupS+0x44>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240 (discriminator 1)
 80011fe:	4805      	ldr	r0, [pc, #20]	; (8001214 <chSchWakeupS+0x54>)
 8001200:	f000 ff2e 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240 (discriminator 2)
 8001204:	4620      	mov	r0, r4
 8001206:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:242 (discriminator 2)
  }
}
 8001208:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:240 (discriminator 2)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800120c:	f7ff bd48 	b.w	8000ca0 <_port_switch>
 8001210:	200012ac 	.word	0x200012ac
 8001214:	08002f12 	.word	0x08002f12
	...

08001220 <chSchDoRescheduleBehind>:
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:304
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
 8001220:	b538      	push	{r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:307
  Thread *otp;

  otp = currp;
 8001222:	4c10      	ldr	r4, [pc, #64]	; (8001264 <chSchDoRescheduleBehind+0x44>)
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8001224:	6823      	ldr	r3, [r4, #0]
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:307
 8001226:	69a5      	ldr	r5, [r4, #24]
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8001228:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:314
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
 800122a:	4628      	mov	r0, r5
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62
 800122c:	6054      	str	r4, [r2, #4]
 800122e:	6022      	str	r2, [r4, #0]
chSchDoRescheduleBehind():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:310
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8001230:	2201      	movs	r2, #1
 8001232:	f883 2020 	strb.w	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:309
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8001236:	61a3      	str	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:312
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
 8001238:	2314      	movs	r3, #20
 800123a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:314
#endif
  chSchReadyI(otp);
 800123e:	f7ff ff27 	bl	8001090 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315
  chSysSwitch(currp, otp);
 8001242:	4628      	mov	r0, r5
 8001244:	f7ff feac 	bl	8000fa0 <dbg_trace>
 8001248:	69eb      	ldr	r3, [r5, #28]
 800124a:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 800124e:	4293      	cmp	r3, r2
 8001250:	d902      	bls.n	8001258 <chSchDoRescheduleBehind+0x38>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315 (discriminator 1)
 8001252:	4805      	ldr	r0, [pc, #20]	; (8001268 <chSchDoRescheduleBehind+0x48>)
 8001254:	f000 ff04 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315 (discriminator 2)
 8001258:	69a0      	ldr	r0, [r4, #24]
 800125a:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:316 (discriminator 2)
}
 800125c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:315 (discriminator 2)
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8001260:	f7ff bd1e 	b.w	8000ca0 <_port_switch>
 8001264:	200012ac 	.word	0x200012ac
 8001268:	08002f12 	.word	0x08002f12
$d():
 800126c:	00000000 	.word	0x00000000

08001270 <chSchDoRescheduleAhead>:
chSchDoRescheduleAhead():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:329
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
 8001270:	b538      	push	{r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:332
  Thread *otp, *cp;

  otp = currp;
 8001272:	4b14      	ldr	r3, [pc, #80]	; (80012c4 <chSchDoRescheduleAhead+0x54>)
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8001274:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleAhead():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:332
 8001276:	699c      	ldr	r4, [r3, #24]
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8001278:	6811      	ldr	r1, [r2, #0]
 800127a:	461d      	mov	r5, r3
 800127c:	604b      	str	r3, [r1, #4]
 800127e:	6019      	str	r1, [r3, #0]
chSchDoRescheduleAhead():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:335
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8001280:	2101      	movs	r1, #1
 8001282:	f882 1020 	strb.w	r1, [r2, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:334
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8001286:	619a      	str	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:341

  otp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8001288:	68a1      	ldr	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:337
  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;

  otp->p_state = THD_STATE_READY;
 800128a:	2200      	movs	r2, #0
 800128c:	f884 2020 	strb.w	r2, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:340 (discriminator 1)
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
 8001290:	681b      	ldr	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:341 (discriminator 1)
  } while (cp->p_prio > otp->p_prio);
 8001292:	689a      	ldr	r2, [r3, #8]
 8001294:	428a      	cmp	r2, r1
 8001296:	d8fb      	bhi.n	8001290 <chSchDoRescheduleAhead+0x20>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:344
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001298:	685a      	ldr	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:343
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800129a:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:344
  otp->p_prev = cp->p_prev;
 800129c:	6062      	str	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800129e:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:345
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 80012a0:	605c      	str	r4, [r3, #4]
 80012a2:	6014      	str	r4, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347

  chSysSwitch(currp, otp);
 80012a4:	f7ff fe7c 	bl	8000fa0 <dbg_trace>
 80012a8:	69e3      	ldr	r3, [r4, #28]
 80012aa:	f1ad 0224 	sub.w	r2, sp, #36	; 0x24
 80012ae:	4293      	cmp	r3, r2
 80012b0:	d902      	bls.n	80012b8 <chSchDoRescheduleAhead+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347 (discriminator 1)
 80012b2:	4805      	ldr	r0, [pc, #20]	; (80012c8 <chSchDoRescheduleAhead+0x58>)
 80012b4:	f000 fed4 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347 (discriminator 2)
 80012b8:	69a8      	ldr	r0, [r5, #24]
 80012ba:	4621      	mov	r1, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:348 (discriminator 2)
}
 80012bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:347 (discriminator 2)
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80012c0:	f7ff bcee 	b.w	8000ca0 <_port_switch>
 80012c4:	200012ac 	.word	0x200012ac
 80012c8:	08002f12 	.word	0x08002f12
$d():
 80012cc:	00000000 	.word	0x00000000

080012d0 <chSchDoReschedule>:
chSchDoReschedule():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:367
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
 80012d0:	4b04      	ldr	r3, [pc, #16]	; (80012e4 <chSchDoReschedule+0x14>)
 80012d2:	699b      	ldr	r3, [r3, #24]
 80012d4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80012d8:	b90b      	cbnz	r3, 80012de <chSchDoReschedule+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:370
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 80012da:	f7ff bfa1 	b.w	8001220 <chSchDoRescheduleBehind>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chschd.c:375
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 80012de:	f7ff bfc7 	b.w	8001270 <chSchDoRescheduleAhead>
 80012e2:	bf00      	nop
 80012e4:	200012ac 	.word	0x200012ac
	...

080012f0 <chSemInit>:
chSemInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:86
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemInit(Semaphore *sp, cnt_t n) {
 80012f0:	b538      	push	{r3, r4, r5, lr}
 80012f2:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:88

  chDbgCheck((sp != NULL) && (n >= 0), "chSemInit");
 80012f4:	4604      	mov	r4, r0
 80012f6:	b108      	cbz	r0, 80012fc <chSemInit+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:88 (discriminator 2)
 80012f8:	2900      	cmp	r1, #0
 80012fa:	da02      	bge.n	8001302 <chSemInit+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:88 (discriminator 1)
 80012fc:	4803      	ldr	r0, [pc, #12]	; (800130c <chSemInit+0x1c>)
 80012fe:	f000 feaf 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:90

  queue_init(&sp->s_queue);
 8001302:	6064      	str	r4, [r4, #4]
 8001304:	6024      	str	r4, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:91
  sp->s_cnt = n;
 8001306:	60a5      	str	r5, [r4, #8]
 8001308:	bd38      	pop	{r3, r4, r5, pc}
 800130a:	bf00      	nop
 800130c:	08002f30 	.word	0x08002f30

08001310 <chSemWaitS>:
chSemWaitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:185
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(Semaphore *sp) {
 8001310:	b538      	push	{r3, r4, r5, lr}
 8001312:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:187

  chDbgCheckClassS();
 8001314:	f7ff fe1c 	bl	8000f50 <chDbgCheckClassS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:188
  chDbgCheck(sp != NULL, "chSemWaitS");
 8001318:	b914      	cbnz	r4, 8001320 <chSemWaitS+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:188 (discriminator 1)
 800131a:	4812      	ldr	r0, [pc, #72]	; (8001364 <chSemWaitS+0x54>)
 800131c:	f000 fea0 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:189
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
 8001320:	68a3      	ldr	r3, [r4, #8]
 8001322:	2b00      	cmp	r3, #0
 8001324:	6823      	ldr	r3, [r4, #0]
 8001326:	db02      	blt.n	800132e <chSemWaitS+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:189 (discriminator 2)
 8001328:	42a3      	cmp	r3, r4
 800132a:	d102      	bne.n	8001332 <chSemWaitS+0x22>
 800132c:	e004      	b.n	8001338 <chSemWaitS+0x28>
 800132e:	42a3      	cmp	r3, r4
 8001330:	d102      	bne.n	8001338 <chSemWaitS+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:189 (discriminator 1)
 8001332:	480d      	ldr	r0, [pc, #52]	; (8001368 <chSemWaitS+0x58>)
 8001334:	f000 fe94 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:194
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
 8001338:	68a3      	ldr	r3, [r4, #8]
 800133a:	3b01      	subs	r3, #1
 800133c:	2b00      	cmp	r3, #0
 800133e:	60a3      	str	r3, [r4, #8]
 8001340:	da0d      	bge.n	800135e <chSemWaitS+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:195
    currp->p_u.wtobjp = sp;
 8001342:	4d0a      	ldr	r5, [pc, #40]	; (800136c <chSemWaitS+0x5c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:197
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
 8001344:	2003      	movs	r0, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:195
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemWaitS(), #1",
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
 8001346:	69ab      	ldr	r3, [r5, #24]
 8001348:	629c      	str	r4, [r3, #40]	; 0x28
queue_insert():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:55
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
 800134a:	6862      	ldr	r2, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:54
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
 800134c:	601c      	str	r4, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:55
  tp->p_prev = tqp->p_prev;
 800134e:	605a      	str	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:56
  tp->p_prev->p_next = tqp->p_prev = tp;
 8001350:	6063      	str	r3, [r4, #4]
 8001352:	6013      	str	r3, [r2, #0]
chSemWaitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:197
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(THD_STATE_WTSEM);
 8001354:	f7ff fee4 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:198
    return currp->p_u.rdymsg;
 8001358:	69ab      	ldr	r3, [r5, #24]
 800135a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800135c:	bd38      	pop	{r3, r4, r5, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:200
  }
  return RDY_OK;
 800135e:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:201
}
 8001360:	bd38      	pop	{r3, r4, r5, pc}
 8001362:	bf00      	nop
 8001364:	08002f60 	.word	0x08002f60
 8001368:	08002f6f 	.word	0x08002f6f
 800136c:	200012ac 	.word	0x200012ac

08001370 <chSemWait>:
chSemWait():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:164
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
 8001370:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:167
  msg_t msg;

  chSysLock();
 8001372:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:164
 *                      semaphore has been signaled.
 * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(Semaphore *sp) {
 8001374:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:167
  msg_t msg;

  chSysLock();
 8001376:	f383 8811 	msr	BASEPRI, r3
 800137a:	f7ff fd31 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:168
  msg = chSemWaitS(sp);
 800137e:	4620      	mov	r0, r4
 8001380:	f7ff ffc6 	bl	8001310 <chSemWaitS>
 8001384:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:169
  chSysUnlock();
 8001386:	f7ff fd43 	bl	8000e10 <dbg_check_unlock>
 800138a:	2300      	movs	r3, #0
 800138c:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:171
  return msg;
}
 8001390:	4620      	mov	r0, r4
 8001392:	bd10      	pop	{r4, pc}
	...

080013a0 <chSemSignal>:
chSemSignal():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:278
 *
 * @param[in] sp        pointer to a @p Semaphore structure
 *
 * @api
 */
void chSemSignal(Semaphore *sp) {
 80013a0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:280

  chDbgCheck(sp != NULL, "chSemSignal");
 80013a2:	4604      	mov	r4, r0
 80013a4:	b910      	cbnz	r0, 80013ac <chSemSignal+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:280 (discriminator 1)
 80013a6:	4813      	ldr	r0, [pc, #76]	; (80013f4 <chSemSignal+0x54>)
 80013a8:	f000 fe5a 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:281
  chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
 80013ac:	68a3      	ldr	r3, [r4, #8]
 80013ae:	2b00      	cmp	r3, #0
 80013b0:	6823      	ldr	r3, [r4, #0]
 80013b2:	db02      	blt.n	80013ba <chSemSignal+0x1a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:281 (discriminator 2)
 80013b4:	42a3      	cmp	r3, r4
 80013b6:	d102      	bne.n	80013be <chSemSignal+0x1e>
 80013b8:	e004      	b.n	80013c4 <chSemSignal+0x24>
 80013ba:	42a3      	cmp	r3, r4
 80013bc:	d102      	bne.n	80013c4 <chSemSignal+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:281 (discriminator 1)
 80013be:	480e      	ldr	r0, [pc, #56]	; (80013f8 <chSemSignal+0x58>)
 80013c0:	f000 fe4e 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:286
              ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
              "chSemSignal(), #1",
              "inconsistent semaphore");

  chSysLock();
 80013c4:	2320      	movs	r3, #32
 80013c6:	f383 8811 	msr	BASEPRI, r3
 80013ca:	f7ff fd09 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:287
  if (++sp->s_cnt <= 0)
 80013ce:	68a3      	ldr	r3, [r4, #8]
 80013d0:	3301      	adds	r3, #1
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	60a3      	str	r3, [r4, #8]
 80013d6:	dc06      	bgt.n	80013e6 <chSemSignal+0x46>
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:60
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 80013d8:	6820      	ldr	r0, [r4, #0]
chSemSignal():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:288
    chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
 80013da:	2100      	movs	r1, #0
fifo_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80013dc:	6803      	ldr	r3, [r0, #0]
 80013de:	6023      	str	r3, [r4, #0]
 80013e0:	605c      	str	r4, [r3, #4]
chSemSignal():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:288
 80013e2:	f7ff feed 	bl	80011c0 <chSchWakeupS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsem.c:289
  chSysUnlock();
 80013e6:	f7ff fd13 	bl	8000e10 <dbg_check_unlock>
 80013ea:	2300      	movs	r3, #0
 80013ec:	f383 8811 	msr	BASEPRI, r3
 80013f0:	bd10      	pop	{r4, pc}
 80013f2:	bf00      	nop
 80013f4:	08002fae 	.word	0x08002fae
 80013f8:	08002fbe 	.word	0x08002fbe
$d():
 80013fc:	00000000 	.word	0x00000000

08001400 <_idle_thread>:
_idle_thread():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:64
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8001400:	4b02      	ldr	r3, [pc, #8]	; (800140c <_idle_thread+0xc>)
 8001402:	4a03      	ldr	r2, [pc, #12]	; (8001410 <_idle_thread+0x10>)
 8001404:	699b      	ldr	r3, [r3, #24]
 8001406:	619a      	str	r2, [r3, #24]
 8001408:	e7fe      	b.n	8001408 <_idle_thread+0x8>
 800140a:	bf00      	nop
 800140c:	200012ac 	.word	0x200012ac
 8001410:	08003060 	.word	0x08003060
	...

08001420 <chSysInit>:
chSysInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:84
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 8001420:	b507      	push	{r0, r1, r2, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:90
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8001422:	f7ff fbcd 	bl	8000bc0 <_port_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:91
  _scheduler_init();
 8001426:	f7ff fe23 	bl	8001070 <_scheduler_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:92
  _vt_init();
 800142a:	f000 f931 	bl	8001690 <_vt_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:100
#endif
#if CH_USE_HEAP
  _heap_init();
#endif
#if CH_DBG_ENABLE_TRACE
  _trace_init();
 800142e:	f7ff fda7 	bl	8000f80 <_trace_init>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:104
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 8001432:	2140      	movs	r1, #64	; 0x40
 8001434:	480f      	ldr	r0, [pc, #60]	; (8001474 <chSysInit+0x54>)
 8001436:	f000 f863 	bl	8001500 <_thread_init>
 800143a:	4b0f      	ldr	r3, [pc, #60]	; (8001478 <chSysInit+0x58>)
 800143c:	6198      	str	r0, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:105
  currp->p_state = THD_STATE_CURRENT;
 800143e:	2301      	movs	r3, #1
 8001440:	f880 3020 	strb.w	r3, [r0, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:109
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8001444:	4b0d      	ldr	r3, [pc, #52]	; (800147c <chSysInit+0x5c>)
 8001446:	61c3      	str	r3, [r0, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:111
#endif
  chSysEnable();
 8001448:	f7ff fcba 	bl	8000dc0 <dbg_check_enable>
 800144c:	2300      	movs	r3, #0
 800144e:	f383 8811 	msr	BASEPRI, r3
 8001452:	b662      	cpsie	i
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:115

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8001454:	4b08      	ldr	r3, [pc, #32]	; (8001478 <chSysInit+0x58>)
 8001456:	4a0a      	ldr	r2, [pc, #40]	; (8001480 <chSysInit+0x60>)
 8001458:	699b      	ldr	r3, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800145a:	21a8      	movs	r1, #168	; 0xa8
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:115
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 800145c:	619a      	str	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800145e:	2300      	movs	r3, #0
 8001460:	9300      	str	r3, [sp, #0]
 8001462:	2201      	movs	r2, #1
 8001464:	4b07      	ldr	r3, [pc, #28]	; (8001484 <chSysInit+0x64>)
 8001466:	4808      	ldr	r0, [pc, #32]	; (8001488 <chSysInit+0x68>)
 8001468:	f000 f892 	bl	8001590 <chThdCreateStatic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:124
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 800146c:	b003      	add	sp, #12
 800146e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001472:	bf00      	nop
 8001474:	20000b8c 	.word	0x20000b8c
 8001478:	200012ac 	.word	0x200012ac
 800147c:	20000400 	.word	0x20000400
 8001480:	08002ee0 	.word	0x08002ee0
 8001484:	08001401 	.word	0x08001401
 8001488:	200012c8 	.word	0x200012c8
$d():
 800148c:	00000000 	.word	0x00000000

08001490 <chSysTimerHandlerI>:
chSysTimerHandlerI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:137
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:139

  chDbgCheckClassI();
 8001492:	f7ff fd45 	bl	8000f20 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:143

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
 8001496:	4b16      	ldr	r3, [pc, #88]	; (80014f0 <chSysTimerHandlerI+0x60>)
 8001498:	699b      	ldr	r3, [r3, #24]
 800149a:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800149e:	b112      	cbz	r2, 80014a6 <chSysTimerHandlerI+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:145
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 80014a0:	3a01      	subs	r2, #1
 80014a2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:148
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
 80014a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80014a8:	3201      	adds	r2, #1
 80014aa:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:150
#endif
  chVTDoTickI();
 80014ac:	4b11      	ldr	r3, [pc, #68]	; (80014f4 <chSysTimerHandlerI+0x64>)
 80014ae:	68da      	ldr	r2, [r3, #12]
 80014b0:	461e      	mov	r6, r3
 80014b2:	3201      	adds	r2, #1
 80014b4:	60da      	str	r2, [r3, #12]
 80014b6:	681a      	ldr	r2, [r3, #0]
 80014b8:	429a      	cmp	r2, r3
 80014ba:	d018      	beq.n	80014ee <chSysTimerHandlerI+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:150 (discriminator 1)
 80014bc:	6891      	ldr	r1, [r2, #8]
 80014be:	3901      	subs	r1, #1
 80014c0:	6091      	str	r1, [r2, #8]
 80014c2:	6834      	ldr	r4, [r6, #0]
 80014c4:	4a0b      	ldr	r2, [pc, #44]	; (80014f4 <chSysTimerHandlerI+0x64>)
 80014c6:	68a5      	ldr	r5, [r4, #8]
 80014c8:	b98d      	cbnz	r5, 80014ee <chSysTimerHandlerI+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chsys.c:150 (discriminator 2)
 80014ca:	6821      	ldr	r1, [r4, #0]
 80014cc:	68e7      	ldr	r7, [r4, #12]
 80014ce:	60e5      	str	r5, [r4, #12]
 80014d0:	604a      	str	r2, [r1, #4]
 80014d2:	6011      	str	r1, [r2, #0]
 80014d4:	f7ff fccc 	bl	8000e70 <dbg_check_unlock_from_isr>
 80014d8:	462b      	mov	r3, r5
 80014da:	f383 8811 	msr	BASEPRI, r3
 80014de:	6920      	ldr	r0, [r4, #16]
 80014e0:	47b8      	blx	r7
 80014e2:	2320      	movs	r3, #32
 80014e4:	f383 8811 	msr	BASEPRI, r3
 80014e8:	f7ff fcaa 	bl	8000e40 <dbg_check_lock_from_isr>
 80014ec:	e7e9      	b.n	80014c2 <chSysTimerHandlerI+0x32>
 80014ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80014f0:	200012ac 	.word	0x200012ac
 80014f4:	20001370 	.word	0x20001370
	...

08001500 <_thread_init>:
_thread_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:79
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 8001500:	2202      	movs	r2, #2
 8001502:	f880 2020 	strb.w	r2, [r0, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:80
  tp->p_flags = THD_MEM_MODE_STATIC;
 8001506:	2200      	movs	r2, #0
 8001508:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:89
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 800150c:	6302      	str	r2, [r0, #48]	; 0x30
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:92
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
 800150e:	6242      	str	r2, [r0, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:98
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 8001510:	6182      	str	r2, [r0, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:99
  REG_INSERT(tp);
 8001512:	4a08      	ldr	r2, [pc, #32]	; (8001534 <_thread_init+0x34>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:78
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001514:	6081      	str	r1, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:82
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 8001516:	2114      	movs	r1, #20
 8001518:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800151c:	6951      	ldr	r1, [r2, #20]
 800151e:	6102      	str	r2, [r0, #16]
 8001520:	6141      	str	r1, [r0, #20]
 8001522:	6150      	str	r0, [r2, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:102
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8001524:	f100 022c 	add.w	r2, r0, #44	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001528:	6108      	str	r0, [r1, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:102
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 800152a:	62c2      	str	r2, [r0, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:108
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800152c:	f100 0234 	add.w	r2, r0, #52	; 0x34
 8001530:	61c2      	str	r2, [r0, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:114
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
 8001532:	4770      	bx	lr
 8001534:	200012ac 	.word	0x200012ac
	...

08001540 <chThdCreateI>:
chThdCreateI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:158
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
 8001540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001544:	4604      	mov	r4, r0
 8001546:	460f      	mov	r7, r1
 8001548:	4615      	mov	r5, r2
 800154a:	461e      	mov	r6, r3
 800154c:	f8dd 8018 	ldr.w	r8, [sp, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:162
  /* Thread structure is laid out in the lower part of the thread workspace.*/
  Thread *tp = wsp;

  chDbgCheckClassI();
 8001550:	f7ff fce6 	bl	8000f20 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:164

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
 8001554:	b124      	cbz	r4, 8001560 <chThdCreateI+0x20>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:164 (discriminator 2)
 8001556:	2f97      	cmp	r7, #151	; 0x97
 8001558:	d902      	bls.n	8001560 <chThdCreateI+0x20>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:164 (discriminator 1)
 800155a:	2d7f      	cmp	r5, #127	; 0x7f
 800155c:	d800      	bhi.n	8001560 <chThdCreateI+0x20>
 800155e:	b916      	cbnz	r6, 8001566 <chThdCreateI+0x26>
 8001560:	4808      	ldr	r0, [pc, #32]	; (8001584 <chThdCreateI+0x44>)
 8001562:	f000 fd7d 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:167
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8001566:	3f24      	subs	r7, #36	; 0x24
 8001568:	4b07      	ldr	r3, [pc, #28]	; (8001588 <chThdCreateI+0x48>)
 800156a:	19e0      	adds	r0, r4, r7
 800156c:	60e0      	str	r0, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 800156e:	4629      	mov	r1, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:167
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8001570:	51e6      	str	r6, [r4, r7]
 8001572:	f8c0 8004 	str.w	r8, [r0, #4]
 8001576:	6203      	str	r3, [r0, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 8001578:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:169
}
 800157a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:168

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
 800157e:	f7ff bfbf 	b.w	8001500 <_thread_init>
 8001582:	bf00      	nop
 8001584:	08003070 	.word	0x08003070
 8001588:	08000cb1 	.word	0x08000cb1
$d():
 800158c:	00000000 	.word	0x00000000

08001590 <chThdCreateStatic>:
chThdCreateStatic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 8001590:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001594:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:192
  Thread *tp;
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
 8001596:	f100 0534 	add.w	r5, r0, #52	; 0x34
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 800159a:	460e      	mov	r6, r1
 800159c:	4690      	mov	r8, r2
 800159e:	461f      	mov	r7, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:192
  Thread *tp;
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
 80015a0:	2000      	movs	r0, #0
_thread_memfill():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:129
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp)
    *startp++ = v;
 80015a2:	23ff      	movs	r3, #255	; 0xff
 80015a4:	5423      	strb	r3, [r4, r0]
 80015a6:	3001      	adds	r0, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:128
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp)
 80015a8:	2834      	cmp	r0, #52	; 0x34
 80015aa:	d1fa      	bne.n	80015a2 <chThdCreateStatic+0x12>
chThdCreateStatic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:195
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(Thread),
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
 80015ac:	19a3      	adds	r3, r4, r6
_thread_memfill():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:128
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp)
 80015ae:	429d      	cmp	r5, r3
 80015b0:	d203      	bcs.n	80015ba <chThdCreateStatic+0x2a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:129
    *startp++ = v;
 80015b2:	2255      	movs	r2, #85	; 0x55
 80015b4:	f805 2b01 	strb.w	r2, [r5], #1
 80015b8:	e7f9      	b.n	80015ae <chThdCreateStatic+0x1e>
chThdCreateStatic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:199
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
 80015ba:	2320      	movs	r3, #32
 80015bc:	f383 8811 	msr	BASEPRI, r3
 80015c0:	f7ff fc0e 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:200
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 80015c4:	9908      	ldr	r1, [sp, #32]
 80015c6:	463b      	mov	r3, r7
 80015c8:	4642      	mov	r2, r8
 80015ca:	9100      	str	r1, [sp, #0]
 80015cc:	4620      	mov	r0, r4
 80015ce:	4631      	mov	r1, r6
 80015d0:	f7ff ffb6 	bl	8001540 <chThdCreateI>
 80015d4:	2100      	movs	r1, #0
 80015d6:	4604      	mov	r4, r0
 80015d8:	f7ff fdf2 	bl	80011c0 <chSchWakeupS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:201
  chSysUnlock();
 80015dc:	f7ff fc18 	bl	8000e10 <dbg_check_unlock>
 80015e0:	2300      	movs	r3, #0
 80015e2:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:203
  return tp;
}
 80015e6:	4620      	mov	r0, r4
 80015e8:	b002      	add	sp, #8
 80015ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080015f0 <chThdSleep>:
chThdSleep():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:292
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80015f0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:294

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");
 80015f2:	4604      	mov	r4, r0
 80015f4:	b910      	cbnz	r0, 80015fc <chThdSleep+0xc>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:294 (discriminator 1)
 80015f6:	4809      	ldr	r0, [pc, #36]	; (800161c <chThdSleep+0x2c>)
 80015f8:	f000 fd32 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:296

  chSysLock();
 80015fc:	2320      	movs	r3, #32
 80015fe:	f383 8811 	msr	BASEPRI, r3
 8001602:	f7ff fbed 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:297
  chThdSleepS(time);
 8001606:	4621      	mov	r1, r4
 8001608:	2006      	movs	r0, #6
 800160a:	f7ff fdb1 	bl	8001170 <chSchGoSleepTimeoutS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:298
  chSysUnlock();
 800160e:	f7ff fbff 	bl	8000e10 <dbg_check_unlock>
 8001612:	2300      	movs	r3, #0
 8001614:	f383 8811 	msr	BASEPRI, r3
 8001618:	bd10      	pop	{r4, pc}
 800161a:	bf00      	nop
 800161c:	080030a8 	.word	0x080030a8

08001620 <chThdExitS>:
chThdExitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:367
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  Thread *tp = currp;
 8001620:	4b0f      	ldr	r3, [pc, #60]	; (8001660 <chThdExitS+0x40>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:366
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001622:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:367
  Thread *tp = currp;
 8001624:	699c      	ldr	r4, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:369

  tp->p_u.exitcode = msg;
 8001626:	62a0      	str	r0, [r4, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:374 (discriminator 1)
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 8001628:	4623      	mov	r3, r4
 800162a:	f853 0f2c 	ldr.w	r0, [r3, #44]!
 800162e:	4298      	cmp	r0, r3
 8001630:	d004      	beq.n	800163c <chThdExitS+0x1c>
list_remove():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/os/kernel/include/chinline.h:89
}

static INLINE Thread *list_remove(ThreadsList *tlp) {

  Thread *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001632:	6803      	ldr	r3, [r0, #0]
 8001634:	62e3      	str	r3, [r4, #44]	; 0x2c
chThdExitS():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:375
    chSchReadyI(list_remove(&tp->p_waiting));
 8001636:	f7ff fd2b 	bl	8001090 <chSchReadyI>
 800163a:	e7f5      	b.n	8001628 <chThdExitS+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:380
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 800163c:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8001640:	079b      	lsls	r3, r3, #30
 8001642:	d104      	bne.n	800164e <chThdExitS+0x2e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:381
    REG_REMOVE(tp);
 8001644:	6922      	ldr	r2, [r4, #16]
 8001646:	6963      	ldr	r3, [r4, #20]
 8001648:	611a      	str	r2, [r3, #16]
 800164a:	6922      	ldr	r2, [r4, #16]
 800164c:	6153      	str	r3, [r2, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:383
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 800164e:	200e      	movs	r0, #14
 8001650:	f7ff fd66 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:386
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 8001654:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:385
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
 8001658:	4802      	ldr	r0, [pc, #8]	; (8001664 <chThdExitS+0x44>)
 800165a:	f000 bd01 	b.w	8002060 <chDbgPanic>
 800165e:	bf00      	nop
 8001660:	200012ac 	.word	0x200012ac
 8001664:	080030b7 	.word	0x080030b7
	...

08001670 <chThdExit>:
chThdExit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:345
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001670:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:347

  chSysLock();
 8001672:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:345
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001674:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:347

  chSysLock();
 8001676:	f383 8811 	msr	BASEPRI, r3
 800167a:	f7ff fbb1 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:348
  chThdExitS(msg);
 800167e:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:350
  /* The thread never returns here.*/
}
 8001680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chthreads.c:348
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001684:	f7ff bfcc 	b.w	8001620 <chThdExitS>
	...

08001690 <_vt_init>:
_vt_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 8001690:	4b04      	ldr	r3, [pc, #16]	; (80016a4 <_vt_init+0x14>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:53
  vtlist.vt_time = (systime_t)-1;
 8001692:	f04f 32ff 	mov.w	r2, #4294967295
 8001696:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:54
  vtlist.vt_systime = 0;
 8001698:	2200      	movs	r2, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 800169a:	605b      	str	r3, [r3, #4]
 800169c:	601b      	str	r3, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:54
  vtlist.vt_time = (systime_t)-1;
  vtlist.vt_systime = 0;
 800169e:	60da      	str	r2, [r3, #12]
 80016a0:	4770      	bx	lr
 80016a2:	bf00      	nop
 80016a4:	20001370 	.word	0x20001370
	...

080016b0 <chVTSetI>:
chVTSetI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:76
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 80016b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80016b2:	4604      	mov	r4, r0
 80016b4:	460d      	mov	r5, r1
 80016b6:	4616      	mov	r6, r2
 80016b8:	461f      	mov	r7, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:79
  VirtualTimer *p;

  chDbgCheckClassI();
 80016ba:	f7ff fc31 	bl	8000f20 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:80
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
 80016be:	b10c      	cbz	r4, 80016c4 <chVTSetI+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:80 (discriminator 2)
 80016c0:	b106      	cbz	r6, 80016c4 <chVTSetI+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:80 (discriminator 1)
 80016c2:	b915      	cbnz	r5, 80016ca <chVTSetI+0x1a>
 80016c4:	480c      	ldr	r0, [pc, #48]	; (80016f8 <chVTSetI+0x48>)
 80016c6:	f000 fccb 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:85
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 80016ca:	4a0c      	ldr	r2, [pc, #48]	; (80016fc <chVTSetI+0x4c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:83

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
 80016cc:	6127      	str	r7, [r4, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:85
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 80016ce:	6813      	ldr	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:84
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80016d0:	60e6      	str	r6, [r4, #12]
 80016d2:	4611      	mov	r1, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:86 (discriminator 1)
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 80016d4:	689a      	ldr	r2, [r3, #8]
 80016d6:	42aa      	cmp	r2, r5
 80016d8:	d202      	bcs.n	80016e0 <chVTSetI+0x30>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:87
    time -= p->vt_time;
 80016da:	1aad      	subs	r5, r5, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:88
    p = p->vt_next;
 80016dc:	681b      	ldr	r3, [r3, #0]
 80016de:	e7f9      	b.n	80016d4 <chVTSetI+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:91
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 80016e0:	685a      	ldr	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:94
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_time = time;
  if (p != (void *)&vtlist)
 80016e2:	428b      	cmp	r3, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:91
  while (p->vt_time < time) {
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 80016e4:	6023      	str	r3, [r4, #0]
 80016e6:	6062      	str	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:92
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 80016e8:	605c      	str	r4, [r3, #4]
 80016ea:	6014      	str	r4, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:93
  vtp->vt_time = time;
 80016ec:	60a5      	str	r5, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:94
  if (p != (void *)&vtlist)
 80016ee:	d002      	beq.n	80016f6 <chVTSetI+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:95
    p->vt_time -= time;
 80016f0:	689a      	ldr	r2, [r3, #8]
 80016f2:	1b55      	subs	r5, r2, r5
 80016f4:	609d      	str	r5, [r3, #8]
 80016f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80016f8:	080030f0 	.word	0x080030f0
 80016fc:	20001370 	.word	0x20001370

08001700 <chVTResetI>:
chVTResetI():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:106
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 8001700:	b510      	push	{r4, lr}
 8001702:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:108

  chDbgCheckClassI();
 8001704:	f7ff fc0c 	bl	8000f20 <chDbgCheckClassI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:109
  chDbgCheck(vtp != NULL, "chVTResetI");
 8001708:	b914      	cbnz	r4, 8001710 <chVTResetI+0x10>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:109 (discriminator 1)
 800170a:	480b      	ldr	r0, [pc, #44]	; (8001738 <chVTResetI+0x38>)
 800170c:	f000 fca8 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:110
  chDbgAssert(vtp->vt_func != NULL,
 8001710:	68e3      	ldr	r3, [r4, #12]
 8001712:	b913      	cbnz	r3, 800171a <chVTResetI+0x1a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:110 (discriminator 1)
 8001714:	4809      	ldr	r0, [pc, #36]	; (800173c <chVTResetI+0x3c>)
 8001716:	f000 fca3 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:114
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 800171a:	6823      	ldr	r3, [r4, #0]
 800171c:	4a08      	ldr	r2, [pc, #32]	; (8001740 <chVTResetI+0x40>)
 800171e:	4293      	cmp	r3, r2
 8001720:	d003      	beq.n	800172a <chVTResetI+0x2a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:115
    vtp->vt_next->vt_time += vtp->vt_time;
 8001722:	6899      	ldr	r1, [r3, #8]
 8001724:	68a2      	ldr	r2, [r4, #8]
 8001726:	440a      	add	r2, r1
 8001728:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:116
  vtp->vt_prev->vt_next = vtp->vt_next;
 800172a:	6862      	ldr	r2, [r4, #4]
 800172c:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:117
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800172e:	6823      	ldr	r3, [r4, #0]
 8001730:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/kernel/src/chvt.c:118
  vtp->vt_func = (vtfunc_t)NULL;
 8001732:	2300      	movs	r3, #0
 8001734:	60e3      	str	r3, [r4, #12]
 8001736:	bd10      	pop	{r4, pc}
 8001738:	080030fd 	.word	0x080030fd
 800173c:	0800310c 	.word	0x0800310c
 8001740:	20001370 	.word	0x20001370
	...

08001750 <halInit>:
halInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/src/hal.c:70
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
 8001750:	f000 b806 	b.w	8001760 <hal_lld_init>
	...

08001760 <hal_lld_init>:
hal_lld_init():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:96
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 8001760:	4b15      	ldr	r3, [pc, #84]	; (80017b8 <hal_lld_init+0x58>)
 8001762:	691a      	ldr	r2, [r3, #16]
 8001764:	f462 4200 	orn	r2, r2, #32768	; 0x8000
 8001768:	611a      	str	r2, [r3, #16]
 800176a:	2200      	movs	r2, #0
 800176c:	611a      	str	r2, [r3, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:97
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800176e:	6999      	ldr	r1, [r3, #24]
 8001770:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8001774:	6199      	str	r1, [r3, #24]
 8001776:	619a      	str	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:98
  rccResetAPB2(~0);
 8001778:	6959      	ldr	r1, [r3, #20]
 800177a:	f04f 31ff 	mov.w	r1, #4294967295
 800177e:	6159      	str	r1, [r3, #20]
 8001780:	615a      	str	r2, [r3, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:100

  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001782:	6a19      	ldr	r1, [r3, #32]
 8001784:	f041 0101 	orr.w	r1, r1, #1
 8001788:	6219      	str	r1, [r3, #32]
 800178a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800178c:	f041 0101 	orr.w	r1, r1, #1
 8001790:	62d9      	str	r1, [r3, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:103

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = Clk.AHBFreqHz / CH_FREQUENCY - 1;
 8001792:	490a      	ldr	r1, [pc, #40]	; (80017bc <hal_lld_init+0x5c>)
 8001794:	6808      	ldr	r0, [r1, #0]
 8001796:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800179a:	fbb0 f0f1 	udiv	r0, r0, r1
 800179e:	4908      	ldr	r1, [pc, #32]	; (80017c0 <hal_lld_init+0x60>)
 80017a0:	3801      	subs	r0, #1
 80017a2:	6048      	str	r0, [r1, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:104
  SysTick->VAL = 0;
 80017a4:	608a      	str	r2, [r1, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:107
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;
 80017a6:	2207      	movs	r2, #7
 80017a8:	600a      	str	r2, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:114
  /* DWT cycle counter enable.*/
//  SCS_DEMCR |= SCS_DEMCR_TRCENA;
//  DWT_CTRL  |= DWT_CTRL_CYCCNTENA;

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80017aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80017ac:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80017b0:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/hal_lld.cpp:120

  /* Initializes the backup domain.*/
//  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80017b2:	f000 b8dd 	b.w	8001970 <dmaInit>
 80017b6:	bf00      	nop
 80017b8:	40023800 	.word	0x40023800
 80017bc:	20000c00 	.word	0x20000c00
 80017c0:	e000e010 	.word	0xe000e010
	...

080017d0 <Vector6C>:
Vector6C():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:114
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
 80017d0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:117
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80017d2:	f7ff fb65 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:119

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 80017d6:	4b08      	ldr	r3, [pc, #32]	; (80017f8 <Vector6C+0x28>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 80017d8:	220f      	movs	r2, #15
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 80017da:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 80017dc:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:121
  if (dma_isr_redir[0].dma_func)
 80017de:	4a07      	ldr	r2, [pc, #28]	; (80017fc <Vector6C+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 80017e0:	f001 010f 	and.w	r1, r1, #15
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:121
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
 80017e4:	6813      	ldr	r3, [r2, #0]
 80017e6:	b10b      	cbz	r3, 80017ec <Vector6C+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:122
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 80017e8:	6850      	ldr	r0, [r2, #4]
 80017ea:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:124

  CH_IRQ_EPILOGUE();
 80017ec:	f7ff fb78 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:125
}
 80017f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:124
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80017f4:	f7ff ba04 	b.w	8000c00 <_port_irq_epilogue>
 80017f8:	40026000 	.word	0x40026000
 80017fc:	20000bc0 	.word	0x20000bc0

08001800 <Vector70>:
Vector70():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:132
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
 8001800:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:135
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001802:	f7ff fb4d 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:137

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8001806:	4b08      	ldr	r3, [pc, #32]	; (8001828 <Vector70+0x28>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 8001808:	22f0      	movs	r2, #240	; 0xf0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 800180a:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 800180c:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:139
  if (dma_isr_redir[1].dma_func)
 800180e:	4a07      	ldr	r2, [pc, #28]	; (800182c <Vector70+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8001810:	f3c1 1103 	ubfx	r1, r1, #4, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:139
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
 8001814:	6893      	ldr	r3, [r2, #8]
 8001816:	b10b      	cbz	r3, 800181c <Vector70+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:140
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8001818:	68d0      	ldr	r0, [r2, #12]
 800181a:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:142

  CH_IRQ_EPILOGUE();
 800181c:	f7ff fb60 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:143
}
 8001820:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:142
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001824:	f7ff b9ec 	b.w	8000c00 <_port_irq_epilogue>
 8001828:	40026000 	.word	0x40026000
 800182c:	20000bc0 	.word	0x20000bc0

08001830 <Vector74>:
Vector74():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:150
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
 8001830:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:153
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001832:	f7ff fb35 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:155

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8001836:	4b09      	ldr	r3, [pc, #36]	; (800185c <Vector74+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 8001838:	f44f 6270 	mov.w	r2, #3840	; 0xf00
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 800183c:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 800183e:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:157
  if (dma_isr_redir[2].dma_func)
 8001840:	4a07      	ldr	r2, [pc, #28]	; (8001860 <Vector74+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8001842:	f3c1 2103 	ubfx	r1, r1, #8, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:157
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
 8001846:	6913      	ldr	r3, [r2, #16]
 8001848:	b10b      	cbz	r3, 800184e <Vector74+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:158
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800184a:	6950      	ldr	r0, [r2, #20]
 800184c:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:160

  CH_IRQ_EPILOGUE();
 800184e:	f7ff fb47 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:161
}
 8001852:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:160
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001856:	f7ff b9d3 	b.w	8000c00 <_port_irq_epilogue>
 800185a:	bf00      	nop
 800185c:	40026000 	.word	0x40026000
 8001860:	20000bc0 	.word	0x20000bc0
	...

08001870 <Vector78>:
Vector78():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:168
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
 8001870:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:171
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001872:	f7ff fb15 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:173

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8001876:	4b09      	ldr	r3, [pc, #36]	; (800189c <Vector78+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8001878:	f44f 4270 	mov.w	r2, #61440	; 0xf000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 800187c:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 800187e:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:175
  if (dma_isr_redir[3].dma_func)
 8001880:	4a07      	ldr	r2, [pc, #28]	; (80018a0 <Vector78+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8001882:	f3c1 3103 	ubfx	r1, r1, #12, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:175
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
 8001886:	6993      	ldr	r3, [r2, #24]
 8001888:	b10b      	cbz	r3, 800188e <Vector78+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:176
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800188a:	69d0      	ldr	r0, [r2, #28]
 800188c:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:178

  CH_IRQ_EPILOGUE();
 800188e:	f7ff fb27 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:179
}
 8001892:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:178
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001896:	f7ff b9b3 	b.w	8000c00 <_port_irq_epilogue>
 800189a:	bf00      	nop
 800189c:	40026000 	.word	0x40026000
 80018a0:	20000bc0 	.word	0x20000bc0
	...

080018b0 <Vector7C>:
Vector7C():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:186
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
 80018b0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:189
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80018b2:	f7ff faf5 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:191

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 80018b6:	4b09      	ldr	r3, [pc, #36]	; (80018dc <Vector7C+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 80018b8:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 80018bc:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 80018be:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:193
  if (dma_isr_redir[4].dma_func)
 80018c0:	4a07      	ldr	r2, [pc, #28]	; (80018e0 <Vector7C+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 80018c2:	f3c1 4103 	ubfx	r1, r1, #16, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:193
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
 80018c6:	6a13      	ldr	r3, [r2, #32]
 80018c8:	b10b      	cbz	r3, 80018ce <Vector7C+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:194
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 80018ca:	6a50      	ldr	r0, [r2, #36]	; 0x24
 80018cc:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:196

  CH_IRQ_EPILOGUE();
 80018ce:	f7ff fb07 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:197
}
 80018d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:196
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  CH_IRQ_EPILOGUE();
 80018d6:	f7ff b993 	b.w	8000c00 <_port_irq_epilogue>
 80018da:	bf00      	nop
 80018dc:	40026000 	.word	0x40026000
 80018e0:	20000bc0 	.word	0x20000bc0
	...

080018f0 <Vector80>:
Vector80():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:204
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
 80018f0:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:207
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 80018f2:	f7ff fad5 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:209

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80018f6:	4b09      	ldr	r3, [pc, #36]	; (800191c <Vector80+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 80018f8:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80018fc:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 80018fe:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:211
  if (dma_isr_redir[5].dma_func)
 8001900:	4a07      	ldr	r2, [pc, #28]	; (8001920 <Vector80+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8001902:	f3c1 5103 	ubfx	r1, r1, #20, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:211
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
 8001906:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8001908:	b10b      	cbz	r3, 800190e <Vector80+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:212
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800190a:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 800190c:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:214

  CH_IRQ_EPILOGUE();
 800190e:	f7ff fae7 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:215
}
 8001912:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:214
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001916:	f7ff b973 	b.w	8000c00 <_port_irq_epilogue>
 800191a:	bf00      	nop
 800191c:	40026000 	.word	0x40026000
 8001920:	20000bc0 	.word	0x20000bc0
	...

08001930 <Vector84>:
Vector84():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:222
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
 8001930:	b508      	push	{r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:225
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001932:	f7ff fab5 	bl	8000ea0 <dbg_check_enter_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:227

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8001936:	4b09      	ldr	r3, [pc, #36]	; (800195c <Vector84+0x2c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8001938:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 800193c:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 800193e:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:229
  if (dma_isr_redir[6].dma_func)
 8001940:	4a07      	ldr	r2, [pc, #28]	; (8001960 <Vector84+0x30>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8001942:	f3c1 6103 	ubfx	r1, r1, #24, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:229
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
 8001946:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001948:	b10b      	cbz	r3, 800194e <Vector84+0x1e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:230
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800194a:	6b50      	ldr	r0, [r2, #52]	; 0x34
 800194c:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:232

  CH_IRQ_EPILOGUE();
 800194e:	f7ff fac7 	bl	8000ee0 <dbg_check_leave_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:233
}
 8001952:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:232
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8001956:	f7ff b953 	b.w	8000c00 <_port_irq_epilogue>
 800195a:	bf00      	nop
 800195c:	40026000 	.word	0x40026000
 8001960:	20000bc0 	.word	0x20000bc0
	...

08001970 <dmaInit>:
dmaInit():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:247
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8001970:	4a09      	ldr	r2, [pc, #36]	; (8001998 <dmaInit+0x28>)
 8001972:	2300      	movs	r3, #0
 8001974:	6013      	str	r3, [r2, #0]
 8001976:	210c      	movs	r1, #12
 8001978:	4359      	muls	r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:249 (discriminator 2)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 800197a:	4a08      	ldr	r2, [pc, #32]	; (800199c <dmaInit+0x2c>)
 800197c:	5889      	ldr	r1, [r1, r2]
 800197e:	2200      	movs	r2, #0
 8001980:	600a      	str	r2, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:250 (discriminator 2)
    dma_isr_redir[i].dma_func = NULL;
 8001982:	4907      	ldr	r1, [pc, #28]	; (80019a0 <dmaInit+0x30>)
 8001984:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:248 (discriminator 2)
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001988:	3301      	adds	r3, #1
 800198a:	2b07      	cmp	r3, #7
 800198c:	d1f3      	bne.n	8001976 <dmaInit+0x6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:252
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 800198e:	4b05      	ldr	r3, [pc, #20]	; (80019a4 <dmaInit+0x34>)
 8001990:	f04f 32ff 	mov.w	r2, #4294967295
 8001994:	605a      	str	r2, [r3, #4]
 8001996:	4770      	bx	lr
 8001998:	20000bf8 	.word	0x20000bf8
 800199c:	08003170 	.word	0x08003170
 80019a0:	20000bc0 	.word	0x20000bc0
 80019a4:	40026000 	.word	0x40026000
	...

080019b0 <dmaStreamAllocate>:
dmaStreamAllocate():
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:282
 * @special
 */
bool_t dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                         uint32_t priority,
                         stm32_dmaisr_t func,
                         void *param) {
 80019b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80019b4:	460f      	mov	r7, r1
 80019b6:	4615      	mov	r5, r2
 80019b8:	4698      	mov	r8, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:284

  chDbgCheck(dmastp != NULL, "dmaStreamAllocate");
 80019ba:	4604      	mov	r4, r0
 80019bc:	b910      	cbnz	r0, 80019c4 <dmaStreamAllocate+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:284 (discriminator 1)
 80019be:	481a      	ldr	r0, [pc, #104]	; (8001a28 <dmaStreamAllocate+0x78>)
 80019c0:	f000 fb4e 	bl	8002060 <chDbgPanic>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:287

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 80019c4:	7a62      	ldrb	r2, [r4, #9]
 80019c6:	2001      	movs	r0, #1
 80019c8:	fa00 fc02 	lsl.w	ip, r0, r2
 80019cc:	4e17      	ldr	r6, [pc, #92]	; (8001a2c <dmaStreamAllocate+0x7c>)
 80019ce:	6831      	ldr	r1, [r6, #0]
 80019d0:	ea1c 0f01 	tst.w	ip, r1
 80019d4:	d126      	bne.n	8001a24 <dmaStreamAllocate+0x74>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:291
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 80019d6:	4816      	ldr	r0, [pc, #88]	; (8001a30 <dmaStreamAllocate+0x80>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 80019d8:	ea4c 0301 	orr.w	r3, ip, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:291
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 80019dc:	f840 5032 	str.w	r5, [r0, r2, lsl #3]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 80019e0:	6033      	str	r3, [r6, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 80019e2:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 80019e6:	065b      	lsls	r3, r3, #25
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 80019e8:	f8c2 8004 	str.w	r8, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 80019ec:	d004      	beq.n	80019f8 <dmaStreamAllocate+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:297
    rccEnableDMA1(FALSE);
 80019ee:	4b11      	ldr	r3, [pc, #68]	; (8001a34 <dmaStreamAllocate+0x84>)
 80019f0:	69da      	ldr	r2, [r3, #28]
 80019f2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80019f6:	61da      	str	r2, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:300

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80019f8:	6823      	ldr	r3, [r4, #0]
 80019fa:	200f      	movs	r0, #15
 80019fc:	681a      	ldr	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80019fe:	2600      	movs	r6, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:300
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001a00:	f022 020f 	bic.w	r2, r2, #15
 8001a04:	601a      	str	r2, [r3, #0]
 8001a06:	7a21      	ldrb	r1, [r4, #8]
 8001a08:	6862      	ldr	r2, [r4, #4]
 8001a0a:	fa00 f101 	lsl.w	r1, r0, r1
 8001a0e:	6011      	str	r1, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001a10:	601e      	str	r6, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:304

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 8001a12:	b135      	cbz	r5, 8001a22 <dmaStreamAllocate+0x72>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:305
    nvicEnableVector(dmastp->vector, CORTEX_PRIORITY_MASK(priority));
 8001a14:	7aa0      	ldrb	r0, [r4, #10]
 8001a16:	0139      	lsls	r1, r7, #4
 8001a18:	f7ff f872 	bl	8000b00 <nvicEnableVector>
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:307

  return FALSE;
 8001a1c:	4630      	mov	r0, r6
 8001a1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001a22:	4628      	mov	r0, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/os/hal/platforms/STM32L1xx/stm32_dma.c:308
}
 8001a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001a28:	08003120 	.word	0x08003120
 8001a2c:	20000bf8 	.word	0x20000bf8
 8001a30:	20000bc0 	.word	0x20000bc0
 8001a34:	40023800 	.word	0x40023800
	...

08001a40 <Clk_t::UpdateFreqValues()>:
_ZN5Clk_t16UpdateFreqValuesEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8001a40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001a42:	b093      	sub	sp, #76	; 0x4c
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001a44:	2100      	movs	r1, #0
 8001a46:	2220      	movs	r2, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8001a48:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001a4a:	a80a      	add	r0, sp, #40	; 0x28
 8001a4c:	f001 f928 	bl	8002ca0 <memset>
 8001a50:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001a54:	930a      	str	r3, [sp, #40]	; 0x28
 8001a56:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001a5a:	930b      	str	r3, [sp, #44]	; 0x2c
 8001a5c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001a60:	930c      	str	r3, [sp, #48]	; 0x30
 8001a62:	4b34      	ldr	r3, [pc, #208]	; (8001b34 <Clk_t::UpdateFreqValues()+0xf4>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8001a64:	4a34      	ldr	r2, [pc, #208]	; (8001b38 <Clk_t::UpdateFreqValues()+0xf8>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001a66:	930d      	str	r3, [sp, #52]	; 0x34
 8001a68:	4b34      	ldr	r3, [pc, #208]	; (8001b3c <Clk_t::UpdateFreqValues()+0xfc>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8001a6a:	6851      	ldr	r1, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001a6c:	930e      	str	r3, [sp, #56]	; 0x38
 8001a6e:	4b34      	ldr	r3, [pc, #208]	; (8001b40 <Clk_t::UpdateFreqValues()+0x100>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8001a70:	6810      	ldr	r0, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001a72:	930f      	str	r3, [sp, #60]	; 0x3c
 8001a74:	4b33      	ldr	r3, [pc, #204]	; (8001b44 <Clk_t::UpdateFreqValues()+0x104>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:64
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8001a76:	ae06      	add	r6, sp, #24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8001a78:	9310      	str	r3, [sp, #64]	; 0x40
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8001a7a:	ab03      	add	r3, sp, #12
 8001a7c:	c303      	stmia	r3!, {r0, r1}
 8001a7e:	7a11      	ldrb	r1, [r2, #8]
 8001a80:	7019      	strb	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:64
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8001a82:	f102 0309 	add.w	r3, r2, #9
 8001a86:	3219      	adds	r2, #25
 8001a88:	4617      	mov	r7, r2
 8001a8a:	6818      	ldr	r0, [r3, #0]
 8001a8c:	6859      	ldr	r1, [r3, #4]
 8001a8e:	4634      	mov	r4, r6
 8001a90:	c403      	stmia	r4!, {r0, r1}
 8001a92:	3308      	adds	r3, #8
 8001a94:	4293      	cmp	r3, r2
 8001a96:	4626      	mov	r6, r4
 8001a98:	d1f7      	bne.n	8001a8a <Clk_t::UpdateFreqValues()+0x4a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:65
    const uint8_t APBPrescTable[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8001a9a:	6838      	ldr	r0, [r7, #0]
 8001a9c:	6879      	ldr	r1, [r7, #4]
 8001a9e:	ab01      	add	r3, sp, #4
 8001aa0:	c303      	stmia	r3!, {r0, r1}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:68

    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
 8001aa2:	4b29      	ldr	r3, [pc, #164]	; (8001b48 <Clk_t::UpdateFreqValues()+0x108>)
 8001aa4:	689a      	ldr	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:69
    tmp >>= 2;
 8001aa6:	f3c2 0281 	ubfx	r2, r2, #2, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:70
    switch(tmp) {
 8001aaa:	2a02      	cmp	r2, #2
 8001aac:	d024      	beq.n	8001af8 <Clk_t::UpdateFreqValues()+0xb8>
 8001aae:	2a03      	cmp	r2, #3
 8001ab0:	d00c      	beq.n	8001acc <Clk_t::UpdateFreqValues()+0x8c>
 8001ab2:	2a01      	cmp	r2, #1
 8001ab4:	d101      	bne.n	8001aba <Clk_t::UpdateFreqValues()+0x7a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:77
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
            SysClkHz = MSIClk[tmp];
            break;

        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
 8001ab6:	4b25      	ldr	r3, [pc, #148]	; (8001b4c <Clk_t::UpdateFreqValues()+0x10c>)
 8001ab8:	e01f      	b.n	8001afa <Clk_t::UpdateFreqValues()+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8001aba:	685b      	ldr	r3, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8001abc:	a812      	add	r0, sp, #72	; 0x48
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8001abe:	f3c3 3342 	ubfx	r3, r3, #13, #3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8001ac2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001ac6:	f853 3c20 	ldr.w	r3, [r3, #-32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:74
            break;
 8001aca:	e016      	b.n	8001afa <Clk_t::UpdateFreqValues()+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8001acc:	689a      	ldr	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8001ace:	a912      	add	r1, sp, #72	; 0x48
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8001ad0:	f3c2 4283 	ubfx	r2, r2, #18, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8001ad4:	440a      	add	r2, r1
 8001ad6:	f812 1c3c 	ldrb.w	r1, [r2, #-60]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:88
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8001ada:	689a      	ldr	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8001adc:	689b      	ldr	r3, [r3, #8]
 8001ade:	481c      	ldr	r0, [pc, #112]	; (8001b50 <Clk_t::UpdateFreqValues()+0x110>)
 8001ae0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8001ae4:	4b19      	ldr	r3, [pc, #100]	; (8001b4c <Clk_t::UpdateFreqValues()+0x10c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8001ae6:	f3c2 5281 	ubfx	r2, r2, #22, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8001aea:	bf18      	it	ne
 8001aec:	4603      	movne	r3, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:91
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8001aee:	434b      	muls	r3, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8001af0:	3201      	adds	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:91
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8001af2:	fbb3 f3f2 	udiv	r3, r3, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:92
            break;
 8001af6:	e000      	b.n	8001afa <Clk_t::UpdateFreqValues()+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:81
        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
            break;

        case 0b10: // HSE
            SysClkHz = CRYSTAL_FREQ_HZ;
 8001af8:	4b15      	ldr	r3, [pc, #84]	; (8001b50 <Clk_t::UpdateFreqValues()+0x110>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:96
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
            break;
    } // switch

    // AHB freq
    tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8001afa:	4a13      	ldr	r2, [pc, #76]	; (8001b48 <Clk_t::UpdateFreqValues()+0x108>)
 8001afc:	a812      	add	r0, sp, #72	; 0x48
 8001afe:	6891      	ldr	r1, [r2, #8]
 8001b00:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8001b04:	4401      	add	r1, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:97
    AHBFreqHz = SysClkHz >> tmp;
 8001b06:	f811 1c30 	ldrb.w	r1, [r1, #-48]
 8001b0a:	40cb      	lsrs	r3, r1
 8001b0c:	602b      	str	r3, [r5, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:99
    // APB freq
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> 8];
 8001b0e:	6891      	ldr	r1, [r2, #8]
 8001b10:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8001b14:	4401      	add	r1, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:100
    APB1FreqHz = AHBFreqHz >> tmp;
 8001b16:	f811 1c44 	ldrb.w	r1, [r1, #-68]
 8001b1a:	fa23 f101 	lsr.w	r1, r3, r1
 8001b1e:	6069      	str	r1, [r5, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:101
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> 11];
 8001b20:	6892      	ldr	r2, [r2, #8]
 8001b22:	f3c2 22c2 	ubfx	r2, r2, #11, #3
 8001b26:	4402      	add	r2, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:102
    APB2FreqHz = AHBFreqHz >> tmp;
 8001b28:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 8001b2c:	40d3      	lsrs	r3, r2
 8001b2e:	60ab      	str	r3, [r5, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:103
}
 8001b30:	b013      	add	sp, #76	; 0x4c
 8001b32:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001b34:	0007ff9c 	.word	0x0007ff9c
 8001b38:	08002d40 	.word	0x08002d40
 8001b3c:	000ffdc0 	.word	0x000ffdc0
 8001b40:	001fff68 	.word	0x001fff68
 8001b44:	003ffed0 	.word	0x003ffed0
 8001b48:	40023800 	.word	0x40023800
 8001b4c:	00f42400 	.word	0x00f42400
 8001b50:	007a1200 	.word	0x007a1200
	...

08001b60 <SetupVCore(VCore_t)>:
_Z10SetupVCore7VCore_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:198

// =============================== V Core ======================================
VCore_t VCore;
void SetupVCore(VCore_t AVCore) {
    // PWR clock enable
    RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001b60:	4b09      	ldr	r3, [pc, #36]	; (8001b88 <SetupVCore(VCore_t)+0x28>)
 8001b62:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001b66:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:200 (discriminator 1)
    // Core voltage setup
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8001b68:	4b08      	ldr	r3, [pc, #32]	; (8001b8c <SetupVCore(VCore_t)+0x2c>)
 8001b6a:	685a      	ldr	r2, [r3, #4]
 8001b6c:	06d1      	lsls	r1, r2, #27
 8001b6e:	d4fb      	bmi.n	8001b68 <SetupVCore(VCore_t)+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:201
    uint32_t tmp = PWR->CR;
 8001b70:	681a      	ldr	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:202
    tmp &= ~PWR_CR_VOS;
 8001b72:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:203
    tmp |= ((uint32_t)AVCore) << 11;
 8001b76:	ea42 22c0 	orr.w	r2, r2, r0, lsl #11
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:204
    PWR->CR = tmp;
 8001b7a:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:205 (discriminator 1)
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8001b7c:	685a      	ldr	r2, [r3, #4]
 8001b7e:	06d2      	lsls	r2, r2, #27
 8001b80:	d4fc      	bmi.n	8001b7c <SetupVCore(VCore_t)+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/clocking_L1xx.cpp:206
    VCore = AVCore;
 8001b82:	4b03      	ldr	r3, [pc, #12]	; (8001b90 <SetupVCore(VCore_t)+0x30>)
 8001b84:	7018      	strb	r0, [r3, #0]
 8001b86:	4770      	bx	lr
 8001b88:	40023800 	.word	0x40023800
 8001b8c:	40007000 	.word	0x40007000
 8001b90:	20000bfc 	.word	0x20000bfc
	...

08001ba0 <CmdUart_t::IPutChar(char)>:
_ZN9CmdUart_t8IPutCharEc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:16
CmdUart_t Uart;

static inline void FPutChar(char c) { Uart.IPutChar(c); }

void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
 8001ba0:	f8d0 31fc 	ldr.w	r3, [r0, #508]	; 0x1fc
 8001ba4:	1c5a      	adds	r2, r3, #1
 8001ba6:	f8c0 21fc 	str.w	r2, [r0, #508]	; 0x1fc
 8001baa:	7019      	strb	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:17
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
 8001bac:	f8d0 31fc 	ldr.w	r3, [r0, #508]	; 0x1fc
 8001bb0:	f500 72fc 	add.w	r2, r0, #504	; 0x1f8
 8001bb4:	4293      	cmp	r3, r2
 8001bb6:	bf28      	it	cs
 8001bb8:	f8c0 01fc 	strcs.w	r0, [r0, #508]	; 0x1fc
 8001bbc:	4770      	bx	lr
	...

08001bc0 <FPutChar(char)>:
FPutChar():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:13
#include "cmd_uart.h"
#include <string.h>

CmdUart_t Uart;

static inline void FPutChar(char c) { Uart.IPutChar(c); }
 8001bc0:	4601      	mov	r1, r0
 8001bc2:	4801      	ldr	r0, [pc, #4]	; (8001bc8 <FPutChar(char)+0x8>)
 8001bc4:	f7ff bfec 	b.w	8001ba0 <CmdUart_t::IPutChar(char)>
 8001bc8:	20000c0c 	.word	0x20000c0c
$d():
 8001bcc:	00000000 	.word	0x00000000

08001bd0 <CmdUart_t::Printf(char const*, ...)>:
_ZN9CmdUart_t6PrintfEPKcz():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:20
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::Printf(const char *format, ...) {
 8001bd0:	b40e      	push	{r1, r2, r3}
 8001bd2:	b517      	push	{r0, r1, r2, r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:21
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
 8001bd4:	f8d0 31fc 	ldr.w	r3, [r0, #508]	; 0x1fc
 8001bd8:	f8d0 11f8 	ldr.w	r1, [r0, #504]	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:20
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::Printf(const char *format, ...) {
 8001bdc:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:21
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
 8001bde:	428b      	cmp	r3, r1
 8001be0:	bf28      	it	cs
 8001be2:	f501 71fc 	addcs.w	r1, r1, #504	; 0x1f8
 8001be6:	1ac9      	subs	r1, r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24
    va_list args;
    va_start(args, format);
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001be8:	4814      	ldr	r0, [pc, #80]	; (8001c3c <CmdUart_t::Printf(char const*, ...)+0x6c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:23
}

void CmdUart_t::Printf(const char *format, ...) {
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
    va_list args;
    va_start(args, format);
 8001bea:	ab06      	add	r3, sp, #24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001bec:	9a05      	ldr	r2, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:23
}

void CmdUart_t::Printf(const char *format, ...) {
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
    va_list args;
    va_start(args, format);
 8001bee:	9301      	str	r3, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001bf0:	f000 fd3e 	bl	8002670 <kl_vsprintf>
 8001bf4:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8001bf8:	4418      	add	r0, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:28
    va_end(args);

    // Start transmission if Idle
    if(IDmaIsIdle) {
 8001bfa:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:24

void CmdUart_t::Printf(const char *format, ...) {
    uint32_t MaxLength = (PWrite < PRead)? (PRead - PWrite) : ((UART_TXBUF_SIZE + PRead) - PWrite);
    va_list args;
    va_start(args, format);
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 8001bfe:	f8c4 0204 	str.w	r0, [r4, #516]	; 0x204
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:28
    va_end(args);

    // Start transmission if Idle
    if(IDmaIsIdle) {
 8001c02:	b1b3      	cbz	r3, 8001c32 <CmdUart_t::Printf(char const*, ...)+0x62>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:29
        IDmaIsIdle = false;
 8001c04:	2300      	movs	r3, #0
 8001c06:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:30
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001c0a:	4b0d      	ldr	r3, [pc, #52]	; (8001c40 <CmdUart_t::Printf(char const*, ...)+0x70>)
 8001c0c:	f8d4 21f8 	ldr.w	r2, [r4, #504]	; 0x1f8
 8001c10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:31
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;    // Char count from PRead to buffer end
 8001c12:	f504 71fc 	add.w	r1, r4, #504	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:30
    va_end(args);

    // Start transmission if Idle
    if(IDmaIsIdle) {
        IDmaIsIdle = false;
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001c16:	60da      	str	r2, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:31
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;    // Char count from PRead to buffer end
 8001c18:	1a8a      	subs	r2, r1, r2
 8001c1a:	4290      	cmp	r0, r2
 8001c1c:	bf28      	it	cs
 8001c1e:	4610      	movcs	r0, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:34
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;  // How many to transmit now
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001c20:	2292      	movs	r2, #146	; 0x92
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:32
    // Start transmission if Idle
    if(IDmaIsIdle) {
        IDmaIsIdle = false;
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;    // Char count from PRead to buffer end
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;  // How many to transmit now
 8001c22:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:33
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8001c26:	6058      	str	r0, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:34
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001c28:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:35
        dmaStreamEnable(UART_DMA_TX);
 8001c2a:	681a      	ldr	r2, [r3, #0]
 8001c2c:	f042 0201 	orr.w	r2, r2, #1
 8001c30:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:37
    }
}
 8001c32:	b003      	add	sp, #12
 8001c34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001c38:	b003      	add	sp, #12
 8001c3a:	4770      	bx	lr
 8001c3c:	08001bc1 	.word	0x08001bc1
 8001c40:	08003170 	.word	0x08003170
	...

08001c50 <CmdUart_t::Init(unsigned long)>:
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:128
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
 8001c50:	b538      	push	{r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:131
    PWrite = TXBuf;
    PRead = TXBuf;
    IDmaIsIdle = true;
 8001c52:	2301      	movs	r3, #1
 8001c54:	f880 3200 	strb.w	r3, [r0, #512]	; 0x200
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001c58:	4c2c      	ldr	r4, [pc, #176]	; (8001d0c <CmdUart_t::Init(unsigned long)+0xbc>)
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:132
    IFullSlotsCount = 0;
 8001c5a:	2300      	movs	r3, #0
 8001c5c:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
 8001c60:	69e2      	ldr	r2, [r4, #28]
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:129
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
    PWrite = TXBuf;
 8001c62:	f8c0 01fc 	str.w	r0, [r0, #508]	; 0x1fc
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
 8001c66:	f042 0201 	orr.w	r2, r2, #1
_ZN9CmdUart_t4InitEm():
    PRead = TXBuf;
 8001c6a:	f8c0 01f8 	str.w	r0, [r0, #504]	; 0x1f8
PinClockEnable():
 8001c6e:	61e2      	str	r2, [r4, #28]
PinSetupAlterFunc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001c70:	4a27      	ldr	r2, [pc, #156]	; (8001d10 <CmdUart_t::Init(unsigned long)+0xc0>)
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001c72:	4d28      	ldr	r5, [pc, #160]	; (8001d14 <CmdUart_t::Init(unsigned long)+0xc4>)
PinSetupAlterFunc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:192
 8001c74:	6810      	ldr	r0, [r2, #0]
 8001c76:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001c7a:	6010      	str	r0, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001c7c:	6810      	ldr	r0, [r2, #0]
 8001c7e:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001c82:	6010      	str	r0, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001c84:	8890      	ldrh	r0, [r2, #4]
 8001c86:	f420 7000 	bic.w	r0, r0, #512	; 0x200
 8001c8a:	0400      	lsls	r0, r0, #16
 8001c8c:	0c00      	lsrs	r0, r0, #16
 8001c8e:	8090      	strh	r0, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001c90:	8890      	ldrh	r0, [r2, #4]
 8001c92:	b280      	uxth	r0, r0
 8001c94:	8090      	strh	r0, [r2, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001c96:	68d0      	ldr	r0, [r2, #12]
 8001c98:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001c9c:	60d0      	str	r0, [r2, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001c9e:	68d0      	ldr	r0, [r2, #12]
 8001ca0:	60d0      	str	r0, [r2, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001ca2:	6890      	ldr	r0, [r2, #8]
 8001ca4:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001ca8:	6090      	str	r0, [r2, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001caa:	6890      	ldr	r0, [r2, #8]
 8001cac:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001cb0:	6090      	str	r0, [r2, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001cb2:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001cb4:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8001cb8:	6250      	str	r0, [r2, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001cba:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001cbc:	f040 0070 	orr.w	r0, r0, #112	; 0x70
 8001cc0:	6250      	str	r0, [r2, #36]	; 0x24
_ZN9CmdUart_t4InitEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:136
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8001cc2:	6a22      	ldr	r2, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001cc4:	4628      	mov	r0, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:136
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8001cc6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001cca:	6222      	str	r2, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:137
    UART->CR1 = USART_CR1_UE;     // Enable USART
 8001ccc:	f5a4 3480 	sub.w	r4, r4, #65536	; 0x10000
 8001cd0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001cd4:	81a2      	strh	r2, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:138
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
 8001cd6:	4a10      	ldr	r2, [pc, #64]	; (8001d18 <CmdUart_t::Init(unsigned long)+0xc8>)
 8001cd8:	6892      	ldr	r2, [r2, #8]
 8001cda:	fbb2 f1f1 	udiv	r1, r2, r1
 8001cde:	b28a      	uxth	r2, r1
 8001ce0:	8122      	strh	r2, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001ce2:	2107      	movs	r1, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:140
    // ==== USART configuration ====
    UART_RCC_ENABLE();
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
 8001ce4:	8223      	strh	r3, [r4, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:142
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001ce6:	4a0d      	ldr	r2, [pc, #52]	; (8001d1c <CmdUart_t::Init(unsigned long)+0xcc>)
 8001ce8:	f7ff fe62 	bl	80019b0 <dmaStreamAllocate>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:143
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 8001cec:	682b      	ldr	r3, [r5, #0]
 8001cee:	4a0c      	ldr	r2, [pc, #48]	; (8001d20 <CmdUart_t::Init(unsigned long)+0xd0>)
 8001cf0:	609a      	str	r2, [r3, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:144
    dmaStreamSetMode      (UART_DMA_TX, UART_DMA_TX_MODE);
 8001cf2:	2292      	movs	r2, #146	; 0x92
 8001cf4:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:162
    dmaStreamSetMode      (UART_DMA_RX, UART_DMA_RX_MODE);
    dmaStreamEnable       (UART_DMA_RX);
    // Create and start thread
    chThdCreateStatic(waUartRxThread, sizeof(waUartRxThread), NORMALPRIO, (tfunc_t)UartRxThread, NULL);
#else
    UART->CR1 = USART_CR1_TE;     // Transmitter enabled
 8001cf6:	2308      	movs	r3, #8
 8001cf8:	81a3      	strh	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:163
    UART->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
 8001cfa:	2380      	movs	r3, #128	; 0x80
 8001cfc:	82a3      	strh	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:165
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
 8001cfe:	89a3      	ldrh	r3, [r4, #12]
 8001d00:	b29b      	uxth	r3, r3
 8001d02:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001d06:	81a3      	strh	r3, [r4, #12]
 8001d08:	bd38      	pop	{r3, r4, r5, pc}
 8001d0a:	bf00      	nop
 8001d0c:	40023800 	.word	0x40023800
 8001d10:	40020000 	.word	0x40020000
 8001d14:	08003194 	.word	0x08003194
 8001d18:	20000c00 	.word	0x20000c00
 8001d1c:	08001da1 	.word	0x08001da1
 8001d20:	40013804 	.word	0x40013804
	...

08001d30 <CmdUart_t::IRQDmaTxHandler()>:
_ZN9CmdUart_t15IRQDmaTxHandlerEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:170
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8001d30:	4a19      	ldr	r2, [pc, #100]	; (8001d98 <CmdUart_t::IRQDmaTxHandler()+0x68>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:169
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
 8001d32:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:170
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8001d34:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8001d36:	240f      	movs	r4, #15
 8001d38:	6819      	ldr	r1, [r3, #0]
 8001d3a:	f021 010f 	bic.w	r1, r1, #15
 8001d3e:	6019      	str	r1, [r3, #0]
 8001d40:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8001d42:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8001d46:	fa04 f202 	lsl.w	r2, r4, r2
 8001d4a:	600a      	str	r2, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8001d4c:	f8d0 41f8 	ldr.w	r4, [r0, #504]	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:171
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8001d50:	f8d0 1208 	ldr.w	r1, [r0, #520]	; 0x208
 8001d54:	f8d0 2204 	ldr.w	r2, [r0, #516]	; 0x204
 8001d58:	1a52      	subs	r2, r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172
    PRead += ITransSize;
 8001d5a:	4421      	add	r1, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:173
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer
 8001d5c:	f500 74fc 	add.w	r4, r0, #504	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8001d60:	42a1      	cmp	r1, r4
 8001d62:	bf28      	it	cs
 8001d64:	4601      	movcs	r1, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:171
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8001d66:	f8c0 2204 	str.w	r2, [r0, #516]	; 0x204
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:172
    PRead += ITransSize;
 8001d6a:	f8c0 11f8 	str.w	r1, [r0, #504]	; 0x1f8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:175
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer

    if(IFullSlotsCount == 0) IDmaIsIdle = true; // Nothing left to send
 8001d6e:	b91a      	cbnz	r2, 8001d78 <CmdUart_t::IRQDmaTxHandler()+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:175 (discriminator 1)
 8001d70:	2301      	movs	r3, #1
 8001d72:	f880 3200 	strb.w	r3, [r0, #512]	; 0x200
 8001d76:	bd10      	pop	{r4, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:177
    else {  // There is something to transmit more
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001d78:	60d9      	str	r1, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:178
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;
 8001d7a:	1a61      	subs	r1, r4, r1
 8001d7c:	4291      	cmp	r1, r2
 8001d7e:	bf38      	it	cc
 8001d80:	460a      	movcc	r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:179
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;
 8001d82:	f8c0 2208 	str.w	r2, [r0, #520]	; 0x208
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:180
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8001d86:	605a      	str	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:181
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001d88:	2292      	movs	r2, #146	; 0x92
 8001d8a:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:182
        dmaStreamEnable(UART_DMA_TX);    // Restart DMA
 8001d8c:	681a      	ldr	r2, [r3, #0]
 8001d8e:	f042 0201 	orr.w	r2, r2, #1
 8001d92:	601a      	str	r2, [r3, #0]
 8001d94:	bd10      	pop	{r4, pc}
 8001d96:	bf00      	nop
 8001d98:	08003170 	.word	0x08003170
$d():
 8001d9c:	00000000 	.word	0x00000000

08001da0 <CmdUartTxIrq>:
CmdUartTxIrq():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.cpp:125
#endif

// ==== Init & DMA ====
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
 8001da0:	4801      	ldr	r0, [pc, #4]	; (8001da8 <CmdUartTxIrq+0x8>)
 8001da2:	f7ff bfc5 	b.w	8001d30 <CmdUart_t::IRQDmaTxHandler()>
 8001da6:	bf00      	nop
 8001da8:	20000c0c 	.word	0x20000c0c
$d():
 8001dac:	00000000 	.word	0x00000000

08001db0 <i2cDmaIrqHandler(void*, unsigned long)>:
_Z16i2cDmaIrqHandlerPvm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:150
    Uart.PrintNow(msg1);
}
#endif

#if 1 // ============================= I2C =====================================
void i2cDmaIrqHandler(void *p, uint32_t flags) {
 8001db0:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:151
    chSysLockFromIsr();
 8001db2:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:150
    Uart.PrintNow(msg1);
}
#endif

#if 1 // ============================= I2C =====================================
void i2cDmaIrqHandler(void *p, uint32_t flags) {
 8001db4:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:151
    chSysLockFromIsr();
 8001db6:	f383 8811 	msr	BASEPRI, r3
 8001dba:	f7ff f841 	bl	8000e40 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:153
    //Uart.Printf("===T===");
    Thread *PThd = ((i2c_t*)p)->PRequestingThread;
 8001dbe:	6960      	ldr	r0, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:154
    if (PThd != NULL) {
 8001dc0:	b118      	cbz	r0, 8001dca <i2cDmaIrqHandler(void*, unsigned long)+0x1a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:155
        ((i2c_t*)p)->PRequestingThread = NULL;
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:156
        chSchReadyI(PThd);
 8001dc6:	f7ff f963 	bl	8001090 <chSchReadyI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:158
    }
    chSysUnlockFromIsr();
 8001dca:	f7ff f851 	bl	8000e70 <dbg_check_unlock_from_isr>
 8001dce:	2300      	movs	r3, #0
 8001dd0:	f383 8811 	msr	BASEPRI, r3
 8001dd4:	bd10      	pop	{r4, pc}
	...

08001de0 <PinClockEnable(GPIO_TypeDef*)>:
PinClockEnable():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001de0:	4b12      	ldr	r3, [pc, #72]	; (8001e2c <PinClockEnable(GPIO_TypeDef*)+0x4c>)
 8001de2:	4298      	cmp	r0, r3
 8001de4:	d105      	bne.n	8001df2 <PinClockEnable(GPIO_TypeDef*)+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:130 (discriminator 1)
 8001de6:	f503 5360 	add.w	r3, r3, #14336	; 0x3800
 8001dea:	69da      	ldr	r2, [r3, #28]
 8001dec:	f042 0201 	orr.w	r2, r2, #1
 8001df0:	e019      	b.n	8001e26 <PinClockEnable(GPIO_TypeDef*)+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:131
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001df2:	4b0f      	ldr	r3, [pc, #60]	; (8001e30 <PinClockEnable(GPIO_TypeDef*)+0x50>)
 8001df4:	4298      	cmp	r0, r3
 8001df6:	d105      	bne.n	8001e04 <PinClockEnable(GPIO_TypeDef*)+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:131 (discriminator 1)
 8001df8:	f503 5350 	add.w	r3, r3, #13312	; 0x3400
 8001dfc:	69da      	ldr	r2, [r3, #28]
 8001dfe:	f042 0202 	orr.w	r2, r2, #2
 8001e02:	e010      	b.n	8001e26 <PinClockEnable(GPIO_TypeDef*)+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:132
    else if(PGpioPort == GPIOC) RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
 8001e04:	4b0b      	ldr	r3, [pc, #44]	; (8001e34 <PinClockEnable(GPIO_TypeDef*)+0x54>)
 8001e06:	4298      	cmp	r0, r3
 8001e08:	d105      	bne.n	8001e16 <PinClockEnable(GPIO_TypeDef*)+0x36>
 8001e0a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8001e0e:	69da      	ldr	r2, [r3, #28]
 8001e10:	f042 0204 	orr.w	r2, r2, #4
 8001e14:	e007      	b.n	8001e26 <PinClockEnable(GPIO_TypeDef*)+0x46>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:133
    else if(PGpioPort == GPIOD) RCC->AHBENR |= RCC_AHBENR_GPIODEN;
 8001e16:	4b08      	ldr	r3, [pc, #32]	; (8001e38 <PinClockEnable(GPIO_TypeDef*)+0x58>)
 8001e18:	4298      	cmp	r0, r3
 8001e1a:	d105      	bne.n	8001e28 <PinClockEnable(GPIO_TypeDef*)+0x48>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:133 (discriminator 1)
 8001e1c:	f503 5330 	add.w	r3, r3, #11264	; 0x2c00
 8001e20:	69da      	ldr	r2, [r3, #28]
 8001e22:	f042 0208 	orr.w	r2, r2, #8
 8001e26:	61da      	str	r2, [r3, #28]
 8001e28:	4770      	bx	lr
 8001e2a:	bf00      	nop
 8001e2c:	40020000 	.word	0x40020000
 8001e30:	40020400 	.word	0x40020400
 8001e34:	40020800 	.word	0x40020800
 8001e38:	40020c00 	.word	0x40020c00
$d():
 8001e3c:	00000000 	.word	0x00000000

08001e40 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>:
PinSetupAlterFunc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:181
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
}

static inline void PinSetupAlterFunc(
 8001e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e42:	460d      	mov	r5, r1
 8001e44:	4604      	mov	r4, r0
 8001e46:	4616      	mov	r6, r2
 8001e48:	461f      	mov	r7, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:189
        const PinOutMode_t PinOutMode,
        const PinPullUpDown_t APullUpDown,
        const PinAF_t AAlterFunc,
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
 8001e4a:	f7ff ffc9 	bl	8001de0 <PinClockEnable(GPIO_TypeDef*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:190
    uint32_t Offset = APinNumber*2;
 8001e4e:	0069      	lsls	r1, r5, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:192
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001e50:	2003      	movs	r0, #3
 8001e52:	4088      	lsls	r0, r1
 8001e54:	6823      	ldr	r3, [r4, #0]
 8001e56:	43c0      	mvns	r0, r0
 8001e58:	4003      	ands	r3, r0
 8001e5a:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001e5c:	2302      	movs	r3, #2
 8001e5e:	408b      	lsls	r3, r1
 8001e60:	6822      	ldr	r2, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001e62:	40ae      	lsls	r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:193
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001e64:	4313      	orrs	r3, r2
 8001e66:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001e68:	2301      	movs	r3, #1
 8001e6a:	40ab      	lsls	r3, r5
 8001e6c:	88a2      	ldrh	r2, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:204
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
 8001e6e:	2d07      	cmp	r5, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001e70:	b292      	uxth	r2, r2
 8001e72:	ea22 0303 	bic.w	r3, r2, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001e76:	f89d 2018 	ldrb.w	r2, [sp, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:195
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001e7a:	80a3      	strh	r3, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001e7c:	fa02 f101 	lsl.w	r1, r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001e80:	88a3      	ldrh	r3, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:205
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
 8001e82:	bf88      	it	hi
 8001e84:	3d08      	subhi	r5, #8
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:196
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001e86:	ea46 0603 	orr.w	r6, r6, r3
 8001e8a:	b2b6      	uxth	r6, r6
 8001e8c:	80a6      	strh	r6, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001e8e:	68e3      	ldr	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:205
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
 8001e90:	ea4f 0585 	mov.w	r5, r5, lsl #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:198
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001e94:	ea00 0303 	and.w	r3, r0, r3
 8001e98:	60e3      	str	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001e9a:	68e3      	ldr	r3, [r4, #12]
 8001e9c:	60e3      	str	r3, [r4, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001e9e:	68a3      	ldr	r3, [r4, #8]
 8001ea0:	ea00 0003 	and.w	r0, r0, r3
 8001ea4:	60a0      	str	r0, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001ea6:	68a3      	ldr	r3, [r4, #8]
 8001ea8:	ea41 0103 	orr.w	r1, r1, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:204
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
 8001eac:	bf94      	ite	ls
 8001eae:	2300      	movls	r3, #0
 8001eb0:	2301      	movhi	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:202
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001eb2:	60a1      	str	r1, [r4, #8]
 8001eb4:	eb04 0483 	add.w	r4, r4, r3, lsl #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001eb8:	230f      	movs	r3, #15
 8001eba:	40ab      	lsls	r3, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001ebc:	fa07 f505 	lsl.w	r5, r7, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:206
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001ec0:	6a22      	ldr	r2, [r4, #32]
 8001ec2:	ea22 0303 	bic.w	r3, r2, r3
 8001ec6:	6223      	str	r3, [r4, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001ec8:	6a23      	ldr	r3, [r4, #32]
 8001eca:	431d      	orrs	r5, r3
 8001ecc:	6225      	str	r5, [r4, #32]
 8001ece:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001ed0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)>:
_ZN8PwmPin_t4InitEP12GPIO_TypeDeftP11TIM_TypeDefhtb():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:67
    }
}
#endif

#if 1 // ============================= PWM pin =================================
void PwmPin_t::Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted) {
 8001ed0:	b513      	push	{r0, r1, r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:69
    Tim = PTim;
    if(Tim == TIM2) {
 8001ed2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:67
    }
}
#endif

#if 1 // ============================= PWM pin =================================
void PwmPin_t::Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted) {
 8001ed6:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:68
    Tim = PTim;
 8001ed8:	6063      	str	r3, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:67
    }
}
#endif

#if 1 // ============================= PWM pin =================================
void PwmPin_t::Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted) {
 8001eda:	4608      	mov	r0, r1
 8001edc:	4611      	mov	r1, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:69
    Tim = PTim;
    if(Tim == TIM2) {
 8001ede:	d10a      	bne.n	8001ef6 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x26>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:70
        rccEnableTIM2(FALSE);
 8001ee0:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 8001ee4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001ee6:	f042 0201 	orr.w	r2, r2, #1
 8001eea:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:71
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF1);
 8001eec:	2302      	movs	r3, #2
 8001eee:	9300      	str	r3, [sp, #0]
 8001ef0:	2200      	movs	r2, #0
 8001ef2:	2301      	movs	r3, #1
 8001ef4:	e02f      	b.n	8001f56 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x86>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:73
    }
    else if(Tim == TIM3) {
 8001ef6:	4a48      	ldr	r2, [pc, #288]	; (8002018 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x148>)
 8001ef8:	4293      	cmp	r3, r2
 8001efa:	d104      	bne.n	8001f06 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:74
        rccEnableTIM3(FALSE);
 8001efc:	4b47      	ldr	r3, [pc, #284]	; (800201c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x14c>)
 8001efe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001f00:	f042 0202 	orr.w	r2, r2, #2
 8001f04:	e006      	b.n	8001f14 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x44>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:77
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF2);
    }
    else if(Tim == TIM4) {
 8001f06:	4a46      	ldr	r2, [pc, #280]	; (8002020 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x150>)
 8001f08:	4293      	cmp	r3, r2
 8001f0a:	d108      	bne.n	8001f1e <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:78
        rccEnableTIM4(FALSE);
 8001f0c:	4b43      	ldr	r3, [pc, #268]	; (800201c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x14c>)
 8001f0e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001f10:	f042 0204 	orr.w	r2, r2, #4
 8001f14:	625a      	str	r2, [r3, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:79
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF2);
 8001f16:	2302      	movs	r3, #2
 8001f18:	9300      	str	r3, [sp, #0]
 8001f1a:	2200      	movs	r2, #0
 8001f1c:	e01b      	b.n	8001f56 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x86>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:81
    }
    else if(Tim == TIM9) {
 8001f1e:	4a41      	ldr	r2, [pc, #260]	; (8002024 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x154>)
 8001f20:	4293      	cmp	r3, r2
 8001f22:	d104      	bne.n	8001f2e <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:82
        rccEnableTIM9(FALSE);
 8001f24:	4b3d      	ldr	r3, [pc, #244]	; (800201c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x14c>)
 8001f26:	6a1a      	ldr	r2, [r3, #32]
 8001f28:	f042 0204 	orr.w	r2, r2, #4
 8001f2c:	e00e      	b.n	8001f4c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x7c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:85
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
    }
    else if(Tim == TIM10) {
 8001f2e:	4a3e      	ldr	r2, [pc, #248]	; (8002028 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x158>)
 8001f30:	4293      	cmp	r3, r2
 8001f32:	d104      	bne.n	8001f3e <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x6e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:86
        rccEnableAPB2(RCC_APB2ENR_TIM10EN, FALSE);
 8001f34:	4b39      	ldr	r3, [pc, #228]	; (800201c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x14c>)
 8001f36:	6a1a      	ldr	r2, [r3, #32]
 8001f38:	f042 0208 	orr.w	r2, r2, #8
 8001f3c:	e006      	b.n	8001f4c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x7c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:89
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
    }
    else if(Tim == TIM11) {
 8001f3e:	4a3b      	ldr	r2, [pc, #236]	; (800202c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x15c>)
 8001f40:	4293      	cmp	r3, r2
 8001f42:	d10a      	bne.n	8001f5a <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x8a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:90
        rccEnableAPB2(RCC_APB2ENR_TIM11EN, FALSE);
 8001f44:	4b35      	ldr	r3, [pc, #212]	; (800201c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x14c>)
 8001f46:	6a1a      	ldr	r2, [r3, #32]
 8001f48:	f042 0210 	orr.w	r2, r2, #16
 8001f4c:	621a      	str	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:91
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
 8001f4e:	2302      	movs	r3, #2
 8001f50:	9300      	str	r3, [sp, #0]
 8001f52:	2200      	movs	r2, #0
 8001f54:	2303      	movs	r3, #3
 8001f56:	f7ff ff73 	bl	8001e40 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:94
    }
    // Clock src
    if(ANY_OF_3(Tim, TIM2, TIM3, TIM4)) PClk = &Clk.APB1FreqHz;
 8001f5a:	6863      	ldr	r3, [r4, #4]
 8001f5c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001f60:	d006      	beq.n	8001f70 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0xa0>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:94 (discriminator 2)
 8001f62:	4a2d      	ldr	r2, [pc, #180]	; (8002018 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x148>)
 8001f64:	4293      	cmp	r3, r2
 8001f66:	d003      	beq.n	8001f70 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0xa0>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:94 (discriminator 1)
 8001f68:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f6c:	4293      	cmp	r3, r2
 8001f6e:	d101      	bne.n	8001f74 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0xa4>
 8001f70:	4a2f      	ldr	r2, [pc, #188]	; (8002030 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x160>)
 8001f72:	e000      	b.n	8001f76 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0xa6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:95
    else PClk = &Clk.APB2FreqHz;
 8001f74:	4a2f      	ldr	r2, [pc, #188]	; (8002034 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x164>)
 8001f76:	6022      	str	r2, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:98

    // Common
    Tim->CR1 = TIM_CR1_CEN; // Enable timer, set clk division to 0, AutoReload not buffered
 8001f78:	2201      	movs	r2, #1
 8001f7a:	801a      	strh	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:99
    Tim->CR2 = 0;
 8001f7c:	2200      	movs	r2, #0
 8001f7e:	809a      	strh	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:100
    Tim->ARR = TopValue;
 8001f80:	f8bd 2014 	ldrh.w	r2, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:104

    // Output
    uint16_t tmp = Inverted? 0b111 : 0b110; // PWM mode 1 or 2
    switch(Chnl) {
 8001f84:	f89d 1010 	ldrb.w	r1, [sp, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:100
    else PClk = &Clk.APB2FreqHz;

    // Common
    Tim->CR1 = TIM_CR1_CEN; // Enable timer, set clk division to 0, AutoReload not buffered
    Tim->CR2 = 0;
    Tim->ARR = TopValue;
 8001f88:	62da      	str	r2, [r3, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:103

    // Output
    uint16_t tmp = Inverted? 0b111 : 0b110; // PWM mode 1 or 2
 8001f8a:	f89d 2018 	ldrb.w	r2, [sp, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:104
    switch(Chnl) {
 8001f8e:	3901      	subs	r1, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:103
    Tim->CR1 = TIM_CR1_CEN; // Enable timer, set clk division to 0, AutoReload not buffered
    Tim->CR2 = 0;
    Tim->ARR = TopValue;

    // Output
    uint16_t tmp = Inverted? 0b111 : 0b110; // PWM mode 1 or 2
 8001f90:	2a00      	cmp	r2, #0
 8001f92:	bf0c      	ite	eq
 8001f94:	2206      	moveq	r2, #6
 8001f96:	2207      	movne	r2, #7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:104
    switch(Chnl) {
 8001f98:	2903      	cmp	r1, #3
 8001f9a:	d837      	bhi.n	800200c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x13c>
 8001f9c:	e8df f001 	tbb	[pc, r1]
 8001fa0:	291c0f02 	.word	0x291c0f02
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:106
        case 1:
            PCCR = &Tim->CCR1;
 8001fa4:	f103 0134 	add.w	r1, r3, #52	; 0x34
 8001fa8:	60a1      	str	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:107
            Tim->CCMR1 |= (tmp << 4);
 8001faa:	8b19      	ldrh	r1, [r3, #24]
 8001fac:	b289      	uxth	r1, r1
 8001fae:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
 8001fb2:	831a      	strh	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:108
            Tim->CCER  |= TIM_CCER_CC1E;
 8001fb4:	8c1a      	ldrh	r2, [r3, #32]
 8001fb6:	b292      	uxth	r2, r2
 8001fb8:	f042 0201 	orr.w	r2, r2, #1
 8001fbc:	e025      	b.n	800200a <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x13a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:112
            break;

        case 2:
            PCCR = &Tim->CCR2;
 8001fbe:	f103 0138 	add.w	r1, r3, #56	; 0x38
 8001fc2:	60a1      	str	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:113
            Tim->CCMR1 |= (tmp << 12);
 8001fc4:	8b19      	ldrh	r1, [r3, #24]
 8001fc6:	b289      	uxth	r1, r1
 8001fc8:	ea41 3202 	orr.w	r2, r1, r2, lsl #12
 8001fcc:	831a      	strh	r2, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:114
            Tim->CCER  |= TIM_CCER_CC2E;
 8001fce:	8c1a      	ldrh	r2, [r3, #32]
 8001fd0:	b292      	uxth	r2, r2
 8001fd2:	f042 0210 	orr.w	r2, r2, #16
 8001fd6:	e018      	b.n	800200a <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x13a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:118
            break;

        case 3:
            PCCR = &Tim->CCR3;
 8001fd8:	f103 013c 	add.w	r1, r3, #60	; 0x3c
 8001fdc:	60a1      	str	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:119
            Tim->CCMR2 |= (tmp << 4);
 8001fde:	8b99      	ldrh	r1, [r3, #28]
 8001fe0:	b289      	uxth	r1, r1
 8001fe2:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
 8001fe6:	839a      	strh	r2, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:120
            Tim->CCER  |= TIM_CCER_CC3E;
 8001fe8:	8c1a      	ldrh	r2, [r3, #32]
 8001fea:	b292      	uxth	r2, r2
 8001fec:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001ff0:	e00b      	b.n	800200a <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x13a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:124
            break;

        case 4:
            PCCR = &Tim->CCR4;
 8001ff2:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8001ff6:	60a1      	str	r1, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:125
            Tim->CCMR2 |= (tmp << 12);
 8001ff8:	8b99      	ldrh	r1, [r3, #28]
 8001ffa:	b289      	uxth	r1, r1
 8001ffc:	ea41 3202 	orr.w	r2, r1, r2, lsl #12
 8002000:	839a      	strh	r2, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:126
            Tim->CCER  |= TIM_CCER_CC4E;
 8002002:	8c1a      	ldrh	r2, [r3, #32]
 8002004:	b292      	uxth	r2, r2
 8002006:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800200a:	841a      	strh	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:131
            break;

        default: break;
    }
    *PCCR = 0;
 800200c:	68a3      	ldr	r3, [r4, #8]
 800200e:	2200      	movs	r2, #0
 8002010:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:132
}
 8002012:	b002      	add	sp, #8
 8002014:	bd10      	pop	{r4, pc}
 8002016:	bf00      	nop
 8002018:	40000400 	.word	0x40000400
 800201c:	40023800 	.word	0x40023800
 8002020:	40000800 	.word	0x40000800
 8002024:	40010800 	.word	0x40010800
 8002028:	40010c00 	.word	0x40010c00
 800202c:	40011000 	.word	0x40011000
 8002030:	20000c04 	.word	0x20000c04
 8002034:	20000c08 	.word	0x20000c08
	...

08002040 <PwmPin_t::SetFreqHz(unsigned long)>:
_ZN8PwmPin_t9SetFreqHzEm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:135

void PwmPin_t::SetFreqHz(uint32_t FreqHz) {
    uint32_t divider = Tim->ARR * FreqHz;
 8002040:	6843      	ldr	r3, [r0, #4]
 8002042:	6ada      	ldr	r2, [r3, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:136
    if(divider == 0) return;
 8002044:	4351      	muls	r1, r2
 8002046:	d007      	beq.n	8002058 <PwmPin_t::SetFreqHz(unsigned long)+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:137
    uint32_t FPrescaler = *PClk / divider;
 8002048:	6802      	ldr	r2, [r0, #0]
 800204a:	6812      	ldr	r2, [r2, #0]
 800204c:	fbb2 f1f1 	udiv	r1, r2, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:138
    if(FPrescaler != 0) FPrescaler--;   // do not decrease in case of high freq
 8002050:	b101      	cbz	r1, 8002054 <PwmPin_t::SetFreqHz(unsigned long)+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:138 (discriminator 1)
 8002052:	3901      	subs	r1, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:139
    Tim->PSC = (uint16_t)FPrescaler;
 8002054:	b289      	uxth	r1, r1
 8002056:	8519      	strh	r1, [r3, #40]	; 0x28
 8002058:	4770      	bx	lr
 800205a:	0000      	movs	r0, r0
 800205c:	0000      	movs	r0, r0
	...

08002060 <chDbgPanic>:
chDbgPanic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:144
}
#endif

#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
 8002060:	3801      	subs	r0, #1
_ZN9CmdUart_t8PrintNowEPKc():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.h:72
#endif
public:
    void Printf(const char *S, ...);
    void FlushTx() { while(!IDmaIsIdle); }  // wait DMA
    void PrintNow(const char *S) {
        while(*S != 0) {
 8002062:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8002066:	b12b      	cbz	r3, 8002074 <chDbgPanic+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.h:73
            while(!(UART->SR & USART_SR_TXE));
 8002068:	4a03      	ldr	r2, [pc, #12]	; (8002078 <chDbgPanic+0x18>)
 800206a:	8811      	ldrh	r1, [r2, #0]
 800206c:	0609      	lsls	r1, r1, #24
 800206e:	d5fb      	bpl.n	8002068 <chDbgPanic+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/cmd_uart.h:74
            UART->DR = *S++;
 8002070:	8093      	strh	r3, [r2, #4]
 8002072:	e7f6      	b.n	8002062 <chDbgPanic+0x2>
chDbgPanic():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:146
    Uart.PrintNow(msg1);
}
 8002074:	4770      	bx	lr
 8002076:	bf00      	nop
 8002078:	40013800 	.word	0x40013800
$d():
 800207c:	00000000 	.word	0x00000000

08002080 <i2c_t::Standby()>:
_ZN5i2c_t7StandbyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
 8002080:	6803      	ldr	r3, [r0, #0]
 8002082:	4a1c      	ldr	r2, [pc, #112]	; (80020f4 <i2c_t::Standby()+0x74>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:190
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
 8002084:	b570      	push	{r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
 8002086:	4293      	cmp	r3, r2
 8002088:	4b1b      	ldr	r3, [pc, #108]	; (80020f8 <i2c_t::Standby()+0x78>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:190
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
 800208a:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
 800208c:	699a      	ldr	r2, [r3, #24]
 800208e:	d108      	bne.n	80020a2 <i2c_t::Standby()+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:191 (discriminator 1)
 8002090:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002094:	619a      	str	r2, [r3, #24]
 8002096:	2200      	movs	r2, #0
 8002098:	619a      	str	r2, [r3, #24]
 800209a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800209c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80020a0:	e007      	b.n	80020b2 <i2c_t::Standby()+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:192
    else             { rccResetI2C2(); rccDisableI2C2(FALSE); }
 80020a2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80020a6:	619a      	str	r2, [r3, #24]
 80020a8:	2200      	movs	r2, #0
 80020aa:	619a      	str	r2, [r3, #24]
 80020ac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80020ae:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:194
    // Disable GPIOs
    PinSetupAnalog(IPGpio, ISclPin);
 80020b2:	686c      	ldr	r4, [r5, #4]
 80020b4:	892e      	ldrh	r6, [r5, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:192
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
}

void i2c_t::Standby() {
    if(ii2c == I2C1) { rccResetI2C1(); rccDisableI2C1(FALSE); }
    else             { rccResetI2C2(); rccDisableI2C2(FALSE); }
 80020b6:	625a      	str	r2, [r3, #36]	; 0x24
PinSetupAnalog():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:174
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
 80020b8:	4620      	mov	r0, r4
 80020ba:	f7ff fe91 	bl	8001de0 <PinClockEnable(GPIO_TypeDef*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:176
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 80020be:	0073      	lsls	r3, r6, #1
 80020c0:	2603      	movs	r6, #3
 80020c2:	fa06 f303 	lsl.w	r3, r6, r3
 80020c6:	6822      	ldr	r2, [r4, #0]
 80020c8:	431a      	orrs	r2, r3
 80020ca:	6022      	str	r2, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:178
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 80020cc:	68e2      	ldr	r2, [r4, #12]
 80020ce:	ea22 0303 	bic.w	r3, r2, r3
 80020d2:	60e3      	str	r3, [r4, #12]
_ZN5i2c_t7StandbyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:195
    // Disable GPIOs
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
 80020d4:	686c      	ldr	r4, [r5, #4]
 80020d6:	896d      	ldrh	r5, [r5, #10]
PinSetupAnalog():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:174
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
 80020d8:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:176
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 80020da:	006d      	lsls	r5, r5, #1
 80020dc:	40ae      	lsls	r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:174
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
 80020de:	f7ff fe7f 	bl	8001de0 <PinClockEnable(GPIO_TypeDef*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:176
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 80020e2:	6823      	ldr	r3, [r4, #0]
 80020e4:	4333      	orrs	r3, r6
 80020e6:	6023      	str	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:178
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 80020e8:	68e3      	ldr	r3, [r4, #12]
 80020ea:	ea23 0606 	bic.w	r6, r3, r6
 80020ee:	60e6      	str	r6, [r4, #12]
 80020f0:	bd70      	pop	{r4, r5, r6, pc}
 80020f2:	bf00      	nop
 80020f4:	40005400 	.word	0x40005400
 80020f8:	40023800 	.word	0x40023800
$d():
 80020fc:	00000000 	.word	0x00000000

08002100 <i2c_t::Resume()>:
_ZN5i2c_t6ResumeEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:198
}

void i2c_t::Resume() {
 8002100:	b573      	push	{r0, r1, r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    Error = false;
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 8002102:	2602      	movs	r6, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:199
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
}

void i2c_t::Resume() {
    Error = false;
 8002104:	2500      	movs	r5, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 8002106:	8901      	ldrh	r1, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:199
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
}

void i2c_t::Resume() {
    Error = false;
 8002108:	7405      	strb	r5, [r0, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 800210a:	9600      	str	r6, [sp, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:198
    // Disable GPIOs
    PinSetupAnalog(IPGpio, ISclPin);
    PinSetupAnalog(IPGpio, ISdaPin);
}

void i2c_t::Resume() {
 800210c:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:201
    Error = false;
    // ==== GPIOs ====
    PinSetupAlterFunc(IPGpio, ISclPin, omOpenDrain, pudNone, AF4);
 800210e:	2201      	movs	r2, #1
 8002110:	6840      	ldr	r0, [r0, #4]
 8002112:	2304      	movs	r3, #4
 8002114:	f7ff fe94 	bl	8001e40 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:202
    PinSetupAlterFunc(IPGpio, ISdaPin, omOpenDrain, pudNone, AF4);
 8002118:	8961      	ldrh	r1, [r4, #10]
 800211a:	2201      	movs	r2, #1
 800211c:	2304      	movs	r3, #4
 800211e:	9600      	str	r6, [sp, #0]
 8002120:	6860      	ldr	r0, [r4, #4]
 8002122:	f7ff fe8d 	bl	8001e40 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.11]>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:204
    // ==== Clock and reset ====
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
 8002126:	4a29      	ldr	r2, [pc, #164]	; (80021cc <i2c_t::Resume()+0xcc>)
 8002128:	6823      	ldr	r3, [r4, #0]
 800212a:	4293      	cmp	r3, r2
 800212c:	f502 32f2 	add.w	r2, r2, #123904	; 0x1e400
 8002130:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8002132:	d106      	bne.n	8002142 <i2c_t::Resume()+0x42>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:204 (discriminator 1)
 8002134:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8002138:	6251      	str	r1, [r2, #36]	; 0x24
 800213a:	6991      	ldr	r1, [r2, #24]
 800213c:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8002140:	e005      	b.n	800214e <i2c_t::Resume()+0x4e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:205
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
 8002142:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 8002146:	6251      	str	r1, [r2, #36]	; 0x24
 8002148:	6991      	ldr	r1, [r2, #24]
 800214a:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 800214e:	6191      	str	r1, [r2, #24]
 8002150:	6195      	str	r5, [r2, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:207
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
 8002152:	4a1f      	ldr	r2, [pc, #124]	; (80021d0 <i2c_t::Resume()+0xd0>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:208
    uint16_t tmpreg = ii2c->CR2;
 8002154:	8899      	ldrh	r1, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:207
    PinSetupAlterFunc(IPGpio, ISdaPin, omOpenDrain, pudNone, AF4);
    // ==== Clock and reset ====
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
 8002156:	6850      	ldr	r0, [r2, #4]
 8002158:	4a1e      	ldr	r2, [pc, #120]	; (80021d4 <i2c_t::Resume()+0xd4>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:209
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
 800215a:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:207
    PinSetupAlterFunc(IPGpio, ISdaPin, omOpenDrain, pudNone, AF4);
    // ==== Clock and reset ====
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
 800215e:	fbb0 f2f2 	udiv	r2, r0, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:209
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
 8002162:	0409      	lsls	r1, r1, #16
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:210
    if(ClkMhz < 2)  ClkMhz = 2;
 8002164:	2a01      	cmp	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:209
    if(ii2c == I2C1) { rccEnableI2C1(FALSE); rccResetI2C1(); }
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
 8002166:	ea4f 4111 	mov.w	r1, r1, lsr #16
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:210
    if(ClkMhz < 2)  ClkMhz = 2;
 800216a:	d903      	bls.n	8002174 <i2c_t::Resume()+0x74>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:211
    if(ClkMhz > 32) ClkMhz = 32;
 800216c:	2a21      	cmp	r2, #33	; 0x21
 800216e:	bf28      	it	cs
 8002170:	2220      	movcs	r2, #32
 8002172:	e000      	b.n	8002176 <i2c_t::Resume()+0x76>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:210
    else             { rccEnableI2C2(FALSE); rccResetI2C2(); }
    // Minimum clock is 2 MHz
    uint32_t ClkMhz = Clk.APB1FreqHz / 1000000;
    uint16_t tmpreg = ii2c->CR2;
    tmpreg &= (uint16_t)~I2C_CR2_FREQ;
    if(ClkMhz < 2)  ClkMhz = 2;
 8002174:	2202      	movs	r2, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:212
    if(ClkMhz > 32) ClkMhz = 32;
    tmpreg |= ClkMhz;
 8002176:	4311      	orrs	r1, r2
 8002178:	b289      	uxth	r1, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:213
    ii2c->CR2 = tmpreg;
 800217a:	8099      	strh	r1, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:214
    ii2c->CR1 &= (uint16_t)~I2C_CR1_PE; // Disable i2c to setup TRise & CCR
 800217c:	8819      	ldrh	r1, [r3, #0]
 800217e:	f021 0101 	bic.w	r1, r1, #1
 8002182:	0409      	lsls	r1, r1, #16
 8002184:	0c09      	lsrs	r1, r1, #16
 8002186:	8019      	strh	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:215
    ii2c->TRISE = (uint16_t)(((ClkMhz * 300) / 1000) + 1);
 8002188:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800218c:	434a      	muls	r2, r1
 800218e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8002192:	fbb2 f2f1 	udiv	r2, r2, r1
 8002196:	3201      	adds	r2, #1
 8002198:	b292      	uxth	r2, r2
 800219a:	841a      	strh	r2, [r3, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:217
    // 16/9
    tmpreg = (uint16_t)(Clk.APB1FreqHz / (IBitrateHz * 25));
 800219c:	68e2      	ldr	r2, [r4, #12]
 800219e:	2119      	movs	r1, #25
 80021a0:	434a      	muls	r2, r1
 80021a2:	fbb0 f2f2 	udiv	r2, r0, r2
 80021a6:	b292      	uxth	r2, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:218
    if(tmpreg == 0) tmpreg = 1; // minimum allowed value
 80021a8:	2a00      	cmp	r2, #0
 80021aa:	bf08      	it	eq
 80021ac:	2201      	moveq	r2, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:219
    tmpreg |= I2C_CCR_FS | I2C_CCR_DUTY;
 80021ae:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:220
    ii2c->CCR = tmpreg;
 80021b2:	839a      	strh	r2, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:221
    ii2c->CR1 |= I2C_CR1_PE;    // Enable i2c back
 80021b4:	881a      	ldrh	r2, [r3, #0]
 80021b6:	b292      	uxth	r2, r2
 80021b8:	f042 0201 	orr.w	r2, r2, #1
 80021bc:	801a      	strh	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:223
    // ==== DMA ====
    ii2c->CR2 |= I2C_CR2_DMAEN;
 80021be:	889a      	ldrh	r2, [r3, #4]
 80021c0:	b292      	uxth	r2, r2
 80021c2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80021c6:	809a      	strh	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:224
}
 80021c8:	b002      	add	sp, #8
 80021ca:	bd70      	pop	{r4, r5, r6, pc}
 80021cc:	40005400 	.word	0x40005400
 80021d0:	20000c00 	.word	0x20000c00
 80021d4:	000f4240 	.word	0x000f4240
	...

080021e0 <i2c_t::Init(I2C_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned short, unsigned long, stm32_dma_stream_t const*, stm32_dma_stream_t const*)>:
_ZN5i2c_t4InitEP11I2C_TypeDefP12GPIO_TypeDefttmPK18stm32_dma_stream_tS6_():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:169
        uint16_t SclPin,
        uint16_t SdaPin,
        uint32_t BitrateHz,
        const stm32_dma_stream_t *APDmaTx,
        const stm32_dma_stream_t *APDmaRx
    ) {
 80021e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:172
    ii2c = pi2c;
    IPGpio = PGpio;
    ISclPin = SclPin;
 80021e2:	8103      	strh	r3, [r0, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:173
    ISdaPin = SdaPin;
 80021e4:	f8bd 3018 	ldrh.w	r3, [sp, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:169
        uint16_t SclPin,
        uint16_t SdaPin,
        uint32_t BitrateHz,
        const stm32_dma_stream_t *APDmaTx,
        const stm32_dma_stream_t *APDmaRx
    ) {
 80021e8:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:173
    ii2c = pi2c;
    IPGpio = PGpio;
    ISclPin = SclPin;
    ISdaPin = SdaPin;
 80021ea:	8143      	strh	r3, [r0, #10]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:174
    IBitrateHz = BitrateHz;
 80021ec:	9b07      	ldr	r3, [sp, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:171
        uint32_t BitrateHz,
        const stm32_dma_stream_t *APDmaTx,
        const stm32_dma_stream_t *APDmaRx
    ) {
    ii2c = pi2c;
    IPGpio = PGpio;
 80021ee:	e880 0006 	stmia.w	r0, {r1, r2}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:174
    ISclPin = SclPin;
    ISdaPin = SdaPin;
    IBitrateHz = BitrateHz;
 80021f2:	60c3      	str	r3, [r0, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:169
        uint16_t SclPin,
        uint16_t SdaPin,
        uint32_t BitrateHz,
        const stm32_dma_stream_t *APDmaTx,
        const stm32_dma_stream_t *APDmaRx
    ) {
 80021f4:	9e08      	ldr	r6, [sp, #32]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:182

    // ==== DMA ====
    // Here only unchanged parameters of the DMA are configured.
    // Setup Dma TX
    PDmaTx = APDmaTx;
    dmaStreamAllocate(PDmaTx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 80021f6:	4f10      	ldr	r7, [pc, #64]	; (8002238 <i2c_t::Init(I2C_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned short, unsigned long, stm32_dma_stream_t const*, stm32_dma_stream_t const*)+0x58>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:169
        uint16_t SclPin,
        uint16_t SdaPin,
        uint32_t BitrateHz,
        const stm32_dma_stream_t *APDmaTx,
        const stm32_dma_stream_t *APDmaRx
    ) {
 80021f8:	9d09      	ldr	r5, [sp, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:175
    ii2c = pi2c;
    IPGpio = PGpio;
    ISclPin = SclPin;
    ISdaPin = SdaPin;
    IBitrateHz = BitrateHz;
    Standby();
 80021fa:	f7ff ff41 	bl	8002080 <i2c_t::Standby()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:176
    Resume();
 80021fe:	4620      	mov	r0, r4
 8002200:	f7ff ff7e 	bl	8002100 <i2c_t::Resume()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:182

    // ==== DMA ====
    // Here only unchanged parameters of the DMA are configured.
    // Setup Dma TX
    PDmaTx = APDmaTx;
    dmaStreamAllocate(PDmaTx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 8002204:	2109      	movs	r1, #9
 8002206:	463a      	mov	r2, r7
 8002208:	4623      	mov	r3, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:181
    Resume();

    // ==== DMA ====
    // Here only unchanged parameters of the DMA are configured.
    // Setup Dma TX
    PDmaTx = APDmaTx;
 800220a:	61a6      	str	r6, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:182
    dmaStreamAllocate(PDmaTx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 800220c:	4630      	mov	r0, r6
 800220e:	f7ff fbcf 	bl	80019b0 <dmaStreamAllocate>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:183
    dmaStreamSetPeripheral(PDmaTx, &ii2c->DR);
 8002212:	69a3      	ldr	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:186
    // Setup Dma RX
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 8002214:	4628      	mov	r0, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:183
    // ==== DMA ====
    // Here only unchanged parameters of the DMA are configured.
    // Setup Dma TX
    PDmaTx = APDmaTx;
    dmaStreamAllocate(PDmaTx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaTx, &ii2c->DR);
 8002216:	681a      	ldr	r2, [r3, #0]
 8002218:	6823      	ldr	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:186
    // Setup Dma RX
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 800221a:	2109      	movs	r1, #9
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:183
    // ==== DMA ====
    // Here only unchanged parameters of the DMA are configured.
    // Setup Dma TX
    PDmaTx = APDmaTx;
    dmaStreamAllocate(PDmaTx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaTx, &ii2c->DR);
 800221c:	3310      	adds	r3, #16
 800221e:	6093      	str	r3, [r2, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:186
    // Setup Dma RX
    PDmaRx = APDmaRx;
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 8002220:	463a      	mov	r2, r7
 8002222:	4623      	mov	r3, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:185
    // Setup Dma TX
    PDmaTx = APDmaTx;
    dmaStreamAllocate(PDmaTx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
    dmaStreamSetPeripheral(PDmaTx, &ii2c->DR);
    // Setup Dma RX
    PDmaRx = APDmaRx;
 8002224:	61e5      	str	r5, [r4, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:186
    dmaStreamAllocate(PDmaRx, IRQ_PRIO_MEDIUM, i2cDmaIrqHandler, this);
 8002226:	f7ff fbc3 	bl	80019b0 <dmaStreamAllocate>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:187
    dmaStreamSetPeripheral(PDmaRx, &ii2c->DR);
 800222a:	69e3      	ldr	r3, [r4, #28]
 800222c:	6822      	ldr	r2, [r4, #0]
 800222e:	681b      	ldr	r3, [r3, #0]
 8002230:	3210      	adds	r2, #16
 8002232:	609a      	str	r2, [r3, #8]
 8002234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002236:	bf00      	nop
 8002238:	08001db1 	.word	0x08001db1
$d():
 800223c:	00000000 	.word	0x00000000

08002240 <i2c_t::IBusyWait()>:
_ZN5i2c_t9IBusyWaitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:332
    return OK;
}

// ==== Flag operations ====
// Busy flag
uint8_t i2c_t::IBusyWait() {
 8002240:	b538      	push	{r3, r4, r5, lr}
 8002242:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:334
    uint8_t RetryCnt = 4;
    while(RetryCnt--) {
 8002244:	2505      	movs	r5, #5
 8002246:	3d01      	subs	r5, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:334 (discriminator 1)
 8002248:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 800224c:	d009      	beq.n	8002262 <i2c_t::IBusyWait()+0x22>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:335
        if(!(ii2c->SR2 & I2C_SR2_BUSY)) return OK;
 800224e:	6823      	ldr	r3, [r4, #0]
 8002250:	8b18      	ldrh	r0, [r3, #24]
 8002252:	f000 0002 	and.w	r0, r0, #2
 8002256:	b280      	uxth	r0, r0
 8002258:	b130      	cbz	r0, 8002268 <i2c_t::IBusyWait()+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:336
        chThdSleepMilliseconds(1);
 800225a:	2001      	movs	r0, #1
 800225c:	f7ff f9c8 	bl	80015f0 <chThdSleep>
 8002260:	e7f1      	b.n	8002246 <i2c_t::IBusyWait()+0x6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:338
    }
    Error = true;
 8002262:	2301      	movs	r3, #1
 8002264:	7423      	strb	r3, [r4, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:339
    return TIMEOUT;
 8002266:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:340
}
 8002268:	bd38      	pop	{r3, r4, r5, pc}
 800226a:	0000      	movs	r0, r0
 800226c:	0000      	movs	r0, r0
	...

08002270 <i2c_t::WaitEv5()>:
_ZN5i2c_t7WaitEv5Ev():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:345

// BUSY, MSL & SB flags
uint8_t i2c_t::WaitEv5() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--) {
 8002270:	f240 13c3 	movw	r3, #451	; 0x1c3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:345 (discriminator 1)
 8002274:	3b01      	subs	r3, #1
 8002276:	d009      	beq.n	800228c <i2c_t::WaitEv5()+0x1c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:346
        uint16_t Flag1 = ii2c->SR1;
 8002278:	6802      	ldr	r2, [r0, #0]
 800227a:	8a91      	ldrh	r1, [r2, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:347
        uint16_t Flag2 = ii2c->SR2;
 800227c:	8b12      	ldrh	r2, [r2, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348
        if((Flag1 & I2C_SR1_SB) and (Flag2 & (I2C_SR2_MSL | I2C_SR2_BUSY))) return OK;
 800227e:	07c9      	lsls	r1, r1, #31
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:347
// BUSY, MSL & SB flags
uint8_t i2c_t::WaitEv5() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--) {
        uint16_t Flag1 = ii2c->SR1;
        uint16_t Flag2 = ii2c->SR2;
 8002280:	b292      	uxth	r2, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348
        if((Flag1 & I2C_SR1_SB) and (Flag2 & (I2C_SR2_MSL | I2C_SR2_BUSY))) return OK;
 8002282:	d5f7      	bpl.n	8002274 <i2c_t::WaitEv5()+0x4>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348 (discriminator 1)
 8002284:	0792      	lsls	r2, r2, #30
 8002286:	d0f5      	beq.n	8002274 <i2c_t::WaitEv5()+0x4>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:348
 8002288:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:352
    }
    Error = true;
    return FAILURE;
}
 800228a:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:350
    while(RetryCnt--) {
        uint16_t Flag1 = ii2c->SR1;
        uint16_t Flag2 = ii2c->SR2;
        if((Flag1 & I2C_SR1_SB) and (Flag2 & (I2C_SR2_MSL | I2C_SR2_BUSY))) return OK;
    }
    Error = true;
 800228c:	2301      	movs	r3, #1
 800228e:	7403      	strb	r3, [r0, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:351
    return FAILURE;
 8002290:	4618      	mov	r0, r3
 8002292:	4770      	bx	lr
	...

080022a0 <i2c_t::WaitEv6()>:
_ZN5i2c_t7WaitEv6Ev():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:358

uint8_t i2c_t::WaitEv6() {
    uint32_t RetryCnt = 45;
    uint16_t Flag1;
    do {
        Flag1 = ii2c->SR1;
 80022a0:	6801      	ldr	r1, [r0, #0]
 80022a2:	232e      	movs	r3, #46	; 0x2e
 80022a4:	8a8a      	ldrh	r2, [r1, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359
        if((RetryCnt-- == 0) or (Flag1 & I2C_SR1_AF)) return FAILURE;   // Fail if timeout or NACK
 80022a6:	3b01      	subs	r3, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:358

uint8_t i2c_t::WaitEv6() {
    uint32_t RetryCnt = 45;
    uint16_t Flag1;
    do {
        Flag1 = ii2c->SR1;
 80022a8:	b292      	uxth	r2, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359
        if((RetryCnt-- == 0) or (Flag1 & I2C_SR1_AF)) return FAILURE;   // Fail if timeout or NACK
 80022aa:	d003      	beq.n	80022b4 <i2c_t::WaitEv6()+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359 (discriminator 2)
 80022ac:	f402 6080 	and.w	r0, r2, #1024	; 0x400
 80022b0:	b280      	uxth	r0, r0
 80022b2:	b108      	cbz	r0, 80022b8 <i2c_t::WaitEv6()+0x18>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:359
 80022b4:	2001      	movs	r0, #1
 80022b6:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:357
}

uint8_t i2c_t::WaitEv6() {
    uint32_t RetryCnt = 45;
    uint16_t Flag1;
    do {
 80022b8:	0792      	lsls	r2, r2, #30
 80022ba:	d5f3      	bpl.n	80022a4 <i2c_t::WaitEv6()+0x4>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:362
        Flag1 = ii2c->SR1;
        if((RetryCnt-- == 0) or (Flag1 & I2C_SR1_AF)) return FAILURE;   // Fail if timeout or NACK
    } while(!(Flag1 & I2C_SR1_ADDR)); // ADDR set when Address is sent and ACK received
    return OK;
}
 80022bc:	4770      	bx	lr
	...

080022c0 <i2c_t::WaitEv8()>:
_ZN5i2c_t7WaitEv8Ev():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:366

uint8_t i2c_t::WaitEv8() {
    uint32_t RetryCnt = 45;
    while(RetryCnt--)
 80022c0:	232e      	movs	r3, #46	; 0x2e
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:366 (discriminator 1)
 80022c2:	3b01      	subs	r3, #1
 80022c4:	d005      	beq.n	80022d2 <i2c_t::WaitEv8()+0x12>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:367
        if(ii2c->SR1 & I2C_SR1_TXE) return OK;
 80022c6:	6802      	ldr	r2, [r0, #0]
 80022c8:	8a92      	ldrh	r2, [r2, #20]
 80022ca:	0612      	lsls	r2, r2, #24
 80022cc:	d5f9      	bpl.n	80022c2 <i2c_t::WaitEv8()+0x2>
 80022ce:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:370
    Error = true;
    return TIMEOUT;
}
 80022d0:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:368

uint8_t i2c_t::WaitEv8() {
    uint32_t RetryCnt = 45;
    while(RetryCnt--)
        if(ii2c->SR1 & I2C_SR1_TXE) return OK;
    Error = true;
 80022d2:	2301      	movs	r3, #1
 80022d4:	7403      	strb	r3, [r0, #16]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:369
    return TIMEOUT;
 80022d6:	2002      	movs	r0, #2
 80022d8:	4770      	bx	lr
 80022da:	0000      	movs	r0, r0
 80022dc:	0000      	movs	r0, r0
	...

080022e0 <i2c_t::WaitBTF()>:
_ZN5i2c_t7WaitBTFEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:388
    return TIMEOUT;
}

uint8_t i2c_t::WaitBTF() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--)
 80022e0:	f240 13c3 	movw	r3, #451	; 0x1c3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:388 (discriminator 1)
 80022e4:	3b01      	subs	r3, #1
 80022e6:	d005      	beq.n	80022f4 <i2c_t::WaitBTF()+0x14>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:389
        if(ii2c->SR1 & I2C_SR1_BTF) return OK;
 80022e8:	6802      	ldr	r2, [r0, #0]
 80022ea:	8a92      	ldrh	r2, [r2, #20]
 80022ec:	0752      	lsls	r2, r2, #29
 80022ee:	d5f9      	bpl.n	80022e4 <i2c_t::WaitBTF()+0x4>
 80022f0:	2000      	movs	r0, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:391
    return TIMEOUT;
}
 80022f2:	4770      	bx	lr
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:390

uint8_t i2c_t::WaitBTF() {
    uint32_t RetryCnt = 450;
    while(RetryCnt--)
        if(ii2c->SR1 & I2C_SR1_BTF) return OK;
    return TIMEOUT;
 80022f4:	2002      	movs	r0, #2
 80022f6:	4770      	bx	lr
	...

08002300 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>:
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8002300:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002304:	4604      	mov	r4, r0
 8002306:	460f      	mov	r7, r1
 8002308:	4691      	mov	r9, r2
 800230a:	4698      	mov	r8, r3
 800230c:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:234
    if(IBusyWait() != OK) return FAILURE;
 8002310:	f7ff ff96 	bl	8002240 <i2c_t::IBusyWait()>
 8002314:	2800      	cmp	r0, #0
 8002316:	d174      	bne.n	8002402 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:236
    // Clear flags
    ii2c->SR1 = 0;
 8002318:	6825      	ldr	r5, [r4, #0]
 800231a:	82a8      	strh	r0, [r5, #20]
_ZN5i2c_t12RxIsNotEmptyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:459 (discriminator 1)
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
 800231c:	8aab      	ldrh	r3, [r5, #20]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:237 (discriminator 1)
    while(RxIsNotEmpty()) (void)ii2c->DR;   // Read DR until it empty
 800231e:	065b      	lsls	r3, r3, #25
 8002320:	d501      	bpl.n	8002326 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x26>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:237 (discriminator 2)
 8002322:	8a2b      	ldrh	r3, [r5, #16]
 8002324:	e7fa      	b.n	800231c <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x1c>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 8002326:	8aab      	ldrh	r3, [r5, #20]
 8002328:	8b2b      	ldrh	r3, [r5, #24]
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
private:
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
 800232a:	882b      	ldrh	r3, [r5, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:241
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
 800232c:	4620      	mov	r0, r4
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
 800232e:	b29b      	uxth	r3, r3
 8002330:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002334:	802b      	strh	r3, [r5, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:241
 8002336:	f7ff ff9b 	bl	8002270 <i2c_t::WaitEv5()>
 800233a:	2800      	cmp	r0, #0
 800233c:	d161      	bne.n	8002402 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 800233e:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t17SendAddrWithWriteEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:463
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
    // Address and data
    void SendAddrWithWrite(uint8_t Addr) { ii2c->DR = (uint8_t)(Addr<<1); }
 8002340:	007f      	lsls	r7, r7, #1
 8002342:	b2ff      	uxtb	r7, r7
 8002344:	821f      	strh	r7, [r3, #16]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:243
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
    SendAddrWithWrite(Addr);
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
 8002346:	4620      	mov	r0, r4
 8002348:	f7ff ffaa 	bl	80022a0 <i2c_t::WaitEv6()>
 800234c:	4605      	mov	r5, r0
 800234e:	6820      	ldr	r0, [r4, #0]
 8002350:	b12d      	cbz	r5, 800235e <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456 (discriminator 1)
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 8002352:	8803      	ldrh	r3, [r0, #0]
 8002354:	b29b      	uxth	r3, r3
 8002356:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800235a:	8003      	strh	r3, [r0, #0]
 800235c:	e051      	b.n	8002402 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 800235e:	8a83      	ldrh	r3, [r0, #20]
 8002360:	8b03      	ldrh	r3, [r0, #24]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:246
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength != 0) {
 8002362:	f1b8 0f00 	cmp.w	r8, #0
 8002366:	d02e      	beq.n	80023c6 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0xc6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:247
        if(WaitEv8() != OK) return FAILURE;
 8002368:	4620      	mov	r0, r4
 800236a:	f7ff ffa9 	bl	80022c0 <i2c_t::WaitEv8()>
 800236e:	2800      	cmp	r0, #0
 8002370:	d147      	bne.n	8002402 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:248
        dmaStreamSetMemory0(PDmaTx, WPtr);
 8002372:	69a3      	ldr	r3, [r4, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:249
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 8002374:	2292      	movs	r2, #146	; 0x92
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:248
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength != 0) {
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr);
 8002376:	681b      	ldr	r3, [r3, #0]
 8002378:	f8c3 900c 	str.w	r9, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:249
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 800237c:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:250
        dmaStreamSetTransactionSize(PDmaTx, WLength);
 800237e:	f8c3 8004 	str.w	r8, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:251
        chSysLock();
 8002382:	2320      	movs	r3, #32
 8002384:	f383 8811 	msr	BASEPRI, r3
 8002388:	f7fe fd2a 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:252
        PRequestingThread = chThdSelf();
 800238c:	4b41      	ldr	r3, [pc, #260]	; (8002494 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x194>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:254
        dmaStreamEnable(PDmaTx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 800238e:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:252
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr);
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
        dmaStreamSetTransactionSize(PDmaTx, WLength);
        chSysLock();
        PRequestingThread = chThdSelf();
 8002390:	699b      	ldr	r3, [r3, #24]
 8002392:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:253
        dmaStreamEnable(PDmaTx);
 8002394:	69a3      	ldr	r3, [r4, #24]
 8002396:	681b      	ldr	r3, [r3, #0]
 8002398:	681a      	ldr	r2, [r3, #0]
 800239a:	f042 0201 	orr.w	r2, r2, #1
 800239e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:254
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 80023a0:	f7fe febe 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:255
        chSysUnlock();
 80023a4:	f7fe fd34 	bl	8000e10 <dbg_check_unlock>
 80023a8:	2300      	movs	r3, #0
 80023aa:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:256
        dmaStreamDisable(PDmaTx);
 80023ae:	69a3      	ldr	r3, [r4, #24]
 80023b0:	681a      	ldr	r2, [r3, #0]
 80023b2:	6811      	ldr	r1, [r2, #0]
 80023b4:	f021 010f 	bic.w	r1, r1, #15
 80023b8:	6011      	str	r1, [r2, #0]
 80023ba:	685a      	ldr	r2, [r3, #4]
 80023bc:	7a1b      	ldrb	r3, [r3, #8]
 80023be:	210f      	movs	r1, #15
 80023c0:	fa01 f303 	lsl.w	r3, r1, r3
 80023c4:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:260
    }
    // Read if needed
    if(RLength != 0) {
        if(WaitEv8() != OK) return FAILURE;
 80023c6:	4620      	mov	r0, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:259
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
        chSysUnlock();
        dmaStreamDisable(PDmaTx);
    }
    // Read if needed
    if(RLength != 0) {
 80023c8:	2e00      	cmp	r6, #0
 80023ca:	d058      	beq.n	800247e <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x17e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:260
        if(WaitEv8() != OK) return FAILURE;
 80023cc:	f7ff ff78 	bl	80022c0 <i2c_t::WaitEv8()>
 80023d0:	b9b8      	cbnz	r0, 8002402 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 80023d2:	6823      	ldr	r3, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:263
    // Read if needed
    if(RLength != 0) {
        if(WaitEv8() != OK) return FAILURE;
        // Send repeated start
        SendStart();
        if(WaitEv5() != OK) return FAILURE;
 80023d4:	4620      	mov	r0, r4
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
private:
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
 80023d6:	881a      	ldrh	r2, [r3, #0]
 80023d8:	b292      	uxth	r2, r2
 80023da:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80023de:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:263
 80023e0:	f7ff ff46 	bl	8002270 <i2c_t::WaitEv5()>
 80023e4:	b968      	cbnz	r0, 8002402 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x102>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 80023e6:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t16SendAddrWithReadEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:464
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
    // Address and data
    void SendAddrWithWrite(uint8_t Addr) { ii2c->DR = (uint8_t)(Addr<<1); }
    void SendAddrWithRead (uint8_t Addr) { ii2c->DR = ((uint8_t)(Addr<<1)) | 0x01; }
 80023e8:	f047 0701 	orr.w	r7, r7, #1
 80023ec:	821f      	strh	r7, [r3, #16]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:265
        if(WaitEv8() != OK) return FAILURE;
        // Send repeated start
        SendStart();
        if(WaitEv5() != OK) return FAILURE;
        SendAddrWithRead(Addr);
        if(WaitEv6() != OK) { SendStop(); return FAILURE; }
 80023ee:	4620      	mov	r0, r4
 80023f0:	f7ff ff56 	bl	80022a0 <i2c_t::WaitEv6()>
 80023f4:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 80023f6:	881a      	ldrh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:265
 80023f8:	b128      	cbz	r0, 8002406 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x106>
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456 (discriminator 1)
 80023fa:	b292      	uxth	r2, r2
 80023fc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002400:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:265 (discriminator 1)
 8002402:	2501      	movs	r5, #1
 8002404:	e043      	b.n	800248e <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x18e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:267
        // If single byte is to be received, disable ACK before clearing ADDR flag
        if(RLength == 1) AckDisable();
 8002406:	2e01      	cmp	r6, #1
 8002408:	d104      	bne.n	8002414 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x114>
_ZN5i2c_t10AckDisableEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:458 (discriminator 1)
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
 800240a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800240e:	0412      	lsls	r2, r2, #16
 8002410:	0c12      	lsrs	r2, r2, #16
 8002412:	e002      	b.n	800241a <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x11a>
_ZN5i2c_t9AckEnableEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:457
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
 8002414:	b292      	uxth	r2, r2
 8002416:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800241a:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 800241c:	8a9a      	ldrh	r2, [r3, #20]
 800241e:	8b1a      	ldrh	r2, [r3, #24]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:270
        else AckEnable();
        ClearAddrFlag();
        dmaStreamSetMemory0(PDmaRx, RPtr);
 8002420:	69e2      	ldr	r2, [r4, #28]
 8002422:	9908      	ldr	r1, [sp, #32]
 8002424:	6812      	ldr	r2, [r2, #0]
 8002426:	60d1      	str	r1, [r2, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:271
        dmaStreamSetMode   (PDmaRx, I2C_DMARX_MODE);
 8002428:	2182      	movs	r1, #130	; 0x82
 800242a:	6011      	str	r1, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:272
        dmaStreamSetTransactionSize(PDmaRx, RLength);
 800242c:	6056      	str	r6, [r2, #4]
_ZN5i2c_t18DmaLastTransferSetEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:461
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
 800242e:	889a      	ldrh	r2, [r3, #4]
 8002430:	b292      	uxth	r2, r2
 8002432:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002436:	809a      	strh	r2, [r3, #4]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:274
        DmaLastTransferSet(); // Inform DMA that this is last transfer => do not ACK last byte
        chSysLock();
 8002438:	2320      	movs	r3, #32
 800243a:	f383 8811 	msr	BASEPRI, r3
 800243e:	f7fe fccf 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:275
        PRequestingThread = chThdSelf();
 8002442:	4b14      	ldr	r3, [pc, #80]	; (8002494 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x194>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:277
        dmaStreamEnable(PDmaRx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 8002444:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:275
        dmaStreamSetMemory0(PDmaRx, RPtr);
        dmaStreamSetMode   (PDmaRx, I2C_DMARX_MODE);
        dmaStreamSetTransactionSize(PDmaRx, RLength);
        DmaLastTransferSet(); // Inform DMA that this is last transfer => do not ACK last byte
        chSysLock();
        PRequestingThread = chThdSelf();
 8002446:	699b      	ldr	r3, [r3, #24]
 8002448:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:276
        dmaStreamEnable(PDmaRx);
 800244a:	69e3      	ldr	r3, [r4, #28]
 800244c:	681b      	ldr	r3, [r3, #0]
 800244e:	681a      	ldr	r2, [r3, #0]
 8002450:	f042 0201 	orr.w	r2, r2, #1
 8002454:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:277
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 8002456:	f7fe fe63 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:278
        chSysUnlock();
 800245a:	f7fe fcd9 	bl	8000e10 <dbg_check_unlock>
 800245e:	2300      	movs	r3, #0
 8002460:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:279
        dmaStreamDisable(PDmaRx);
 8002464:	69e3      	ldr	r3, [r4, #28]
 8002466:	681a      	ldr	r2, [r3, #0]
 8002468:	6811      	ldr	r1, [r2, #0]
 800246a:	f021 010f 	bic.w	r1, r1, #15
 800246e:	6011      	str	r1, [r2, #0]
 8002470:	685a      	ldr	r2, [r3, #4]
 8002472:	7a1b      	ldrb	r3, [r3, #8]
 8002474:	210f      	movs	r1, #15
 8002476:	fa01 f303 	lsl.w	r3, r1, r3
 800247a:	6013      	str	r3, [r2, #0]
 800247c:	e001      	b.n	8002482 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x182>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:281
    } // if != 0
    else WaitBTF(); // if nothing to read, just stop
 800247e:	f7ff ff2f 	bl	80022e0 <i2c_t::WaitBTF()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:233
    Resume();
}

uint8_t i2c_t::CmdWriteRead(uint8_t Addr,
        uint8_t *WPtr, uint8_t WLength,
        uint8_t *RPtr, uint8_t RLength) {
 8002482:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 8002484:	881a      	ldrh	r2, [r3, #0]
 8002486:	b292      	uxth	r2, r2
 8002488:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800248c:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t12CmdWriteReadEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:284
        dmaStreamDisable(PDmaRx);
    } // if != 0
    else WaitBTF(); // if nothing to read, just stop
    SendStop();
    return OK;
}
 800248e:	4628      	mov	r0, r5
 8002490:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002494:	200012ac 	.word	0x200012ac
	...

080024a0 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>:
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:288

uint8_t i2c_t::CmdWriteWrite(uint8_t Addr,
        uint8_t *WPtr1, uint8_t WLength1,
        uint8_t *WPtr2, uint8_t WLength2) {
 80024a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80024a4:	4604      	mov	r4, r0
 80024a6:	4689      	mov	r9, r1
 80024a8:	4690      	mov	r8, r2
 80024aa:	461f      	mov	r7, r3
 80024ac:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:289
    if(IBusyWait() != OK) return FAILURE;
 80024b0:	f7ff fec6 	bl	8002240 <i2c_t::IBusyWait()>
 80024b4:	bb18      	cbnz	r0, 80024fe <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:291
    // Clear flags
    ii2c->SR1 = 0;
 80024b6:	6825      	ldr	r5, [r4, #0]
 80024b8:	82a8      	strh	r0, [r5, #20]
_ZN5i2c_t12RxIsNotEmptyEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:459 (discriminator 1)
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
 80024ba:	8aab      	ldrh	r3, [r5, #20]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:292 (discriminator 1)
    while(RxIsNotEmpty()) (void)ii2c->DR;   // Read DR until it empty
 80024bc:	065b      	lsls	r3, r3, #25
 80024be:	d501      	bpl.n	80024c4 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x24>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:292 (discriminator 2)
 80024c0:	8a2b      	ldrh	r3, [r5, #16]
 80024c2:	e7fa      	b.n	80024ba <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x1a>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 80024c4:	8aab      	ldrh	r3, [r5, #20]
 80024c6:	8b2b      	ldrh	r3, [r5, #24]
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
private:
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
 80024c8:	882b      	ldrh	r3, [r5, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:296
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
 80024ca:	4620      	mov	r0, r4
_ZN5i2c_t9SendStartEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:455
 80024cc:	b29b      	uxth	r3, r3
 80024ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80024d2:	802b      	strh	r3, [r5, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:296
 80024d4:	f7ff fecc 	bl	8002270 <i2c_t::WaitEv5()>
 80024d8:	b988      	cbnz	r0, 80024fe <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:288
    return OK;
}

uint8_t i2c_t::CmdWriteWrite(uint8_t Addr,
        uint8_t *WPtr1, uint8_t WLength1,
        uint8_t *WPtr2, uint8_t WLength2) {
 80024da:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t17SendAddrWithWriteEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:463
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
    void DmaLastTransferSet() { ii2c->CR2 |= I2C_CR2_LAST; }
    // Address and data
    void SendAddrWithWrite(uint8_t Addr) { ii2c->DR = (uint8_t)(Addr<<1); }
 80024dc:	ea4f 0949 	mov.w	r9, r9, lsl #1
 80024e0:	f009 09fe 	and.w	r9, r9, #254	; 0xfe
 80024e4:	f8a3 9010 	strh.w	r9, [r3, #16]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:298
    ClearAddrFlag();
    // Start transmission
    SendStart();
    if(WaitEv5() != OK) return FAILURE;
    SendAddrWithWrite(Addr);
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
 80024e8:	4620      	mov	r0, r4
 80024ea:	f7ff fed9 	bl	80022a0 <i2c_t::WaitEv6()>
 80024ee:	6821      	ldr	r1, [r4, #0]
 80024f0:	4605      	mov	r5, r0
 80024f2:	b130      	cbz	r0, 8002502 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x62>
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456 (discriminator 1)
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 80024f4:	880b      	ldrh	r3, [r1, #0]
 80024f6:	b29b      	uxth	r3, r3
 80024f8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80024fc:	800b      	strh	r3, [r1, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:298 (discriminator 1)
 80024fe:	2501      	movs	r5, #1
 8002500:	e06a      	b.n	80025d8 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x138>
_ZN5i2c_t13ClearAddrFlagEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:460
    void AckEnable()     { ii2c->CR1 |= I2C_CR1_ACK; }
    void AckDisable()    { ii2c->CR1 &= ~I2C_CR1_ACK; }
    bool RxIsNotEmpty()  { return (ii2c->SR1 & I2C_SR1_RXNE); }
    void ClearAddrFlag() { (void)ii2c->SR1; (void)ii2c->SR2; }
 8002502:	8a8b      	ldrh	r3, [r1, #20]
 8002504:	8b0b      	ldrh	r3, [r1, #24]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:301
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength1 != 0) {
 8002506:	2f00      	cmp	r7, #0
 8002508:	d02d      	beq.n	8002566 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0xc6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:302
        if(WaitEv8() != OK) return FAILURE;
 800250a:	4620      	mov	r0, r4
 800250c:	f7ff fed8 	bl	80022c0 <i2c_t::WaitEv8()>
 8002510:	2800      	cmp	r0, #0
 8002512:	d1f4      	bne.n	80024fe <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:303
        dmaStreamSetMemory0(PDmaTx, WPtr1);
 8002514:	69a3      	ldr	r3, [r4, #24]
 8002516:	6819      	ldr	r1, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:304
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 8002518:	2392      	movs	r3, #146	; 0x92
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:303
    if(WaitEv6() != OK) { SendStop(); return FAILURE; }
    ClearAddrFlag();
    // Start TX DMA if needed
    if(WLength1 != 0) {
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr1);
 800251a:	f8c1 800c 	str.w	r8, [r1, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:304
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 800251e:	600b      	str	r3, [r1, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:305
        dmaStreamSetTransactionSize(PDmaTx, WLength1);
 8002520:	604f      	str	r7, [r1, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:306
        chSysLock();
 8002522:	2320      	movs	r3, #32
 8002524:	f383 8811 	msr	BASEPRI, r3
 8002528:	f7fe fc5a 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:307
        PRequestingThread = chThdSelf();
 800252c:	4b2c      	ldr	r3, [pc, #176]	; (80025e0 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x140>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:309
        dmaStreamEnable(PDmaTx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 800252e:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:307
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr1);
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
        dmaStreamSetTransactionSize(PDmaTx, WLength1);
        chSysLock();
        PRequestingThread = chThdSelf();
 8002530:	699b      	ldr	r3, [r3, #24]
 8002532:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:308
        dmaStreamEnable(PDmaTx);
 8002534:	69a3      	ldr	r3, [r4, #24]
 8002536:	681b      	ldr	r3, [r3, #0]
 8002538:	681a      	ldr	r2, [r3, #0]
 800253a:	f042 0201 	orr.w	r2, r2, #1
 800253e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:309
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 8002540:	f7fe fdee 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:310
        chSysUnlock();
 8002544:	f7fe fc64 	bl	8000e10 <dbg_check_unlock>
 8002548:	2300      	movs	r3, #0
 800254a:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:311
        dmaStreamDisable(PDmaTx);
 800254e:	69a3      	ldr	r3, [r4, #24]
 8002550:	681a      	ldr	r2, [r3, #0]
 8002552:	6811      	ldr	r1, [r2, #0]
 8002554:	f021 010f 	bic.w	r1, r1, #15
 8002558:	6011      	str	r1, [r2, #0]
 800255a:	685a      	ldr	r2, [r3, #4]
 800255c:	7a1b      	ldrb	r3, [r3, #8]
 800255e:	210f      	movs	r1, #15
 8002560:	fa01 f303 	lsl.w	r3, r1, r3
 8002564:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:313
    }
    if(WLength2 != 0) {
 8002566:	2e00      	cmp	r6, #0
 8002568:	d02d      	beq.n	80025c6 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x126>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:314
        if(WaitEv8() != OK) return FAILURE;
 800256a:	4620      	mov	r0, r4
 800256c:	f7ff fea8 	bl	80022c0 <i2c_t::WaitEv8()>
 8002570:	2800      	cmp	r0, #0
 8002572:	d1c4      	bne.n	80024fe <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:315
        dmaStreamSetMemory0(PDmaTx, WPtr2);
 8002574:	69a3      	ldr	r3, [r4, #24]
 8002576:	9a08      	ldr	r2, [sp, #32]
 8002578:	681b      	ldr	r3, [r3, #0]
 800257a:	60da      	str	r2, [r3, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:316
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
 800257c:	2292      	movs	r2, #146	; 0x92
 800257e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:317
        dmaStreamSetTransactionSize(PDmaTx, WLength2);
 8002580:	605e      	str	r6, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:318
        chSysLock();
 8002582:	2320      	movs	r3, #32
 8002584:	f383 8811 	msr	BASEPRI, r3
 8002588:	f7fe fc2a 	bl	8000de0 <dbg_check_lock>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:319
        PRequestingThread = chThdSelf();
 800258c:	4b14      	ldr	r3, [pc, #80]	; (80025e0 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)+0x140>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:321
        dmaStreamEnable(PDmaTx);
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 800258e:	2002      	movs	r0, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:319
        if(WaitEv8() != OK) return FAILURE;
        dmaStreamSetMemory0(PDmaTx, WPtr2);
        dmaStreamSetMode   (PDmaTx, I2C_DMATX_MODE);
        dmaStreamSetTransactionSize(PDmaTx, WLength2);
        chSysLock();
        PRequestingThread = chThdSelf();
 8002590:	699b      	ldr	r3, [r3, #24]
 8002592:	6163      	str	r3, [r4, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:320
        dmaStreamEnable(PDmaTx);
 8002594:	69a3      	ldr	r3, [r4, #24]
 8002596:	681b      	ldr	r3, [r3, #0]
 8002598:	681a      	ldr	r2, [r3, #0]
 800259a:	f042 0201 	orr.w	r2, r2, #1
 800259e:	601a      	str	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:321
        chSchGoSleepS(THD_STATE_SUSPENDED); // Sleep until end
 80025a0:	f7fe fdbe 	bl	8001120 <chSchGoSleepS>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:322
        chSysUnlock();
 80025a4:	f7fe fc34 	bl	8000e10 <dbg_check_unlock>
 80025a8:	2300      	movs	r3, #0
 80025aa:	f383 8811 	msr	BASEPRI, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:323
        dmaStreamDisable(PDmaTx);
 80025ae:	69a3      	ldr	r3, [r4, #24]
 80025b0:	681a      	ldr	r2, [r3, #0]
 80025b2:	6811      	ldr	r1, [r2, #0]
 80025b4:	f021 010f 	bic.w	r1, r1, #15
 80025b8:	6011      	str	r1, [r2, #0]
 80025ba:	685a      	ldr	r2, [r3, #4]
 80025bc:	7a1b      	ldrb	r3, [r3, #8]
 80025be:	210f      	movs	r1, #15
 80025c0:	fa01 f303 	lsl.w	r3, r1, r3
 80025c4:	6013      	str	r3, [r2, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:325
    }
    WaitBTF();
 80025c6:	4620      	mov	r0, r4
 80025c8:	f7ff fe8a 	bl	80022e0 <i2c_t::WaitBTF()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:288
    return OK;
}

uint8_t i2c_t::CmdWriteWrite(uint8_t Addr,
        uint8_t *WPtr1, uint8_t WLength1,
        uint8_t *WPtr2, uint8_t WLength2) {
 80025cc:	6823      	ldr	r3, [r4, #0]
_ZN5i2c_t8SendStopEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.h:456
    I2C_TypeDef *ii2c;
    GPIO_TypeDef *IPGpio;
    uint16_t ISclPin, ISdaPin;
    uint32_t IBitrateHz;
    void SendStart()     { ii2c->CR1 |= I2C_CR1_START; }
    void SendStop()      { ii2c->CR1 |= I2C_CR1_STOP; }
 80025ce:	881a      	ldrh	r2, [r3, #0]
 80025d0:	b292      	uxth	r2, r2
 80025d2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80025d6:	801a      	strh	r2, [r3, #0]
_ZN5i2c_t13CmdWriteWriteEhPhhS0_h():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_lib_L15x.cpp:328
        dmaStreamDisable(PDmaTx);
    }
    WaitBTF();
    SendStop();
    return OK;
}
 80025d8:	4628      	mov	r0, r5
 80025da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80025de:	bf00      	nop
 80025e0:	200012ac 	.word	0x200012ac
	...

080025f0 <IPutUint.4105>:
IPutUint():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:11
    uint32_t CharCnt = 0, width = 0;
    bool zero_padded = false;
    // Print number n to buffer p in base base. If number is shorter
    // than width, it's prepended with spaces or zeros (if zero_padded
    // is set) from the left.
    void IPutUint(uint32_t n, uint32_t base) {
 80025f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025f2:	4664      	mov	r4, ip
 80025f4:	b085      	sub	sp, #20
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:13
        char digits[10];
        uint32_t len = 0;
 80025f6:	2500      	movs	r5, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:16
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
 80025f8:	fbb0 f3f1 	udiv	r3, r0, r1
 80025fc:	fb01 0213 	mls	r2, r1, r3, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:18
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 8002600:	2a09      	cmp	r2, #9
 8002602:	f105 0501 	add.w	r5, r5, #1
 8002606:	bf94      	ite	ls
 8002608:	3230      	addls	r2, #48	; 0x30
 800260a:	3237      	addhi	r2, #55	; 0x37
 800260c:	ae01      	add	r6, sp, #4
 800260e:	b2d2      	uxtb	r2, r2
 8002610:	1977      	adds	r7, r6, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:17
        char digits[10];
        uint32_t len = 0;
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
            n /= base;
 8002612:	4618      	mov	r0, r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:18
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 8002614:	f807 2c01 	strb.w	r2, [r7, #-1]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:19
        } while(n > 0);
 8002618:	2b00      	cmp	r3, #0
 800261a:	d1ed      	bne.n	80025f8 <IPutUint.4105+0x8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:18
        uint32_t len = 0;
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 800261c:	462f      	mov	r7, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:21 (discriminator 1)
        } while(n > 0);
        // Add padding
        for(uint32_t i = len; i < width; i++) {
 800261e:	6823      	ldr	r3, [r4, #0]
 8002620:	429d      	cmp	r5, r3
 8002622:	d20e      	bcs.n	8002642 <IPutUint.4105+0x52>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:22
            if(zero_padded) PPutChar('0');
 8002624:	7c22      	ldrb	r2, [r4, #16]
 8002626:	68e3      	ldr	r3, [r4, #12]
 8002628:	b10a      	cbz	r2, 800262e <IPutUint.4105+0x3e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:22 (discriminator 1)
 800262a:	2030      	movs	r0, #48	; 0x30
 800262c:	e000      	b.n	8002630 <IPutUint.4105+0x40>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:23
            else            PPutChar(' ');
 800262e:	2020      	movs	r0, #32
 8002630:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:24
            if(++CharCnt >= MaxLength) return;
 8002632:	68a3      	ldr	r3, [r4, #8]
 8002634:	6862      	ldr	r2, [r4, #4]
 8002636:	3301      	adds	r3, #1
 8002638:	4293      	cmp	r3, r2
 800263a:	60a3      	str	r3, [r4, #8]
 800263c:	d20f      	bcs.n	800265e <IPutUint.4105+0x6e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:21
            uint32_t digit = n % base;
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
        } while(n > 0);
        // Add padding
        for(uint32_t i = len; i < width; i++) {
 800263e:	3501      	adds	r5, #1
 8002640:	e7ed      	b.n	800261e <IPutUint.4105+0x2e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:27
            if(zero_padded) PPutChar('0');
            else            PPutChar(' ');
            if(++CharCnt >= MaxLength) return;
        }
        // Print digits
        len = (len < (MaxLength - CharCnt))? len : (MaxLength - CharCnt);
 8002642:	68a3      	ldr	r3, [r4, #8]
 8002644:	6865      	ldr	r5, [r4, #4]
 8002646:	1aed      	subs	r5, r5, r3
 8002648:	42af      	cmp	r7, r5
 800264a:	bf38      	it	cc
 800264c:	463d      	movcc	r5, r7
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:28
        CharCnt += len;
 800264e:	442b      	add	r3, r5
 8002650:	60a3      	str	r3, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:29 (discriminator 1)
        while(len > 0) PPutChar(digits[--len]);
 8002652:	b125      	cbz	r5, 800265e <IPutUint.4105+0x6e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:29 (discriminator 2)
 8002654:	3d01      	subs	r5, #1
 8002656:	68e3      	ldr	r3, [r4, #12]
 8002658:	5d70      	ldrb	r0, [r6, r5]
 800265a:	4798      	blx	r3
 800265c:	e7f9      	b.n	8002652 <IPutUint.4105+0x62>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:30
    } // IPutUint
 800265e:	b005      	add	sp, #20
 8002660:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08002670 <kl_vsprintf>:
kl_vsprintf():
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:5
#include "kl_sprintf.h"
#include <stdint.h>
#include <stdbool.h>

uint32_t kl_vsprintf(ftVoidChar PPutChar, uint32_t MaxLength, const char *format, va_list args) {
 8002670:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002674:	461c      	mov	r4, r3
 8002676:	b087      	sub	sp, #28
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:6
    uint32_t CharCnt = 0, width = 0;
 8002678:	2300      	movs	r3, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:5
#include "kl_sprintf.h"
#include <stdint.h>
#include <stdbool.h>

uint32_t kl_vsprintf(ftVoidChar PPutChar, uint32_t MaxLength, const char *format, va_list args) {
 800267a:	9004      	str	r0, [sp, #16]
 800267c:	9102      	str	r1, [sp, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:6
    uint32_t CharCnt = 0, width = 0;
 800267e:	9303      	str	r3, [sp, #12]
 8002680:	9301      	str	r3, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:7
    bool zero_padded = false;
 8002682:	f88d 3014 	strb.w	r3, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:34 (discriminator 1)
        while(len > 0) PPutChar(digits[--len]);
    } // IPutUint

    const char *f = format;
    char c;
    while((c = *f++) != 0) {
 8002686:	7810      	ldrb	r0, [r2, #0]
 8002688:	1c56      	adds	r6, r2, #1
 800268a:	b150      	cbz	r0, 80026a2 <kl_vsprintf+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:35
        if(c != '%') {
 800268c:	2825      	cmp	r0, #37	; 0x25
 800268e:	d00c      	beq.n	80026aa <kl_vsprintf+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:36
            PPutChar(c);
 8002690:	9b04      	ldr	r3, [sp, #16]
 8002692:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:37
            if(++CharCnt >= MaxLength) break;
 8002694:	9b03      	ldr	r3, [sp, #12]
 8002696:	9a02      	ldr	r2, [sp, #8]
 8002698:	3301      	adds	r3, #1
 800269a:	4293      	cmp	r3, r2
 800269c:	9303      	str	r3, [sp, #12]
 800269e:	f0c0 8095 	bcc.w	80027cc <kl_vsprintf+0x15c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:89
                if(CharCnt >= MaxLength) break;
            }
        }
        if(CharCnt >= MaxLength) break;
    }
    return CharCnt;
 80026a2:	9803      	ldr	r0, [sp, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:90
}
 80026a4:	b007      	add	sp, #28
 80026a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:43
            else continue;
        }

        // Here goes optional width specification.
        // If it starts with zero (zero_padded is true), it means we use '0' instead of ' ' as a filler.
        width = 0;
 80026aa:	2200      	movs	r2, #0
 80026ac:	9201      	str	r2, [sp, #4]
 80026ae:	4611      	mov	r1, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:46
        zero_padded = false;
        while(true) {
            c = *f++;
 80026b0:	f816 3b01 	ldrb.w	r3, [r6], #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:47
            if(c < '0' || c > '9') break;
 80026b4:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 80026b8:	b2c5      	uxtb	r5, r0
 80026ba:	2d09      	cmp	r5, #9
 80026bc:	d807      	bhi.n	80026ce <kl_vsprintf+0x5e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:48
            if((width == 0) && (c == '0')) zero_padded = true;
 80026be:	b912      	cbnz	r2, 80026c6 <kl_vsprintf+0x56>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:48 (discriminator 1)
 80026c0:	2b30      	cmp	r3, #48	; 0x30
 80026c2:	bf08      	it	eq
 80026c4:	2101      	moveq	r1, #1
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:50
            width *= 10;
            width += c-'0';
 80026c6:	230a      	movs	r3, #10
 80026c8:	fb03 0202 	mla	r2, r3, r2, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:51
        }
 80026cc:	e7f0      	b.n	80026b0 <kl_vsprintf+0x40>
 80026ce:	9201      	str	r2, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:53

        if((c == 's') || (c == 'S')) {
 80026d0:	f003 02df 	and.w	r2, r3, #223	; 0xdf
 80026d4:	2a53      	cmp	r2, #83	; 0x53
 80026d6:	f88d 1014 	strb.w	r1, [sp, #20]
 80026da:	d110      	bne.n	80026fe <kl_vsprintf+0x8e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:54
            char *s = va_arg(args, char*);
 80026dc:	1d25      	adds	r5, r4, #4
 80026de:	6824      	ldr	r4, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:55 (discriminator 1)
            while((*s != 0) && (CharCnt++ < MaxLength)) PPutChar(*s++);
 80026e0:	f814 3b01 	ldrb.w	r3, [r4], #1
 80026e4:	2b00      	cmp	r3, #0
 80026e6:	d06b      	beq.n	80027c0 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:55 (discriminator 2)
 80026e8:	9b03      	ldr	r3, [sp, #12]
 80026ea:	1c5a      	adds	r2, r3, #1
 80026ec:	9203      	str	r2, [sp, #12]
 80026ee:	9a02      	ldr	r2, [sp, #8]
 80026f0:	4293      	cmp	r3, r2
 80026f2:	d265      	bcs.n	80027c0 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:55 (discriminator 1)
 80026f4:	f814 0c01 	ldrb.w	r0, [r4, #-1]
 80026f8:	9b04      	ldr	r3, [sp, #16]
 80026fa:	4798      	blx	r3
 80026fc:	e7f0      	b.n	80026e0 <kl_vsprintf+0x70>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:57
        }
        else if(c == 'c') {
 80026fe:	2b63      	cmp	r3, #99	; 0x63
 8002700:	d10b      	bne.n	800271a <kl_vsprintf+0xaa>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:58
            PPutChar(va_arg(args, int));
 8002702:	9b04      	ldr	r3, [sp, #16]
 8002704:	7820      	ldrb	r0, [r4, #0]
 8002706:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:59
            if(++CharCnt >= MaxLength) break;
 8002708:	9b03      	ldr	r3, [sp, #12]
 800270a:	9a02      	ldr	r2, [sp, #8]
 800270c:	3301      	adds	r3, #1
 800270e:	4293      	cmp	r3, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:58
        if((c == 's') || (c == 'S')) {
            char *s = va_arg(args, char*);
            while((*s != 0) && (CharCnt++ < MaxLength)) PPutChar(*s++);
        }
        else if(c == 'c') {
            PPutChar(va_arg(args, int));
 8002710:	f104 0504 	add.w	r5, r4, #4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:59
            if(++CharCnt >= MaxLength) break;
 8002714:	9303      	str	r3, [sp, #12]
 8002716:	d353      	bcc.n	80027c0 <kl_vsprintf+0x150>
 8002718:	e7c3      	b.n	80026a2 <kl_vsprintf+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:61
        }
        else if(c == 'X') IPutUint(va_arg(args, uint32_t), 16);
 800271a:	2b58      	cmp	r3, #88	; 0x58
 800271c:	d105      	bne.n	800272a <kl_vsprintf+0xba>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:61 (discriminator 1)
 800271e:	1d25      	adds	r5, r4, #4
 8002720:	f10d 0c04 	add.w	ip, sp, #4
 8002724:	6820      	ldr	r0, [r4, #0]
 8002726:	2110      	movs	r1, #16
 8002728:	e006      	b.n	8002738 <kl_vsprintf+0xc8>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:62
        else if(c == 'u') IPutUint(va_arg(args, uint32_t), 10);
 800272a:	2b75      	cmp	r3, #117	; 0x75
 800272c:	d107      	bne.n	800273e <kl_vsprintf+0xce>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:62 (discriminator 1)
 800272e:	6820      	ldr	r0, [r4, #0]
 8002730:	1d25      	adds	r5, r4, #4
 8002732:	f10d 0c04 	add.w	ip, sp, #4
 8002736:	210a      	movs	r1, #10
 8002738:	f7ff ff5a 	bl	80025f0 <IPutUint.4105>
 800273c:	e040      	b.n	80027c0 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:63
        else if(c == 'd') {
 800273e:	2b64      	cmp	r3, #100	; 0x64
 8002740:	d111      	bne.n	8002766 <kl_vsprintf+0xf6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:64
            int32_t n = va_arg(args, int32_t);
 8002742:	1d25      	adds	r5, r4, #4
 8002744:	6824      	ldr	r4, [r4, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:65
            if(n < 0) {
 8002746:	2c00      	cmp	r4, #0
 8002748:	da09      	bge.n	800275e <kl_vsprintf+0xee>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:66
                PPutChar('-');
 800274a:	9b04      	ldr	r3, [sp, #16]
 800274c:	202d      	movs	r0, #45	; 0x2d
 800274e:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:67
                if(++CharCnt >= MaxLength) break;
 8002750:	9b03      	ldr	r3, [sp, #12]
 8002752:	9a02      	ldr	r2, [sp, #8]
 8002754:	3301      	adds	r3, #1
 8002756:	4293      	cmp	r3, r2
 8002758:	9303      	str	r3, [sp, #12]
 800275a:	d2a2      	bcs.n	80026a2 <kl_vsprintf+0x32>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:68
                n = -n;
 800275c:	4264      	negs	r4, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:70
            }
            IPutUint(n, 10);
 800275e:	f10d 0c04 	add.w	ip, sp, #4
 8002762:	4620      	mov	r0, r4
 8002764:	e7e7      	b.n	8002736 <kl_vsprintf+0xc6>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:72
        }
        else if(c == 'A') {
 8002766:	2b41      	cmp	r3, #65	; 0x41
 8002768:	d129      	bne.n	80027be <kl_vsprintf+0x14e>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:76
            uint8_t *arr = va_arg(args, uint8_t*);
            int32_t n = va_arg(args, int32_t);
            int32_t Delimiter = va_arg(args, int32_t);
            zero_padded = true; // Every byte consists of two characters.
 800276a:	2301      	movs	r3, #1
 800276c:	f88d 3014 	strb.w	r3, [sp, #20]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:77
            width = 2;          // ...01 02 0A etc.; not 1 2 A
 8002770:	2302      	movs	r3, #2
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:73
                n = -n;
            }
            IPutUint(n, 10);
        }
        else if(c == 'A') {
            uint8_t *arr = va_arg(args, uint8_t*);
 8002772:	f8d4 9000 	ldr.w	r9, [r4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:74
            int32_t n = va_arg(args, int32_t);
 8002776:	f8d4 8004 	ldr.w	r8, [r4, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:75
            int32_t Delimiter = va_arg(args, int32_t);
 800277a:	f104 050c 	add.w	r5, r4, #12
 800277e:	68a7      	ldr	r7, [r4, #8]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:77
            zero_padded = true; // Every byte consists of two characters.
            width = 2;          // ...01 02 0A etc.; not 1 2 A
 8002780:	9301      	str	r3, [sp, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:78
            for(int32_t i = 0; i < n; i++) {
 8002782:	2400      	movs	r4, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:78 (discriminator 1)
 8002784:	4544      	cmp	r4, r8
 8002786:	da1b      	bge.n	80027c0 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:79
                if((i > 0) && (Delimiter != 0)) {
 8002788:	2c00      	cmp	r4, #0
 800278a:	dc0c      	bgt.n	80027a6 <kl_vsprintf+0x136>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:83
                    PPutChar((char)Delimiter); // do not place delimiter before or after array
                    if(++CharCnt >= MaxLength) break;
                }
                IPutUint(arr[i], 16);
 800278c:	f10d 0c04 	add.w	ip, sp, #4
 8002790:	f819 0004 	ldrb.w	r0, [r9, r4]
 8002794:	2110      	movs	r1, #16
 8002796:	f7ff ff2b 	bl	80025f0 <IPutUint.4105>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:84
                if(CharCnt >= MaxLength) break;
 800279a:	9b02      	ldr	r3, [sp, #8]
 800279c:	9a03      	ldr	r2, [sp, #12]
 800279e:	429a      	cmp	r2, r3
 80027a0:	d20e      	bcs.n	80027c0 <kl_vsprintf+0x150>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:78
            uint8_t *arr = va_arg(args, uint8_t*);
            int32_t n = va_arg(args, int32_t);
            int32_t Delimiter = va_arg(args, int32_t);
            zero_padded = true; // Every byte consists of two characters.
            width = 2;          // ...01 02 0A etc.; not 1 2 A
            for(int32_t i = 0; i < n; i++) {
 80027a2:	3401      	adds	r4, #1
 80027a4:	e7ee      	b.n	8002784 <kl_vsprintf+0x114>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:79 (discriminator 1)
                if((i > 0) && (Delimiter != 0)) {
 80027a6:	2f00      	cmp	r7, #0
 80027a8:	d0f0      	beq.n	800278c <kl_vsprintf+0x11c>
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:80
                    PPutChar((char)Delimiter); // do not place delimiter before or after array
 80027aa:	9b04      	ldr	r3, [sp, #16]
 80027ac:	b2f8      	uxtb	r0, r7
 80027ae:	4798      	blx	r3
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:81
                    if(++CharCnt >= MaxLength) break;
 80027b0:	9b03      	ldr	r3, [sp, #12]
 80027b2:	9a02      	ldr	r2, [sp, #8]
 80027b4:	3301      	adds	r3, #1
 80027b6:	4293      	cmp	r3, r2
 80027b8:	9303      	str	r3, [sp, #12]
 80027ba:	d3e7      	bcc.n	800278c <kl_vsprintf+0x11c>
 80027bc:	e000      	b.n	80027c0 <kl_vsprintf+0x150>
 80027be:	4625      	mov	r5, r4
C:/Development/Workspace/chibi-armlet/Firmware/Common/kl_lib/kl_sprintf.c:87
                }
                IPutUint(arr[i], 16);
                if(CharCnt >= MaxLength) break;
            }
        }
        if(CharCnt >= MaxLength) break;
 80027c0:	9b02      	ldr	r3, [sp, #8]
 80027c2:	9a03      	ldr	r2, [sp, #12]
 80027c4:	429a      	cmp	r2, r3
 80027c6:	f4bf af6c 	bcs.w	80026a2 <kl_vsprintf+0x32>
 80027ca:	462c      	mov	r4, r5
 80027cc:	4632      	mov	r2, r6
 80027ce:	e75a      	b.n	8002686 <kl_vsprintf+0x16>

080027d0 <Beeper_t::Init()>:
_ZN8Beeper_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:24
    chSysLockFromIsr();
    Beeper.BeepI((const BeepChunk_t*)p);
    chSysUnlockFromIsr();
}

void Beeper_t::Init() {
 80027d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:25
    IPin.Init(GPIOB, 3, TIM2, 2, BEEP_TOP_VALUE);
 80027d2:	2102      	movs	r1, #2
 80027d4:	2216      	movs	r2, #22
 80027d6:	2300      	movs	r3, #0
 80027d8:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
 80027dc:	3018      	adds	r0, #24
 80027de:	4904      	ldr	r1, [pc, #16]	; (80027f0 <Beeper_t::Init()+0x20>)
 80027e0:	2203      	movs	r2, #3
 80027e2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80027e6:	f7ff fb73 	bl	8001ed0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:26
}
 80027ea:	b005      	add	sp, #20
 80027ec:	f85d fb04 	ldr.w	pc, [sp], #4
 80027f0:	40020400 	.word	0x40020400
	...

08002800 <Beeper_t::BeepI(BeepChunk_t const*)>:
_ZN8Beeper_t5BeepIEPK11BeepChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:30

void Beeper_t::BeepI(const BeepChunk_t *PSequence) {
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
 8002800:	68c3      	ldr	r3, [r0, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:28

void Beeper_t::Init() {
    IPin.Init(GPIOB, 3, TIM2, 2, BEEP_TOP_VALUE);
}

void Beeper_t::BeepI(const BeepChunk_t *PSequence) {
 8002802:	b570      	push	{r4, r5, r6, lr}
 8002804:	4605      	mov	r5, r0
 8002806:	460c      	mov	r4, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:30
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
 8002808:	b10b      	cbz	r3, 800280e <Beeper_t::BeepI(BeepChunk_t const*)+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:30 (discriminator 1)
 800280a:	f7fe ff79 	bl	8001700 <chVTResetI>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:31
    if(PSequence == nullptr) {
 800280e:	b914      	cbnz	r4, 8002816 <Beeper_t::BeepI(BeepChunk_t const*)+0x16>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:32
        IPin.Off();
 8002810:	6a2b      	ldr	r3, [r5, #32]
_ZN8PwmPin_t3OffEv():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:219
public:
    __IO uint32_t *PCCR;    // Made public to allow DMA
    void SetFreqHz(uint32_t FreqHz);
    void Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted=false);
    void Set(uint16_t Value) { *PCCR = Value; }
    void Off() { *PCCR = 0; }
 8002812:	601c      	str	r4, [r3, #0]
 8002814:	bd70      	pop	{r4, r5, r6, pc}
_ZN8Beeper_t5BeepIEPK11BeepChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:36
        return;
    }
    // Set sound
    IPin.SetFreqHz(PSequence->Freq_Hz);
 8002816:	f105 0018 	add.w	r0, r5, #24
 800281a:	8861      	ldrh	r1, [r4, #2]
 800281c:	f7ff fc10 	bl	8002040 <PwmPin_t::SetFreqHz(unsigned long)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:32

void Beeper_t::BeepI(const BeepChunk_t *PSequence) {
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
    if(PSequence == nullptr) {
        IPin.Off();
 8002820:	6a2b      	ldr	r3, [r5, #32]
_ZN8PwmPin_t3SetEt():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:218
    TIM_TypeDef* Tim;
public:
    __IO uint32_t *PCCR;    // Made public to allow DMA
    void SetFreqHz(uint32_t FreqHz);
    void Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted=false);
    void Set(uint16_t Value) { *PCCR = Value; }
 8002822:	7822      	ldrb	r2, [r4, #0]
 8002824:	601a      	str	r2, [r3, #0]
_ZN8Beeper_t5BeepIEPK11BeepChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:40
    // Set sound
    IPin.SetFreqHz(PSequence->Freq_Hz);
    IPin.Set(PSequence->Volume);
    // Proceed sequence, stop it or restart
    const BeepChunk_t *PCh = nullptr;
    switch(PSequence->ChunkKind) {
 8002826:	79a3      	ldrb	r3, [r4, #6]
 8002828:	b11b      	cbz	r3, 8002832 <Beeper_t::BeepI(BeepChunk_t const*)+0x32>
 800282a:	2b02      	cmp	r3, #2
 800282c:	d104      	bne.n	8002838 <Beeper_t::BeepI(BeepChunk_t const*)+0x38>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:43
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
 800282e:	696b      	ldr	r3, [r5, #20]
 8002830:	e003      	b.n	800283a <Beeper_t::BeepI(BeepChunk_t const*)+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:41
    IPin.SetFreqHz(PSequence->Freq_Hz);
    IPin.Set(PSequence->Volume);
    // Proceed sequence, stop it or restart
    const BeepChunk_t *PCh = nullptr;
    switch(PSequence->ChunkKind) {
        case ckNormal: PCh = PSequence + 1; break;
 8002832:	f104 0308 	add.w	r3, r4, #8
 8002836:	e000      	b.n	800283a <Beeper_t::BeepI(BeepChunk_t const*)+0x3a>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:39
    }
    // Set sound
    IPin.SetFreqHz(PSequence->Freq_Hz);
    IPin.Set(PSequence->Volume);
    // Proceed sequence, stop it or restart
    const BeepChunk_t *PCh = nullptr;
 8002838:	2300      	movs	r3, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:46
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
    }
    // Start timer
    chVTSetI(&ITmr, MS2ST(PSequence->Time_ms), BeeperTmrCallback, (void*)PCh);
 800283a:	4628      	mov	r0, r5
 800283c:	88a1      	ldrh	r1, [r4, #4]
 800283e:	4a02      	ldr	r2, [pc, #8]	; (8002848 <Beeper_t::BeepI(BeepChunk_t const*)+0x48>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:47
}
 8002840:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:46
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
    }
    // Start timer
    chVTSetI(&ITmr, MS2ST(PSequence->Time_ms), BeeperTmrCallback, (void*)PCh);
 8002844:	f7fe bf34 	b.w	80016b0 <chVTSetI>
 8002848:	08002851 	.word	0x08002851
$d():
 800284c:	00000000 	.word	0x00000000

08002850 <BeeperTmrCallback(void*)>:
_Z17BeeperTmrCallbackPv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:18

#if 1 // =============================== Beep ==================================
#define BEEP_TOP_VALUE   22
Beeper_t Beeper;
// Timer callback
void BeeperTmrCallback(void *p) {
 8002850:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:19
    chSysLockFromIsr();
 8002852:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:18

#if 1 // =============================== Beep ==================================
#define BEEP_TOP_VALUE   22
Beeper_t Beeper;
// Timer callback
void BeeperTmrCallback(void *p) {
 8002854:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:19
    chSysLockFromIsr();
 8002856:	f383 8811 	msr	BASEPRI, r3
 800285a:	f7fe faf1 	bl	8000e40 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:20
    Beeper.BeepI((const BeepChunk_t*)p);
 800285e:	4805      	ldr	r0, [pc, #20]	; (8002874 <BeeperTmrCallback(void*)+0x24>)
 8002860:	4621      	mov	r1, r4
 8002862:	f7ff ffcd 	bl	8002800 <Beeper_t::BeepI(BeepChunk_t const*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:21
    chSysUnlockFromIsr();
 8002866:	f7fe fb03 	bl	8000e70 <dbg_check_unlock_from_isr>
 800286a:	2300      	movs	r3, #0
 800286c:	f383 8811 	msr	BASEPRI, r3
 8002870:	bd10      	pop	{r4, pc}
 8002872:	bf00      	nop
 8002874:	20000e30 	.word	0x20000e30
	...

08002880 <LedRGB_t::Init()>:
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002880:	4a4d      	ldr	r2, [pc, #308]	; (80029b8 <LedRGB_t::Init()+0x138>)
 8002882:	69d3      	ldr	r3, [r2, #28]
 8002884:	f043 0302 	orr.w	r3, r3, #2
 8002888:	61d3      	str	r3, [r2, #28]
PinSetupAlterFunc():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 800288a:	4b4c      	ldr	r3, [pc, #304]	; (80029bc <LedRGB_t::Init()+0x13c>)
 800288c:	6819      	ldr	r1, [r3, #0]
 800288e:	f021 0103 	bic.w	r1, r1, #3
 8002892:	6019      	str	r1, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8002894:	6819      	ldr	r1, [r3, #0]
 8002896:	f041 0102 	orr.w	r1, r1, #2
 800289a:	6019      	str	r1, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 800289c:	8899      	ldrh	r1, [r3, #4]
 800289e:	f021 0101 	bic.w	r1, r1, #1
 80028a2:	0409      	lsls	r1, r1, #16
 80028a4:	0c09      	lsrs	r1, r1, #16
 80028a6:	8099      	strh	r1, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80028a8:	8899      	ldrh	r1, [r3, #4]
 80028aa:	b289      	uxth	r1, r1
 80028ac:	8099      	strh	r1, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80028ae:	68d9      	ldr	r1, [r3, #12]
 80028b0:	f021 0103 	bic.w	r1, r1, #3
 80028b4:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80028b6:	68d9      	ldr	r1, [r3, #12]
 80028b8:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80028ba:	6899      	ldr	r1, [r3, #8]
 80028bc:	f021 0103 	bic.w	r1, r1, #3
 80028c0:	6099      	str	r1, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80028c2:	6899      	ldr	r1, [r3, #8]
 80028c4:	f041 0102 	orr.w	r1, r1, #2
 80028c8:	6099      	str	r1, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 80028ca:	6a19      	ldr	r1, [r3, #32]
 80028cc:	f021 010f 	bic.w	r1, r1, #15
 80028d0:	6219      	str	r1, [r3, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 80028d2:	6a19      	ldr	r1, [r3, #32]
 80028d4:	f041 0102 	orr.w	r1, r1, #2
 80028d8:	6219      	str	r1, [r3, #32]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 80028da:	69d1      	ldr	r1, [r2, #28]
 80028dc:	f041 0102 	orr.w	r1, r1, #2
 80028e0:	61d1      	str	r1, [r2, #28]
PinSetupAlterFunc():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80028e2:	6819      	ldr	r1, [r3, #0]
 80028e4:	f021 010c 	bic.w	r1, r1, #12
 80028e8:	6019      	str	r1, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80028ea:	6819      	ldr	r1, [r3, #0]
 80028ec:	f041 0108 	orr.w	r1, r1, #8
 80028f0:	6019      	str	r1, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80028f2:	8899      	ldrh	r1, [r3, #4]
 80028f4:	f021 0102 	bic.w	r1, r1, #2
 80028f8:	0409      	lsls	r1, r1, #16
 80028fa:	0c09      	lsrs	r1, r1, #16
 80028fc:	8099      	strh	r1, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80028fe:	8899      	ldrh	r1, [r3, #4]
 8002900:	b289      	uxth	r1, r1
 8002902:	8099      	strh	r1, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8002904:	68d9      	ldr	r1, [r3, #12]
 8002906:	f021 010c 	bic.w	r1, r1, #12
 800290a:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800290c:	68d9      	ldr	r1, [r3, #12]
 800290e:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8002910:	6899      	ldr	r1, [r3, #8]
 8002912:	f021 010c 	bic.w	r1, r1, #12
 8002916:	6099      	str	r1, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8002918:	6899      	ldr	r1, [r3, #8]
 800291a:	f041 0108 	orr.w	r1, r1, #8
 800291e:	6099      	str	r1, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8002920:	6a19      	ldr	r1, [r3, #32]
 8002922:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8002926:	6219      	str	r1, [r3, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8002928:	6a19      	ldr	r1, [r3, #32]
 800292a:	f041 0120 	orr.w	r1, r1, #32
 800292e:	6219      	str	r1, [r3, #32]
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002930:	69d1      	ldr	r1, [r2, #28]
 8002932:	f041 0102 	orr.w	r1, r1, #2
 8002936:	61d1      	str	r1, [r2, #28]
PinSetupAlterFunc():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:192
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8002938:	6819      	ldr	r1, [r3, #0]
 800293a:	f421 6140 	bic.w	r1, r1, #3072	; 0xc00
 800293e:	6019      	str	r1, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:193
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8002940:	6819      	ldr	r1, [r3, #0]
 8002942:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8002946:	6019      	str	r1, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:195
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8002948:	8899      	ldrh	r1, [r3, #4]
 800294a:	f021 0120 	bic.w	r1, r1, #32
 800294e:	0409      	lsls	r1, r1, #16
 8002950:	0c09      	lsrs	r1, r1, #16
 8002952:	8099      	strh	r1, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:196
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8002954:	8899      	ldrh	r1, [r3, #4]
 8002956:	b289      	uxth	r1, r1
 8002958:	8099      	strh	r1, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:198
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 800295a:	68d9      	ldr	r1, [r3, #12]
 800295c:	f421 6140 	bic.w	r1, r1, #3072	; 0xc00
 8002960:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:199
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8002962:	68d9      	ldr	r1, [r3, #12]
 8002964:	60d9      	str	r1, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:201
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8002966:	6899      	ldr	r1, [r3, #8]
 8002968:	f421 6140 	bic.w	r1, r1, #3072	; 0xc00
 800296c:	6099      	str	r1, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:202
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800296e:	6899      	ldr	r1, [r3, #8]
 8002970:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8002974:	6099      	str	r1, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:206
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8002976:	6a19      	ldr	r1, [r3, #32]
 8002978:	f421 0170 	bic.w	r1, r1, #15728640	; 0xf00000
 800297c:	6219      	str	r1, [r3, #32]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:207
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 800297e:	6a19      	ldr	r1, [r3, #32]
 8002980:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8002984:	6219      	str	r1, [r3, #32]
_ZN8LedRGB_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:69
    // ==== GPIO ====
    PinSetupAlterFunc(LED_GPIO, LED_P1, omPushPull, pudNone, LED_ALTERFUNC);
    PinSetupAlterFunc(LED_GPIO, LED_P2, omPushPull, pudNone, LED_ALTERFUNC);
    PinSetupAlterFunc(LED_GPIO, LED_P3, omPushPull, pudNone, LED_ALTERFUNC);
    // ==== Timer ====
    LED_RCC_EN();
 8002986:	6a53      	ldr	r3, [r2, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:74
    // ==== Timebase and general ====
    LED_TIM->CR1 = 0x01;       // Enable timer, set clk division to 0, AutoReload not buffered
    LED_TIM->CR2 = 0;          // Output Idle State
    LED_TIM->PSC = 0;          // No clock division
    LED_TIM->ARR = 255;        // Autoreload register: top value of PWM
 8002988:	21ff      	movs	r1, #255	; 0xff
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:69
    // ==== GPIO ====
    PinSetupAlterFunc(LED_GPIO, LED_P1, omPushPull, pudNone, LED_ALTERFUNC);
    PinSetupAlterFunc(LED_GPIO, LED_P2, omPushPull, pudNone, LED_ALTERFUNC);
    PinSetupAlterFunc(LED_GPIO, LED_P3, omPushPull, pudNone, LED_ALTERFUNC);
    // ==== Timer ====
    LED_RCC_EN();
 800298a:	f043 0302 	orr.w	r3, r3, #2
 800298e:	6253      	str	r3, [r2, #36]	; 0x24
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:71
    // ==== Timebase and general ====
    LED_TIM->CR1 = 0x01;       // Enable timer, set clk division to 0, AutoReload not buffered
 8002990:	4b0b      	ldr	r3, [pc, #44]	; (80029c0 <LedRGB_t::Init()+0x140>)
 8002992:	2201      	movs	r2, #1
 8002994:	801a      	strh	r2, [r3, #0]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:72
    LED_TIM->CR2 = 0;          // Output Idle State
 8002996:	2200      	movs	r2, #0
 8002998:	809a      	strh	r2, [r3, #4]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:73
    LED_TIM->PSC = 0;          // No clock division
 800299a:	851a      	strh	r2, [r3, #40]	; 0x28
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:74
    LED_TIM->ARR = 255;        // Autoreload register: top value of PWM
 800299c:	62d9      	str	r1, [r3, #44]	; 0x2c
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:77
    // ==== Outputs ====
    const uint16_t OutCmpBits = 0b01100000; // output, PWM1
    LED_TIM->CCMR1 = OutCmpBits << 8;       // CCR2
 800299e:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
 80029a2:	8319      	strh	r1, [r3, #24]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:78
    LED_TIM->CCMR2 = (OutCmpBits << 8) | OutCmpBits;
 80029a4:	f246 0160 	movw	r1, #24672	; 0x6060
 80029a8:	8399      	strh	r1, [r3, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:79
    LED_TIM->CCER = TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E;
 80029aa:	f241 1110 	movw	r1, #4368	; 0x1110
 80029ae:	8419      	strh	r1, [r3, #32]
_ZN8LedRGB_t7ISetRedEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.h:90

class LedRGB_t {
private:
    const LedChunk_t *IPFirstChunk;
    VirtualTimer ITmr;
    void ISetRed  (uint8_t AValue) {LED_TIM->LED_RED_CCR   = AValue;}
 80029b0:	641a      	str	r2, [r3, #64]	; 0x40
_ZN8LedRGB_t9ISetGreenEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.h:91
    void ISetGreen(uint8_t AValue) {LED_TIM->LED_GREEN_CCR = AValue;}
 80029b2:	63da      	str	r2, [r3, #60]	; 0x3c
_ZN8LedRGB_t8ISetBlueEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.h:92
    void ISetBlue (uint8_t AValue) {LED_TIM->LED_BLUE_CCR  = AValue;}
 80029b4:	639a      	str	r2, [r3, #56]	; 0x38
 80029b6:	4770      	bx	lr
 80029b8:	40023800 	.word	0x40023800
 80029bc:	40020400 	.word	0x40020400
 80029c0:	40000400 	.word	0x40000400
	...

080029d0 <Vibro_t::Init()>:
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 80029d0:	4b13      	ldr	r3, [pc, #76]	; (8002a20 <Vibro_t::Init()+0x50>)
 80029d2:	69da      	ldr	r2, [r3, #28]
 80029d4:	f042 0202 	orr.w	r2, r2, #2
 80029d8:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80029da:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 80029de:	681a      	ldr	r2, [r3, #0]
 80029e0:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80029e4:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 80029e6:	681a      	ldr	r2, [r3, #0]
 80029e8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80029ec:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80029ee:	889a      	ldrh	r2, [r3, #4]
 80029f0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80029f4:	0412      	lsls	r2, r2, #16
 80029f6:	0c12      	lsrs	r2, r2, #16
 80029f8:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80029fa:	889a      	ldrh	r2, [r3, #4]
 80029fc:	b292      	uxth	r2, r2
 80029fe:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8002a00:	68da      	ldr	r2, [r3, #12]
 8002a02:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002a06:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8002a08:	68da      	ldr	r2, [r3, #12]
 8002a0a:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8002a0c:	689a      	ldr	r2, [r3, #8]
 8002a0e:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002a12:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8002a14:	689a      	ldr	r2, [r3, #8]
 8002a16:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 8002a1a:	609a      	str	r2, [r3, #8]
 8002a1c:	4770      	bx	lr
 8002a1e:	bf00      	nop
 8002a20:	40023800 	.word	0x40023800
	...

08002a30 <Vibro_t::IFlinchI(VibroChunk_t const*)>:
_ZN7Vibro_t8IFlinchIEPK12VibroChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:121
    PinSetupOut(GPIOB, 6, omPushPull, pudNone);
}

void Vibro_t::IFlinchI(const VibroChunk_t *PSequence) {
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
 8002a30:	68c3      	ldr	r3, [r0, #12]
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:119

void Vibro_t::Init() {
    PinSetupOut(GPIOB, 6, omPushPull, pudNone);
}

void Vibro_t::IFlinchI(const VibroChunk_t *PSequence) {
 8002a32:	b570      	push	{r4, r5, r6, lr}
 8002a34:	4605      	mov	r5, r0
 8002a36:	460c      	mov	r4, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:121
    // Reset timer
    if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);
 8002a38:	b10b      	cbz	r3, 8002a3e <Vibro_t::IFlinchI(VibroChunk_t const*)+0xe>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:121 (discriminator 1)
 8002a3a:	f7fe fe61 	bl	8001700 <chVTResetI>
 8002a3e:	4b0e      	ldr	r3, [pc, #56]	; (8002a78 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x48>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:122
    if(PSequence == nullptr) {
 8002a40:	b914      	cbnz	r4, 8002a48 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x18>
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8002a42:	2240      	movs	r2, #64	; 0x40
 8002a44:	835a      	strh	r2, [r3, #26]
 8002a46:	bd70      	pop	{r4, r5, r6, pc}
_ZN7Vibro_t8IFlinchIEPK12VibroChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:127
        PinClear(VIBRO_GPIO, VIBRO_PIN);
        return;
    }
    // Set vibro pwr
    if(PSequence->OnOff == stOn) PinSet(VIBRO_GPIO, VIBRO_PIN);
 8002a48:	7821      	ldrb	r1, [r4, #0]
 8002a4a:	2240      	movs	r2, #64	; 0x40
 8002a4c:	b909      	cbnz	r1, 8002a52 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x22>
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8002a4e:	831a      	strh	r2, [r3, #24]
 8002a50:	e000      	b.n	8002a54 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x24>
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8002a52:	835a      	strh	r2, [r3, #26]
_ZN7Vibro_t8IFlinchIEPK12VibroChunk_t():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:131
    else PinClear(VIBRO_GPIO, VIBRO_PIN);
    // Proceed with sequence, stop it or restart
    const VibroChunk_t *PCh = nullptr;
    switch(PSequence->ChunkKind) {
 8002a54:	78e3      	ldrb	r3, [r4, #3]
 8002a56:	b11b      	cbz	r3, 8002a60 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x30>
 8002a58:	2b02      	cmp	r3, #2
 8002a5a:	d103      	bne.n	8002a64 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x34>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:134
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
 8002a5c:	696b      	ldr	r3, [r5, #20]
 8002a5e:	e002      	b.n	8002a66 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:132
    if(PSequence->OnOff == stOn) PinSet(VIBRO_GPIO, VIBRO_PIN);
    else PinClear(VIBRO_GPIO, VIBRO_PIN);
    // Proceed with sequence, stop it or restart
    const VibroChunk_t *PCh = nullptr;
    switch(PSequence->ChunkKind) {
        case ckNormal: PCh = PSequence + 1; break;
 8002a60:	1d23      	adds	r3, r4, #4
 8002a62:	e000      	b.n	8002a66 <Vibro_t::IFlinchI(VibroChunk_t const*)+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:130
    }
    // Set vibro pwr
    if(PSequence->OnOff == stOn) PinSet(VIBRO_GPIO, VIBRO_PIN);
    else PinClear(VIBRO_GPIO, VIBRO_PIN);
    // Proceed with sequence, stop it or restart
    const VibroChunk_t *PCh = nullptr;
 8002a64:	2300      	movs	r3, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:137
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
    }
    // Start timer
    chVTSetI(&ITmr, MS2ST(PSequence->Time_ms), VibroTmrCallback, (void*)PCh);
 8002a66:	4628      	mov	r0, r5
 8002a68:	f8b4 1001 	ldrh.w	r1, [r4, #1]
 8002a6c:	4a03      	ldr	r2, [pc, #12]	; (8002a7c <Vibro_t::IFlinchI(VibroChunk_t const*)+0x4c>)
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:138
}
 8002a6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:137
        case ckNormal: PCh = PSequence + 1; break;
        case ckStop:                        break;
        case ckRepeat: PCh = IPFirstChunk;  break;
    }
    // Start timer
    chVTSetI(&ITmr, MS2ST(PSequence->Time_ms), VibroTmrCallback, (void*)PCh);
 8002a72:	f7fe be1d 	b.w	80016b0 <chVTSetI>
 8002a76:	bf00      	nop
 8002a78:	40020400 	.word	0x40020400
 8002a7c:	08002a81 	.word	0x08002a81

08002a80 <VibroTmrCallback(void*)>:
_Z16VibroTmrCallbackPv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:109
#if VIBRO_ENABLED // ======================= Vibro =============================
Vibro_t Vibro;
#define VIBRO_TOP_VALUE   22

// Timer callback
void VibroTmrCallback(void *p) {
 8002a80:	b510      	push	{r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:110
    chSysLockFromIsr();
 8002a82:	2320      	movs	r3, #32
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:109
#if VIBRO_ENABLED // ======================= Vibro =============================
Vibro_t Vibro;
#define VIBRO_TOP_VALUE   22

// Timer callback
void VibroTmrCallback(void *p) {
 8002a84:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:110
    chSysLockFromIsr();
 8002a86:	f383 8811 	msr	BASEPRI, r3
 8002a8a:	f7fe f9d9 	bl	8000e40 <dbg_check_lock_from_isr>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:111
    Vibro.IFlinchI((const VibroChunk_t*)p);
 8002a8e:	4805      	ldr	r0, [pc, #20]	; (8002aa4 <VibroTmrCallback(void*)+0x24>)
 8002a90:	4621      	mov	r1, r4
 8002a92:	f7ff ffcd 	bl	8002a30 <Vibro_t::IFlinchI(VibroChunk_t const*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/peripheral.cpp:112
    chSysUnlockFromIsr();
 8002a96:	f7fe f9eb 	bl	8000e70 <dbg_check_unlock_from_isr>
 8002a9a:	2300      	movs	r3, #0
 8002a9c:	f383 8811 	msr	BASEPRI, r3
 8002aa0:	bd10      	pop	{r4, pc}
 8002aa2:	bf00      	nop
 8002aa4:	20000e18 	.word	0x20000e18
	...

08002ab0 <PillMgr_t::Deinit()>:
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:22
    chThdSleepMilliseconds(1);  // Allow power to rise
    i2c.Init(PILL_I2C, PILL_I2C_GPIO, PILL_SCL_PIN, PILL_SDA_PIN, PILL_I2C_BITRATE_HZ, PILL_DMATX, PILL_DMARX);
    chSemSignal(&Sem);
}

void PillMgr_t::Deinit() {
 8002ab0:	b538      	push	{r3, r4, r5, lr}
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 8002ab2:	4c0d      	ldr	r4, [pc, #52]	; (8002ae8 <PillMgr_t::Deinit()+0x38>)
 8002ab4:	2380      	movs	r3, #128	; 0x80
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:22
 8002ab6:	4605      	mov	r5, r0
PinClear():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:124
 8002ab8:	8363      	strh	r3, [r4, #26]
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:24
    PinClear(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to fade
 8002aba:	2001      	movs	r0, #1
 8002abc:	f7fe fd98 	bl	80015f0 <chThdSleep>
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002ac0:	4b0a      	ldr	r3, [pc, #40]	; (8002aec <PillMgr_t::Deinit()+0x3c>)
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:26
    PinSetupAnalog(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);    // Power
    i2c.Standby();
 8002ac2:	f105 000c 	add.w	r0, r5, #12
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8002ac6:	69da      	ldr	r2, [r3, #28]
 8002ac8:	f042 0202 	orr.w	r2, r2, #2
 8002acc:	61da      	str	r2, [r3, #28]
PinSetupAnalog():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:176
}
static inline void PinSetupAnalog(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
 8002ace:	6823      	ldr	r3, [r4, #0]
 8002ad0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002ad4:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:178
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8002ad6:	68e3      	ldr	r3, [r4, #12]
 8002ad8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002adc:	60e3      	str	r3, [r4, #12]
_ZN9PillMgr_t6DeinitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:27
}
 8002ade:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:26

void PillMgr_t::Deinit() {
    PinClear(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to fade
    PinSetupAnalog(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);    // Power
    i2c.Standby();
 8002ae2:	f7ff bacd 	b.w	8002080 <i2c_t::Standby()>
 8002ae6:	bf00      	nop
 8002ae8:	40020400 	.word	0x40020400
 8002aec:	40023800 	.word	0x40023800

08002af0 <PillMgr_t::Init()>:
_ZN9PillMgr_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:12

#include "pill_mgr.h"

PillMgr_t PillMgr;

void PillMgr_t::Init() {
 8002af0:	b530      	push	{r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:13
    chSemInit(&Sem, 0); // Requesting Thread will be queued
 8002af2:	2100      	movs	r1, #0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:12

#include "pill_mgr.h"

PillMgr_t PillMgr;

void PillMgr_t::Init() {
 8002af4:	b085      	sub	sp, #20
 8002af6:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:13
    chSemInit(&Sem, 0); // Requesting Thread will be queued
 8002af8:	f7fe fbfa 	bl	80012f0 <chSemInit>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:14
    Deinit();
 8002afc:	4628      	mov	r0, r5
 8002afe:	f7ff ffd7 	bl	8002ab0 <PillMgr_t::Deinit()>
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002b02:	4b1f      	ldr	r3, [pc, #124]	; (8002b80 <PillMgr_t::Init()+0x90>)
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8002b04:	4c1f      	ldr	r4, [pc, #124]	; (8002b84 <PillMgr_t::Init()+0x94>)
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002b06:	69da      	ldr	r2, [r3, #28]
_ZN9PillMgr_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:17
    PinSetupOut(PERIPH_PWR_GPIO, PERIPH_PWR_PIN, omPushPull);   // Power
    PinSet(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to rise
 8002b08:	2001      	movs	r0, #1
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8002b0a:	f042 0202 	orr.w	r2, r2, #2
 8002b0e:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8002b10:	6823      	ldr	r3, [r4, #0]
 8002b12:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002b16:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 8002b18:	6823      	ldr	r3, [r4, #0]
 8002b1a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002b1e:	6023      	str	r3, [r4, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8002b20:	88a3      	ldrh	r3, [r4, #4]
 8002b22:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002b26:	041b      	lsls	r3, r3, #16
 8002b28:	0c1b      	lsrs	r3, r3, #16
 8002b2a:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8002b2c:	88a3      	ldrh	r3, [r4, #4]
 8002b2e:	b29b      	uxth	r3, r3
 8002b30:	80a3      	strh	r3, [r4, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8002b32:	68e3      	ldr	r3, [r4, #12]
 8002b34:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002b38:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8002b3a:	68e3      	ldr	r3, [r4, #12]
 8002b3c:	60e3      	str	r3, [r4, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8002b3e:	68a3      	ldr	r3, [r4, #8]
 8002b40:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002b44:	60a3      	str	r3, [r4, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8002b46:	68a3      	ldr	r3, [r4, #8]
 8002b48:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002b4c:	60a3      	str	r3, [r4, #8]
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8002b4e:	2380      	movs	r3, #128	; 0x80
 8002b50:	8323      	strh	r3, [r4, #24]
_ZN9PillMgr_t4InitEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:17
 8002b52:	f7fe fd4d 	bl	80015f0 <chThdSleep>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:18
    i2c.Init(PILL_I2C, PILL_I2C_GPIO, PILL_SCL_PIN, PILL_SDA_PIN, PILL_I2C_BITRATE_HZ, PILL_DMATX, PILL_DMARX);
 8002b56:	4b0c      	ldr	r3, [pc, #48]	; (8002b88 <PillMgr_t::Init()+0x98>)
 8002b58:	2209      	movs	r2, #9
 8002b5a:	e88d 000c 	stmia.w	sp, {r2, r3}
 8002b5e:	4b0b      	ldr	r3, [pc, #44]	; (8002b8c <PillMgr_t::Init()+0x9c>)
 8002b60:	f105 000c 	add.w	r0, r5, #12
 8002b64:	9302      	str	r3, [sp, #8]
 8002b66:	330c      	adds	r3, #12
 8002b68:	9303      	str	r3, [sp, #12]
 8002b6a:	4909      	ldr	r1, [pc, #36]	; (8002b90 <PillMgr_t::Init()+0xa0>)
 8002b6c:	4622      	mov	r2, r4
 8002b6e:	2308      	movs	r3, #8
 8002b70:	f7ff fb36 	bl	80021e0 <i2c_t::Init(I2C_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned short, unsigned long, stm32_dma_stream_t const*, stm32_dma_stream_t const*)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:19
    chSemSignal(&Sem);
 8002b74:	4628      	mov	r0, r5
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:20
}
 8002b76:	b005      	add	sp, #20
 8002b78:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:19
    Deinit();
    PinSetupOut(PERIPH_PWR_GPIO, PERIPH_PWR_PIN, omPushPull);   // Power
    PinSet(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to rise
    i2c.Init(PILL_I2C, PILL_I2C_GPIO, PILL_SCL_PIN, PILL_SDA_PIN, PILL_I2C_BITRATE_HZ, PILL_DMATX, PILL_DMARX);
    chSemSignal(&Sem);
 8002b7c:	f7fe bc10 	b.w	80013a0 <chSemSignal>
 8002b80:	40023800 	.word	0x40023800
 8002b84:	40020400 	.word	0x40020400
 8002b88:	00030d40 	.word	0x00030d40
 8002b8c:	080031ac 	.word	0x080031ac
 8002b90:	40005400 	.word	0x40005400
	...

08002ba0 <PillMgr_t::ResetBus()>:
_ZN9PillMgr_t8ResetBusEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:29
    chThdSleepMilliseconds(1);  // Allow power to fade
    PinSetupAnalog(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);    // Power
    i2c.Standby();
}

void PillMgr_t::ResetBus() {
 8002ba0:	b510      	push	{r4, lr}
 8002ba2:	4604      	mov	r4, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:30
    Deinit();
 8002ba4:	f7ff ff84 	bl	8002ab0 <PillMgr_t::Deinit()>
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8002ba8:	4b18      	ldr	r3, [pc, #96]	; (8002c0c <PillMgr_t::ResetBus()+0x6c>)
_ZN9PillMgr_t8ResetBusEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:33
    PinSetupOut(PERIPH_PWR_GPIO, PERIPH_PWR_PIN, omPushPull);   // Power
    PinSet(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to rise
 8002baa:	2001      	movs	r0, #1
PinClockEnable():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:131
 8002bac:	69da      	ldr	r2, [r3, #28]
 8002bae:	f042 0202 	orr.w	r2, r2, #2
 8002bb2:	61da      	str	r2, [r3, #28]
PinSetupOut():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:146
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8002bb4:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 8002bb8:	681a      	ldr	r2, [r3, #0]
 8002bba:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002bbe:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:147
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 8002bc0:	681a      	ldr	r2, [r3, #0]
 8002bc2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002bc6:	601a      	str	r2, [r3, #0]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:149
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8002bc8:	889a      	ldrh	r2, [r3, #4]
 8002bca:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002bce:	0412      	lsls	r2, r2, #16
 8002bd0:	0c12      	lsrs	r2, r2, #16
 8002bd2:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:150
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8002bd4:	889a      	ldrh	r2, [r3, #4]
 8002bd6:	b292      	uxth	r2, r2
 8002bd8:	809a      	strh	r2, [r3, #4]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:152
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8002bda:	68da      	ldr	r2, [r3, #12]
 8002bdc:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002be0:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:153
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8002be2:	68da      	ldr	r2, [r3, #12]
 8002be4:	60da      	str	r2, [r3, #12]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:155
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8002be6:	689a      	ldr	r2, [r3, #8]
 8002be8:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002bec:	609a      	str	r2, [r3, #8]
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:156
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8002bee:	689a      	ldr	r2, [r3, #8]
 8002bf0:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002bf4:	609a      	str	r2, [r3, #8]
PinSet():
C:\Development\Workspace\chibi-armlet\Firmware\Basic\Debug/../../Common/kl_lib/kl_lib_L15x.h:123
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8002bf6:	2280      	movs	r2, #128	; 0x80
 8002bf8:	831a      	strh	r2, [r3, #24]
_ZN9PillMgr_t8ResetBusEv():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:33
 8002bfa:	f7fe fcf9 	bl	80015f0 <chThdSleep>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:34
    i2c.Resume();
 8002bfe:	f104 000c 	add.w	r0, r4, #12
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:35
}
 8002c02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:34
void PillMgr_t::ResetBus() {
    Deinit();
    PinSetupOut(PERIPH_PWR_GPIO, PERIPH_PWR_PIN, omPushPull);   // Power
    PinSet(PERIPH_PWR_GPIO, PERIPH_PWR_PIN);
    chThdSleepMilliseconds(1);  // Allow power to rise
    i2c.Resume();
 8002c06:	f7ff ba7b 	b.w	8002100 <i2c_t::Resume()>
 8002c0a:	bf00      	nop
 8002c0c:	40023800 	.word	0x40023800

08002c10 <PillMgr_t::CheckIfConnected(unsigned char)>:
_ZN9PillMgr_t16CheckIfConnectedEh():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:37
}

uint8_t PillMgr_t::CheckIfConnected(uint8_t i2cAddr) {
 8002c10:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8002c12:	4604      	mov	r4, r0
 8002c14:	460d      	mov	r5, r1
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:38
    chSemWait(&Sem);
 8002c16:	f7fe fbab 	bl	8001370 <chSemWait>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:39
    uint8_t Rslt = i2c.CmdWriteWrite(i2cAddr, NULL, 0, NULL, 0);
 8002c1a:	2200      	movs	r2, #0
 8002c1c:	4629      	mov	r1, r5
 8002c1e:	4613      	mov	r3, r2
 8002c20:	9200      	str	r2, [sp, #0]
 8002c22:	9201      	str	r2, [sp, #4]
 8002c24:	f104 000c 	add.w	r0, r4, #12
 8002c28:	f7ff fc3a 	bl	80024a0 <i2c_t::CmdWriteWrite(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:40
    if(i2c.Error == true) ResetBus();
 8002c2c:	7f23      	ldrb	r3, [r4, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:39
    i2c.Resume();
}

uint8_t PillMgr_t::CheckIfConnected(uint8_t i2cAddr) {
    chSemWait(&Sem);
    uint8_t Rslt = i2c.CmdWriteWrite(i2cAddr, NULL, 0, NULL, 0);
 8002c2e:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:40
    if(i2c.Error == true) ResetBus();
 8002c30:	b113      	cbz	r3, 8002c38 <PillMgr_t::CheckIfConnected(unsigned char)+0x28>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:40 (discriminator 1)
 8002c32:	4620      	mov	r0, r4
 8002c34:	f7ff ffb4 	bl	8002ba0 <PillMgr_t::ResetBus()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:41
    chSemSignal(&Sem);
 8002c38:	4620      	mov	r0, r4
 8002c3a:	f7fe fbb1 	bl	80013a0 <chSemSignal>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:43
    return Rslt;
}
 8002c3e:	4628      	mov	r0, r5
 8002c40:	b003      	add	sp, #12
 8002c42:	bd30      	pop	{r4, r5, pc}
	...

08002c50 <PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)>:
_ZN9PillMgr_t4ReadEhPhm():
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:45

uint8_t PillMgr_t::Read(uint8_t i2cAddr, uint8_t *Ptr, uint32_t Length) {
 8002c50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002c52:	461f      	mov	r7, r3
 8002c54:	b085      	sub	sp, #20
 8002c56:	4604      	mov	r4, r0
 8002c58:	460d      	mov	r5, r1
 8002c5a:	4616      	mov	r6, r2
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:48
    chSemWait(&Sem);
    uint8_t WordAddress = PILL_START_ADDR;
    uint8_t Rslt = i2c.CmdWriteRead(i2cAddr, &WordAddress, 1, Ptr, Length);
 8002c5c:	b2ff      	uxtb	r7, r7
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:46
    chSemSignal(&Sem);
    return Rslt;
}

uint8_t PillMgr_t::Read(uint8_t i2cAddr, uint8_t *Ptr, uint32_t Length) {
    chSemWait(&Sem);
 8002c5e:	f7fe fb87 	bl	8001370 <chSemWait>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:47
    uint8_t WordAddress = PILL_START_ADDR;
 8002c62:	aa04      	add	r2, sp, #16
 8002c64:	2300      	movs	r3, #0
 8002c66:	f802 3d01 	strb.w	r3, [r2, #-1]!
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:48
    uint8_t Rslt = i2c.CmdWriteRead(i2cAddr, &WordAddress, 1, Ptr, Length);
 8002c6a:	4629      	mov	r1, r5
 8002c6c:	2301      	movs	r3, #1
 8002c6e:	9600      	str	r6, [sp, #0]
 8002c70:	9701      	str	r7, [sp, #4]
 8002c72:	f104 000c 	add.w	r0, r4, #12
 8002c76:	f7ff fb43 	bl	8002300 <i2c_t::CmdWriteRead(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char)>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:49
    if(i2c.Error == true) ResetBus();
 8002c7a:	7f23      	ldrb	r3, [r4, #28]
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:48
}

uint8_t PillMgr_t::Read(uint8_t i2cAddr, uint8_t *Ptr, uint32_t Length) {
    chSemWait(&Sem);
    uint8_t WordAddress = PILL_START_ADDR;
    uint8_t Rslt = i2c.CmdWriteRead(i2cAddr, &WordAddress, 1, Ptr, Length);
 8002c7c:	4605      	mov	r5, r0
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:49
    if(i2c.Error == true) ResetBus();
 8002c7e:	b113      	cbz	r3, 8002c86 <PillMgr_t::Read(unsigned char, unsigned char*, unsigned long)+0x36>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:49 (discriminator 1)
 8002c80:	4620      	mov	r0, r4
 8002c82:	f7ff ff8d 	bl	8002ba0 <PillMgr_t::ResetBus()>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:50
    chSemSignal(&Sem);
 8002c86:	4620      	mov	r0, r4
 8002c88:	f7fe fb8a 	bl	80013a0 <chSemSignal>
C:/Development/Workspace/chibi-armlet/Firmware/Common/pill_mgr.cpp:52
    return Rslt;
}
 8002c8c:	4628      	mov	r0, r5
 8002c8e:	b005      	add	sp, #20
 8002c90:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08002ca0 <memset>:
memset():
 8002ca0:	b4f0      	push	{r4, r5, r6, r7}
 8002ca2:	0784      	lsls	r4, r0, #30
 8002ca4:	d043      	beq.n	8002d2e <memset+0x8e>
 8002ca6:	1e54      	subs	r4, r2, #1
 8002ca8:	2a00      	cmp	r2, #0
 8002caa:	d03e      	beq.n	8002d2a <memset+0x8a>
 8002cac:	b2cd      	uxtb	r5, r1
 8002cae:	4603      	mov	r3, r0
 8002cb0:	e003      	b.n	8002cba <memset+0x1a>
 8002cb2:	1e62      	subs	r2, r4, #1
 8002cb4:	2c00      	cmp	r4, #0
 8002cb6:	d038      	beq.n	8002d2a <memset+0x8a>
 8002cb8:	4614      	mov	r4, r2
 8002cba:	f803 5b01 	strb.w	r5, [r3], #1
 8002cbe:	079a      	lsls	r2, r3, #30
 8002cc0:	d1f7      	bne.n	8002cb2 <memset+0x12>
 8002cc2:	2c03      	cmp	r4, #3
 8002cc4:	d92a      	bls.n	8002d1c <memset+0x7c>
 8002cc6:	b2cd      	uxtb	r5, r1
 8002cc8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8002ccc:	2c0f      	cmp	r4, #15
 8002cce:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8002cd2:	d915      	bls.n	8002d00 <memset+0x60>
 8002cd4:	f1a4 0710 	sub.w	r7, r4, #16
 8002cd8:	093f      	lsrs	r7, r7, #4
 8002cda:	f103 0610 	add.w	r6, r3, #16
 8002cde:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8002ce2:	461a      	mov	r2, r3
 8002ce4:	6015      	str	r5, [r2, #0]
 8002ce6:	6055      	str	r5, [r2, #4]
 8002ce8:	6095      	str	r5, [r2, #8]
 8002cea:	60d5      	str	r5, [r2, #12]
 8002cec:	3210      	adds	r2, #16
 8002cee:	42b2      	cmp	r2, r6
 8002cf0:	d1f8      	bne.n	8002ce4 <memset+0x44>
 8002cf2:	f004 040f 	and.w	r4, r4, #15
 8002cf6:	3701      	adds	r7, #1
 8002cf8:	2c03      	cmp	r4, #3
 8002cfa:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 8002cfe:	d90d      	bls.n	8002d1c <memset+0x7c>
 8002d00:	461e      	mov	r6, r3
 8002d02:	4622      	mov	r2, r4
 8002d04:	3a04      	subs	r2, #4
 8002d06:	2a03      	cmp	r2, #3
 8002d08:	f846 5b04 	str.w	r5, [r6], #4
 8002d0c:	d8fa      	bhi.n	8002d04 <memset+0x64>
 8002d0e:	1f22      	subs	r2, r4, #4
 8002d10:	f022 0203 	bic.w	r2, r2, #3
 8002d14:	3204      	adds	r2, #4
 8002d16:	4413      	add	r3, r2
 8002d18:	f004 0403 	and.w	r4, r4, #3
 8002d1c:	b12c      	cbz	r4, 8002d2a <memset+0x8a>
 8002d1e:	b2c9      	uxtb	r1, r1
 8002d20:	441c      	add	r4, r3
 8002d22:	f803 1b01 	strb.w	r1, [r3], #1
 8002d26:	42a3      	cmp	r3, r4
 8002d28:	d1fb      	bne.n	8002d22 <memset+0x82>
 8002d2a:	bcf0      	pop	{r4, r5, r6, r7}
 8002d2c:	4770      	bx	lr
 8002d2e:	4614      	mov	r4, r2
 8002d30:	4603      	mov	r3, r0
 8002d32:	e7c6      	b.n	8002cc2 <memset+0x22>
	...
$d():
 8002d40:	08060403 	.word	0x08060403
 8002d44:	2018100c 	.word	0x2018100c
 8002d48:	00000030 	.word	0x00000030
 8002d4c:	00000000 	.word	0x00000000
 8002d50:	03020100 	.word	0x03020100
 8002d54:	08070604 	.word	0x08070604
 8002d58:	00000009 	.word	0x00000009
 8002d5c:	03020100 	.word	0x03020100
 8002d60:	00000004 	.word	0x00000004
	...

08002d70 <BeepPillBad>:
 8002d70:	0aea0001 000000b4 092d0001 000000b4     ..........-.....
 8002d80:	07b70001 000100b4 00000000 00000000     ................
 8002d90:	2c582523 0a0d4125 70704100 00000000     #%X,%A...App....

08002da0 <BrrBrr>:
 8002da0:	00006300 0000b401 01006300 00000000     .c.......c......

08002db0 <BeepBeep>:
 8002db0:	07b70001 00000036 00000000 00000036     ....6.......6...
 8002dc0:	07b70001 00010036 00000000 00000000     ....6...........
 8002dd0:	62696843 6d724169 2074656c 3d424841     ChibiArmlet AHB=
 8002de0:	203b7525 31425041 3b75253d 42504120     %u; APB1=%u; APB
 8002df0:	75253d32 0000000d 00000000 00000000     2=%u............
 8002e00:	000d6425 6c764c72 00000031 00000000     %d..rLvl1.......
 8002e10:	31235653 23565300 56530032 53003323     SV#1.SV#2.SV#3.S
 8002e20:	00342356 35235653 23565300 56530036     V#4.SV#5.SV#6.SV
 8002e30:	53003723 00382356 39235653 23565300     #7.SV#8.SV#9.SV#
 8002e40:	53003031 31312356 00000000 00000000     10.SV#11........
 8002e50:	45686322 65527476 74736967 614d7265     "chEvtRegisterMa
 8002e60:	28226b73 63220029 74764568 65726e55     sk"()."chEvtUnre
 8002e70:	74736967 28227265 63220029 74764568     gister"()."chEvt
 8002e80:	6e676953 22496c61 22002928 76456863     SignalI"()."chEv
 8002e90:	6f724274 61636461 614d7473 22496b73     tBroadcastMaskI"
 8002ea0:	22002928 76456863 67695374 226c616e     ()."chEvtSignal"
 8002eb0:	22002928 76456863 73694474 63746170     ()."chEvtDispatc
 8002ec0:	29282268 45686300 69447476 74617073     h"().chEvtDispat
 8002ed0:	29286863 3123202c 00000000 00000000     ch(), #1........

08002ee0 <ch_debug>:
 8002ee0:	6e69616d 11801600 08340404 1814100c     main......4.....
 8002ef0:	0021201c 00002422 00000000 00000000     . !."$..........
 8002f00:	63536863 61655268 28497964 23202c29     chSchReadyI(), #
 8002f10:	74730031 206b6361 7265766f 776f6c66     1.stack overflow
	...
 8002f30:	53686322 6e496d65 28227469 63220029     "chSemInit"()."c
 8002f40:	6d655368 65736552 28224974 68630029     hSemResetI"().ch
 8002f50:	526d6553 74657365 2c292849 00312320     SemResetI(), #1.
 8002f60:	53686322 61576d65 22537469 63002928     "chSemWaitS"().c
 8002f70:	6d655368 74696157 2c292853 00312320     hSemWaitS(), #1.
 8002f80:	53686322 61576d65 69547469 756f656d     "chSemWaitTimeou
 8002f90:	28225374 68630029 576d6553 54746961     tS"().chSemWaitT
 8002fa0:	6f656d69 28537475 23202c29 63220031     imeoutS(), #1."c
 8002fb0:	6d655368 6e676953 28226c61 68630029     hSemSignal"().ch
 8002fc0:	536d6553 616e6769 2c29286c 00312320     SemSignal(), #1.
 8002fd0:	53686322 69536d65 6c616e67 29282249     "chSemSignalI"()
 8002fe0:	53686300 69536d65 6c616e67 2c292849     .chSemSignalI(),
 8002ff0:	00312320 53686322 64416d65 756f4364      #1."chSemAddCou
 8003000:	7265746e 29282249 53686300 64416d65     nterI"().chSemAd
 8003010:	756f4364 7265746e 2c292849 00312320     dCounterI(), #1.
 8003020:	53686322 69536d65 6c616e67 74696157     "chSemSignalWait
 8003030:	00292822 65536863 6769536d 576c616e     "().chSemSignalW
 8003040:	28746961 23202c29 68630031 536d6553     ait(), #1.chSemS
 8003050:	616e6769 6961576c 2c292874 00322320     ignalWait(), #2.
 8003060:	656c6469 00000000 00000000 00000000     idle............
 8003070:	54686322 72436468 65746165 29282249     "chThdCreateI"()
 8003080:	68632200 53646854 72507465 69726f69     ."chThdSetPriori
 8003090:	28227974 68630029 52646854 6d757365     ty"().chThdResum
 80030a0:	2c292865 00312320 54686322 6c536468     e(), #1."chThdSl
 80030b0:	22706565 63002928 64685468 74697845     eep"().chThdExit
 80030c0:	2c292853 00312320 54686322 61576468     S(), #1."chThdWa
 80030d0:	28227469 68630029 57646854 28746961     it"().chThdWait(
 80030e0:	23202c29 00000031 00000000 00000000     ), #1...........
 80030f0:	56686322 74655354 29282249 68632200     "chVTSetI"()."ch
 8003100:	65525456 49746573 00292822 54566863     VTResetI"().chVT
 8003110:	65736552 29284974 3123202c 00000000     ResetI(), #1....
 8003120:	616d6422 65727453 6c416d61 61636f6c     "dmaStreamAlloca
 8003130:	28226574 64220029 7453616d 6d616572     te"()."dmaStream
 8003140:	656c6552 22657361 64002928 7453616d     Release"().dmaSt
 8003150:	6d616572 656c6552 28657361 23202c29     reamRelease(), #
 8003160:	00000031 00000000 00000000 00000000     1...............

08003170 <_stm32_dma_streams>:
 8003170:	40026008 40026004 000b0000 4002601c     .`.@.`.@.....`.@
 8003180:	40026004 000c0104 40026030 40026004     .`.@....0`.@.`.@
 8003190:	000d0208 40026044 40026004 000e030c     ....D`.@.`.@....
 80031a0:	40026058 40026004 000f0410 4002606c     X`.@.`.@....l`.@
 80031b0:	40026004 00100514 40026080 40026004     .`.@.....`.@.`.@
 80031c0:	00110618                                ....
